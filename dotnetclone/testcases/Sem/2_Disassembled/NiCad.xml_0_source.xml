<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="84" endline="119">
{
switch (br.ReadByte())
{
case ELEMENT_TYPE_CLASS
case ELEMENT_TYPE_VALUETYPE
break;
default
throw new BadImageFormatException();
}
Type type = ReadTypeDefOrRefEncoded(module, br, context);
if (!type.IsGenericTypeDefinition)
{
throw new BadImageFormatException();
}
int genArgCount = br.ReadCompressedInt();
Type[] args = new Type[genArgCount];
Type[][] reqmod = null;
Type[][] optmod = null;
for (int i = 0; i < genArgCount; i++)
{
CustomModifiers mods = ReadCustomModifiers(module, br, context);
if (mods.required != null || mods.optional != null)
{
if (reqmod == null)
{
reqmod = new Type[genArgCount][];
optmod = new Type[genArgCount][];
}
reqmod[i] = mods.required;
optmod[i] = mods.optional;
}
args[i] = ReadType(module, br, context);
}
for (int i = 0; i < genArgCount; i++)
{
CustomModifiers mods = ReadCustomModifiers(module, br, context);
if (mods.required != null || mods.optional != null)
{
if (reqmod == null)
{
reqmod = new Type[genArgCount][];
optmod = new Type[genArgCount][];
}
reqmod[i] = mods.required;
optmod[i] = mods.optional;
}
args[i] = ReadType(module, br, context);
}
return GenericTypeInstance.Make(type, args, reqmod, optmod);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="137" endline="150">
internal static Type[] ReadMethodSpec(ModuleReader module, ByteReader br, IGenericContext context)
{
if (br.ReadByte() != GENERICINST)
{
throw new BadImageFormatException();
}
Type[] args = new Type[br.ReadCompressedInt()];
for (int i = 0; i < args.Length; i++)
{
args[i] = ReadType(module, br, context);
}
for (int i = 0; i < args.Length; i++)
{
args[i] = ReadType(module, br, context);
}
return args;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="151" endline="166">
private static int ReadArrayShape(ByteReader br)
{
int rank = br.ReadCompressedInt();
int numSizes = br.ReadCompressedInt();
for (int i = 0; i < numSizes; i++)
{
br.ReadCompressedInt();
}
for (int i = 0; i < numSizes; i++)
{
br.ReadCompressedInt();
}
int numLoBounds = br.ReadCompressedInt();
for (int i = 0; i < numLoBounds; i++)
{
br.ReadCompressedInt();
}
for (int i = 0; i < numLoBounds; i++)
{
br.ReadCompressedInt();
}
return rank;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="167" endline="179">
private static Type ReadTypeOrVoid(ModuleReader module, ByteReader br, IGenericContext context)
{
if (br.PeekByte() == ELEMENT_TYPE_VOID)
{
br.ReadByte();
return module.universe.System_Void;
}
else
{
return ReadType(module, br, context);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="180" endline="242">
protected static Type ReadType(ModuleReader module, ByteReader br, IGenericContext context)
{
CustomModifiers mods;
switch (br.ReadByte())
{
case ELEMENT_TYPE_CLASS
case ELEMENT_TYPE_VALUETYPE
return ReadTypeDefOrRefEncoded(module, br, context);
case ELEMENT_TYPE_BOOLEAN
return module.universe.System_Boolean;
case ELEMENT_TYPE_CHAR
return module.universe.System_Char;
case ELEMENT_TYPE_I1
return module.universe.System_SByte;
case ELEMENT_TYPE_U1
return module.universe.System_Byte;
case ELEMENT_TYPE_I2
return module.universe.System_Int16;
case ELEMENT_TYPE_U2
return module.universe.System_UInt16;
case ELEMENT_TYPE_I4
return module.universe.System_Int32;
case ELEMENT_TYPE_U4
return module.universe.System_UInt32;
case ELEMENT_TYPE_I8
return module.universe.System_Int64;
case ELEMENT_TYPE_U8
return module.universe.System_UInt64;
case ELEMENT_TYPE_R4
return module.universe.System_Single;
case ELEMENT_TYPE_R8
return module.universe.System_Double;
case ELEMENT_TYPE_I
return module.universe.System_IntPtr;
case ELEMENT_TYPE_U
return module.universe.System_UIntPtr;
case ELEMENT_TYPE_STRING
return module.universe.System_String;
case ELEMENT_TYPE_OBJECT
return module.universe.System_Object;
case ELEMENT_TYPE_VAR
return context.GetGenericTypeArgument(br.ReadCompressedInt());
case ELEMENT_TYPE_MVAR
return context.GetGenericMethodArgument(br.ReadCompressedInt());
case ELEMENT_TYPE_GENERICINST
return ReadGenericInst(module, br, context);
case ELEMENT_TYPE_SZARRAY
mods = ReadCustomModifiers(module, br, context);
return ReadType(module, br, context).__MakeArrayType(mods.required, mods.optional);
case ELEMENT_TYPE_ARRAY
mods = ReadCustomModifiers(module, br, context);
return ReadType(module, br, context).__MakeArrayType(ReadArrayShape(br), mods.required, mods.optional);
case ELEMENT_TYPE_PTR
mods = ReadCustomModifiers(module, br, context);
return ReadTypeOrVoid(module, br, context).__MakePointerType(mods.required, mods.optional);
case ELEMENT_TYPE_FNPTR
return ReadFunctionPointer(module, br, context);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="243" endline="272">
internal static void ReadLocalVarSig(ModuleReader module, ByteReader br, IGenericContext context, List<LocalVariableInfo> list)
{
if (br.Length < 2 || br.ReadByte() != LOCAL_SIG)
{
throw new BadImageFormatException("Invalid local variable signature");
}
int count = br.ReadCompressedInt();
for (int i = 0; i < count; i++)
{
if (br.PeekByte() == ELEMENT_TYPE_TYPEDBYREF)
{
br.ReadByte();
list.Add(new LocalVariableInfo(i, module.universe.System_TypedReference, false));
}
else
{
SkipCustomModifiers(br);
bool pinned = false;
if (br.PeekByte() == ELEMENT_TYPE_PINNED)
{
br.ReadByte();
pinned = true;
}
SkipCustomModifiers(br);
Type type = ReadTypeOrByRef(module, br, context);
list.Add(new LocalVariableInfo(i, type, pinned));
}
}
for (int i = 0; i < count; i++)
{
if (br.PeekByte() == ELEMENT_TYPE_TYPEDBYREF)
{
br.ReadByte();
list.Add(new LocalVariableInfo(i, module.universe.System_TypedReference, false));
}
else
{
SkipCustomModifiers(br);
bool pinned = false;
if (br.PeekByte() == ELEMENT_TYPE_PINNED)
{
br.ReadByte();
pinned = true;
}
SkipCustomModifiers(br);
Type type = ReadTypeOrByRef(module, br, context);
list.Add(new LocalVariableInfo(i, type, pinned));
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="273" endline="289">
private static Type ReadTypeOrByRef(ModuleReader module, ByteReader br, IGenericContext context)
{
if (br.PeekByte() == ELEMENT_TYPE_BYREF)
{
br.ReadByte();
CustomModifiers mods = ReadCustomModifiers(module, br, context);
return ReadTypeOrVoid(module, br, context).__MakeByRefType(mods.required, mods.optional);
}
else
{
return ReadType(module, br, context);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="290" endline="304">
protected static Type ReadRetType(ModuleReader module, ByteReader br, IGenericContext context)
{
switch (br.PeekByte())
{
case ELEMENT_TYPE_VOID
br.ReadByte();
return module.universe.System_Void;
case ELEMENT_TYPE_TYPEDBYREF
br.ReadByte();
return module.universe.System_TypedReference;
default
return ReadTypeOrByRef(module, br, context);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
{
switch (br.PeekByte())
{
case ELEMENT_TYPE_TYPEDBYREF
br.ReadByte();
return module.universe.System_TypedReference;
default
return ReadTypeOrByRef(module, br, context);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="317" endline="459">
protected static void WriteType(ModuleBuilder module, ByteBuffer bb, Type type)
{
while (type.HasElementType)
{
if (type.__IsVector)
{
bb.Write(ELEMENT_TYPE_SZARRAY);
}
else if (type.IsArray)
{
int rank = type.GetArrayRank();
bb.Write(ELEMENT_TYPE_ARRAY);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
WriteType(module, bb, type.GetElementType());
bb.WriteCompressedInt(rank);
bb.WriteCompressedInt(0);	// boundsCount
bb.WriteCompressedInt(rank);	// loCount
for (int i = 0; i < rank; i++)
{
bb.WriteCompressedInt(0);
}
for (int i = 0; i < rank; i++)
{
bb.WriteCompressedInt(0);
}
return;
}
else if (type.IsByRef)
{
bb.Write(ELEMENT_TYPE_BYREF);
}
else if (type.IsPointer)
{
bb.Write(ELEMENT_TYPE_PTR);
}
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
type = type.GetElementType();
}
while (type.HasElementType)
{
if (type.__IsVector)
{
bb.Write(ELEMENT_TYPE_SZARRAY);
}
else if (type.IsArray)
{
int rank = type.GetArrayRank();
bb.Write(ELEMENT_TYPE_ARRAY);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
WriteType(module, bb, type.GetElementType());
bb.WriteCompressedInt(rank);
bb.WriteCompressedInt(0);	// boundsCount
bb.WriteCompressedInt(rank);	// loCount
for (int i = 0; i < rank; i++)
{
bb.WriteCompressedInt(0);
}
return;
}
else if (type.IsByRef)
{
bb.Write(ELEMENT_TYPE_BYREF);
}
else if (type.IsPointer)
{
bb.Write(ELEMENT_TYPE_PTR);
}
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
type = type.GetElementType();
}
Universe u = module.universe;
if (type == u.System_Void)
{
bb.Write(ELEMENT_TYPE_VOID);
}
else if (type == u.System_Boolean)
{
bb.Write(ELEMENT_TYPE_BOOLEAN);
}
else if (type == u.System_Char)
{
bb.Write(ELEMENT_TYPE_CHAR);
}
else if (type == u.System_SByte)
{
bb.Write(ELEMENT_TYPE_I1);
}
else if (type == u.System_Byte)
{
bb.Write(ELEMENT_TYPE_U1);
}
else if (type == u.System_Int16)
{
bb.Write(ELEMENT_TYPE_I2);
}
else if (type == u.System_UInt16)
{
bb.Write(ELEMENT_TYPE_U2);
}
else if (type == u.System_Int32)
{
bb.Write(ELEMENT_TYPE_I4);
}
else if (type == u.System_UInt32)
{
bb.Write(ELEMENT_TYPE_U4);
}
else if (type == u.System_Int64)
{
bb.Write(ELEMENT_TYPE_I8);
}
else if (type == u.System_UInt64)
{
bb.Write(ELEMENT_TYPE_U8);
}
else if (type == u.System_Single)
{
bb.Write(ELEMENT_TYPE_R4);
}
else if (type == u.System_Double)
{
bb.Write(ELEMENT_TYPE_R8);
}
else if (type == u.System_String)
{
bb.Write(ELEMENT_TYPE_STRING);
}
else if (type == u.System_IntPtr)
{
bb.Write(ELEMENT_TYPE_I);
}
else if (type == u.System_UIntPtr)
{
bb.Write(ELEMENT_TYPE_U);
}
else if (type == u.System_TypedReference)
{
bb.Write(ELEMENT_TYPE_TYPEDBYREF);
}
else if (type == u.System_Object)
{
bb.Write(ELEMENT_TYPE_OBJECT);
}
else if (type.IsGenericParameter)
{
if (type is UnboundGenericMethodParameter || type.DeclaringMethod != null)
{
bb.Write(ELEMENT_TYPE_MVAR);
}
else
{
bb.Write(ELEMENT_TYPE_VAR);
}
bb.WriteCompressedInt(type.GenericParameterPosition);
}
else if (type.IsGenericType)
{
WriteGenericSignature(module, bb, type);
}
else
{
if (type.IsValueType)
{
bb.Write(ELEMENT_TYPE_VALUETYPE);
}
else
{
bb.Write(ELEMENT_TYPE_CLASS);
}
bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="460" endline="487">
private static void WriteGenericSignature(ModuleBuilder module, ByteBuffer bb, Type type)
{
Type[] typeArguments = type.GetGenericArguments();
Type[][] requiredCustomModifiers = type.__GetGenericArgumentsRequiredCustomModifiers();
Type[][] optionalCustomModifiers = type.__GetGenericArgumentsOptionalCustomModifiers();
if (!type.IsGenericTypeDefinition)
{
type = type.GetGenericTypeDefinition();
}
bb.Write(ELEMENT_TYPE_GENERICINST);
if (type.IsValueType)
{
bb.Write(ELEMENT_TYPE_VALUETYPE);
}
else
{
bb.Write(ELEMENT_TYPE_CLASS);
}
bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
bb.WriteCompressedInt(typeArguments.Length);
for (int i = 0; i < typeArguments.Length; i++)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
WriteType(module, bb, typeArguments[i]);
}
for (int i = 0; i < typeArguments.Length; i++)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
WriteType(module, bb, typeArguments[i]);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="488" endline="499">
protected static void WriteCustomModifiers(ModuleBuilder module, ByteBuffer bb, byte mod, Type[] modifiers)
{
if (modifiers != null)
{
foreach (Type type in modifiers)
{
bb.Write(mod);
bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
}
foreach (Type type in modifiers)
{
bb.Write(mod);
bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="505" endline="531">
struct CustomModifiers
{
internal Type[] required;
internal Type[] optional;
}
private static CustomModifiers ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context)
{
CustomModifiers mods = new CustomModifiers();
byte b = br.PeekByte();
if (IsCustomModifier(b))
{
List<Type> required = new List<Type>();
List<Type> optional = new List<Type>();
while (IsCustomModifier(b))
{
bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
Type type = ReadTypeDefOrRefEncoded(module, br, context);
(req ? required
b = br.PeekByte();
}
while (IsCustomModifier(b))
{
bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
Type type = ReadTypeDefOrRefEncoded(module, br, context);
(req ? required
b = br.PeekByte();
}
mods.required = required.ToArray();
mods.optional = optional.ToArray();
}
return mods;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="532" endline="542">
protected static void SkipCustomModifiers(ByteReader br)
{
byte b = br.PeekByte();
while (IsCustomModifier(b))
{
br.ReadByte();
br.ReadCompressedInt();
b = br.PeekByte();
}
while (IsCustomModifier(b))
{
br.ReadByte();
br.ReadCompressedInt();
b = br.PeekByte();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="543" endline="558">
private static Type ReadTypeDefOrRefEncoded(ModuleReader module, ByteReader br, IGenericContext context)
{
int encoded = br.ReadCompressedInt();
switch (encoded & 3)
{
case 0
return module.ResolveType((TypeDefTable.Index << 24) + (encoded >> 2), null, null);
case 1
return module.ResolveType((TypeRefTable.Index << 24) + (encoded >> 2), null, null);
case 2
return module.ResolveType((TypeSpecTable.Index << 24) + (encoded >> 2), context);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="559" endline="589">
protected static void ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context, out Type[] requiredCustomModifiers, out Type[] optionalCustomModifiers)
{
byte b = br.PeekByte();
if (IsCustomModifier(b))
{
List<Type> required = new List<Type>();
List<Type> optional = new List<Type>();
while (IsCustomModifier(b))
{
br.ReadByte();
Type type = ReadTypeDefOrRefEncoded(module, br, context);
if (b == ELEMENT_TYPE_CMOD_REQD)
{
required.Add(type);
}
else
{
optional.Add(type);
}
b = br.PeekByte();
}
while (IsCustomModifier(b))
{
br.ReadByte();
Type type = ReadTypeDefOrRefEncoded(module, br, context);
if (b == ELEMENT_TYPE_CMOD_REQD)
{
required.Add(type);
}
else
{
optional.Add(type);
}
b = br.PeekByte();
}
requiredCustomModifiers = required.ToArray();
optionalCustomModifiers = optional.ToArray();
}
else
{
requiredCustomModifiers = null;
optionalCustomModifiers = null;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="590" endline="618">
internal static void WriteStandAloneMethodSig(ModuleBuilder module, ByteBuffer bb, CallingConvention callingConvention, Type returnType, Type[] parameterTypes)
{
switch (callingConvention)
{
case CallingConvention.Cdecl
bb.Write((byte)0x01);	// C
break;
case CallingConvention.StdCall
case CallingConvention.Winapi
bb.Write((byte)0x02);	// STDCALL
break;
case CallingConvention.ThisCall
bb.Write((byte)0x03);	// THISCALL
break;
case CallingConvention.FastCall
bb.Write((byte)0x04);	// FASTCALL
break;
default
throw new ArgumentOutOfRangeException("callingConvention");
}
bb.WriteCompressedInt(parameterTypes.Length);
WriteType(module, bb, returnType);
foreach (Type t in parameterTypes)
{
WriteType(module, bb, t);
}
foreach (Type t in parameterTypes)
{
WriteType(module, bb, t);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="619" endline="651">
internal static void WriteStandAloneMethodSig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
{
byte flags = 0;
if ((callingConvention & CallingConventions.HasThis) != 0)
{
flags |= HASTHIS;
}
if ((callingConvention & CallingConventions.ExplicitThis) != 0)
{
flags |= EXPLICITTHIS;
}
if ((callingConvention & CallingConventions.VarArgs) != 0)
{
flags |= VARARG;
}
bb.Write(flags);
bb.WriteCompressedInt(parameterTypes.Length + optionalParameterTypes.Length);
WriteType(module, bb, returnType);
foreach (Type t in parameterTypes)
{
WriteType(module, bb, t);
}
foreach (Type t in parameterTypes)
{
WriteType(module, bb, t);
}
if (optionalParameterTypes.Length > 0)
{
bb.Write(SENTINEL);
foreach (Type t in optionalParameterTypes)
{
WriteType(module, bb, t);
}
foreach (Type t in optionalParameterTypes)
{
WriteType(module, bb, t);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="652" endline="665">
internal static void WriteLocalVarSig(ModuleBuilder module, ByteBuffer bb, IList<LocalBuilder> locals)
{
bb.Write(LOCAL_SIG);
bb.WriteCompressedInt(locals.Count);
foreach (LocalBuilder local in locals)
{
if (local.IsPinned)
{
bb.Write(ELEMENT_TYPE_PINNED);
}
WriteType(module, bb, local.LocalType);
}
foreach (LocalBuilder local in locals)
{
if (local.IsPinned)
{
bb.Write(ELEMENT_TYPE_PINNED);
}
WriteType(module, bb, local.LocalType);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="666" endline="704">
internal static void WritePropertySig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention,
Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
{
byte flags = PROPERTY;
if ((callingConvention & CallingConventions.HasThis) != 0)
{
flags |= HASTHIS;
}
if ((callingConvention & CallingConventions.ExplicitThis) != 0)
{
flags |= EXPLICITTHIS;
}
if ((callingConvention & CallingConventions.VarArgs) != 0)
{
flags |= VARARG;
}
bb.Write(flags);
bb.WriteCompressedInt(parameterTypes == null ? 0
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, returnTypeRequiredCustomModifiers);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, returnTypeOptionalCustomModifiers);
WriteType(module, bb, returnType);
if (parameterTypes != null)
{
for (int i = 0; i < parameterTypes.Length; i++)
{
if (parameterTypeRequiredCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
}
if (parameterTypeOptionalCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
}
WriteType(module, bb, parameterTypes[i]);
}
for (int i = 0; i < parameterTypes.Length; i++)
{
if (parameterTypeRequiredCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
}
if (parameterTypeOptionalCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
}
WriteType(module, bb, parameterTypes[i]);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="710" endline="719">
internal static void WriteMethodSpec(ModuleBuilder module, ByteBuffer bb, Type[] genArgs)
{
bb.Write(GENERICINST);
bb.WriteCompressedInt(genArgs.Length);
foreach (Type arg in genArgs)
{
WriteType(module, bb, arg);
}
foreach (Type arg in genArgs)
{
WriteType(module, bb, arg);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="720" endline="745">
internal static Type[] ReadOptionalParameterTypes(ModuleReader module, ByteReader br)
{
br.ReadByte();
int paramCount = br.ReadCompressedInt();
SkipCustomModifiers(br);
ReadRetType(module, br, null);
for (int i = 0; i < paramCount; i++)
{
if (br.PeekByte() == SENTINEL)
{
br.ReadByte();
Type[] types = new Type[paramCount - i];
for (int j = 0; j < types.Length; j++)
{
SkipCustomModifiers(br);
types[j] = ReadType(module, br, null);
}
for (int j = 0; j < types.Length; j++)
{
SkipCustomModifiers(br);
types[j] = ReadType(module, br, null);
}
return types;
}
SkipCustomModifiers(br);
ReadType(module, br, null);
}
for (int i = 0; i < paramCount; i++)
{
if (br.PeekByte() == SENTINEL)
{
br.ReadByte();
Type[] types = new Type[paramCount - i];
for (int j = 0; j < types.Length; j++)
{
SkipCustomModifiers(br);
types[j] = ReadType(module, br, null);
}
return types;
}
SkipCustomModifiers(br);
ReadType(module, br, null);
}
return Type.EmptyTypes;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="746" endline="759">
protected static Type[] BindTypeParameters(IGenericBinder binder, Type[] types)
{
if (types == null || types.Length == 0)
{
return Type.EmptyTypes;
}
Type[] expanded = new Type[types.Length];
for (int i = 0; i < types.Length; i++)
{
expanded[i] = types[i].BindTypeParameters(binder);
}
for (int i = 0; i < types.Length; i++)
{
expanded[i] = types[i].BindTypeParameters(binder);
}
return expanded;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="760" endline="773">
protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
{
if (types == null)
{
return null;
}
Type[][] expanded = new Type[types.Length][];
for (int i = 0; i < types.Length; i++)
{
expanded[i] = BindTypeParameters(binder, types[i]);
}
for (int i = 0; i < types.Length; i++)
{
expanded[i] = BindTypeParameters(binder, types[i]);
}
return expanded;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="774" endline="787">
protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
{
if (types == null)
{
return null;
}
Type[][][] expanded = new Type[types.Length][][];
for (int i = 0; i < types.Length; i++)
{
expanded[i] = BindTypeParameters(binder, types[i]);
}
for (int i = 0; i < types.Length; i++)
{
expanded[i] = BindTypeParameters(binder, types[i]);
}
return expanded;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="788" endline="796">
protected static Type[] BindTypeParameters(IGenericBinder binder, Type[][][] types, int index, int optOrReq)
{
if (types == null || types[index] == null)
{
return null;
}
return BindTypeParameters(binder, types[index][optOrReq]);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ModuleWriter.cs" startline="40" endline="300">
{
moduleBuilder.FixupMethodBodyTokens();
moduleBuilder.ModuleTable.Add(0, moduleBuilder.Strings.Add(moduleBuilder.moduleName), moduleBuilder.Guids.Add(moduleBuilder.ModuleVersionId), 0, 0);
if (moduleBuilder.UserStrings.IsEmpty)
{
moduleBuilder.UserStrings.Add(" ");
}
if (resources != null)
{
resources.Finish();
}
using (FileStream fs = new FileStream(moduleBuilder.FullyQualifiedName, FileMode.Create))
{
PEWriter writer = new PEWriter(fs);
switch (imageFileMachine)
{
case ImageFileMachine.I386
writer.Headers.FileHeader.Machine = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386;
writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_32BIT_MACHINE;
break;
case ImageFileMachine.AMD64
writer.Headers.FileHeader.Machine = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64;
writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_LARGE_ADDRESS_AWARE;
writer.Headers.FileHeader.SizeOfOptionalHeader = 0xF0;
writer.Headers.OptionalHeader.Magic = IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC;
writer.Headers.OptionalHeader.SizeOfStackReserve = 0x400000;
writer.Headers.OptionalHeader.SizeOfStackCommit = 0x4000;
writer.Headers.OptionalHeader.SizeOfHeapCommit = 0x2000;
break;
case ImageFileMachine.IA64
writer.Headers.FileHeader.Machine = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64;
writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_LARGE_ADDRESS_AWARE;
writer.Headers.FileHeader.SizeOfOptionalHeader = 0xF0;
writer.Headers.OptionalHeader.Magic = IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC;
writer.Headers.OptionalHeader.SizeOfStackReserve = 0x400000;
writer.Headers.OptionalHeader.SizeOfStackCommit = 0x4000;
writer.Headers.OptionalHeader.SizeOfHeapCommit = 0x2000;
break;
default
throw new ArgumentOutOfRangeException("imageFileMachine");
}
if (fileKind == PEFileKinds.Dll)
{
writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_DLL;
}
switch (fileKind)
{
case PEFileKinds.WindowApplication
writer.Headers.OptionalHeader.Subsystem = IMAGE_OPTIONAL_HEADER.IMAGE_SUBSYSTEM_WINDOWS_GUI;
break;
default
writer.Headers.OptionalHeader.Subsystem = IMAGE_OPTIONAL_HEADER.IMAGE_SUBSYSTEM_WINDOWS_CUI;
break;
}
writer.Headers.OptionalHeader.DllCharacteristics =
IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE |
IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NO_SEH |
IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NX_COMPAT |
IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
CliHeader cliHeader = new CliHeader();
cliHeader.Cb = 0x48;
cliHeader.MajorRuntimeVersion = 2;
cliHeader.MinorRuntimeVersion = moduleBuilder.MDStreamVersion < 0x20000 ? (ushort)0
if ((portableExecutableKind & PortableExecutableKinds.ILOnly) != 0)
{
cliHeader.Flags |= CliHeader.COMIMAGE_FLAGS_ILONLY;
}
if ((portableExecutableKind & PortableExecutableKinds.Required32Bit) != 0)
{
cliHeader.Flags |= CliHeader.COMIMAGE_FLAGS_32BITREQUIRED;
}
if (keyPair != null)
{
cliHeader.Flags |= CliHeader.COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
if (moduleBuilder.IsPseudoToken(entryPointToken))
{
entryPointToken = moduleBuilder.ResolvePseudoToken(entryPointToken);
}
cliHeader.EntryPointToken = (uint)entryPointToken;
moduleBuilder.Strings.Freeze();
moduleBuilder.UserStrings.Freeze();
moduleBuilder.Guids.Freeze();
moduleBuilder.Blobs.Freeze();
MetadataWriter mw = new MetadataWriter(moduleBuilder, fs);
moduleBuilder.Tables.Freeze(mw);
TextSection code = new TextSection(writer, cliHeader, moduleBuilder, ComputeStrongNameSignatureLength(publicKey));
writer.Headers.OptionalHeader.DataDirectory[1].VirtualAddress = code.ImportDirectoryRVA;
writer.Headers.OptionalHeader.DataDirectory[1].Size = code.ImportDirectoryLength;
writer.Headers.OptionalHeader.DataDirectory[12].VirtualAddress = code.ImportAddressTableRVA;
writer.Headers.OptionalHeader.DataDirectory[12].Size = code.ImportAddressTableLength;
writer.Headers.OptionalHeader.DataDirectory[14].VirtualAddress = code.ComDescriptorRVA;
writer.Headers.OptionalHeader.DataDirectory[14].Size = code.ComDescriptorLength;
if (code.DebugDirectoryLength != 0)
{
writer.Headers.OptionalHeader.DataDirectory[6].VirtualAddress = code.DebugDirectoryRVA;
writer.Headers.OptionalHeader.DataDirectory[6].Size = code.DebugDirectoryLength;
}
writer.Headers.FileHeader.NumberOfSections = 2;
if (moduleBuilder.initializedData.Length != 0)
{
writer.Headers.FileHeader.NumberOfSections++;
}
if (resources != null && resources.Length != 0)
{
writer.Headers.FileHeader.NumberOfSections++;
}
SectionHeader text = new SectionHeader();
text.Name = ".text";
text.VirtualAddress = code.BaseRVA;
text.VirtualSize = (uint)code.Length;
text.PointerToRawData = code.PointerToRawData;
text.SizeOfRawData = writer.ToFileAlignment((uint)code.Length);
text.Characteristics = SectionHeader.IMAGE_SCN_CNT_CODE | SectionHeader.IMAGE_SCN_MEM_EXECUTE | SectionHeader.IMAGE_SCN_MEM_READ;
SectionHeader sdata = new SectionHeader();
sdata.Name = ".sdata";
sdata.VirtualAddress = text.VirtualAddress + writer.ToSectionAlignment(text.VirtualSize);
sdata.VirtualSize = (uint)moduleBuilder.initializedData.Length;
sdata.PointerToRawData = text.PointerToRawData + text.SizeOfRawData;
sdata.SizeOfRawData = writer.ToFileAlignment((uint)moduleBuilder.initializedData.Length);
sdata.Characteristics = SectionHeader.IMAGE_SCN_CNT_INITIALIZED_DATA | SectionHeader.IMAGE_SCN_MEM_READ | SectionHeader.IMAGE_SCN_MEM_WRITE;
SectionHeader rsrc = new SectionHeader();
rsrc.Name = ".rsrc";
rsrc.VirtualAddress = sdata.VirtualAddress + writer.ToSectionAlignment(sdata.VirtualSize);
rsrc.PointerToRawData = sdata.PointerToRawData + sdata.SizeOfRawData;
rsrc.VirtualSize = resources == null ? 0
rsrc.SizeOfRawData = writer.ToFileAlignment(rsrc.VirtualSize);
rsrc.Characteristics = SectionHeader.IMAGE_SCN_MEM_READ | SectionHeader.IMAGE_SCN_CNT_INITIALIZED_DATA;
if (rsrc.SizeOfRawData != 0)
{
writer.Headers.OptionalHeader.DataDirectory[2].VirtualAddress = rsrc.VirtualAddress;
writer.Headers.OptionalHeader.DataDirectory[2].Size = rsrc.VirtualSize;
}
SectionHeader reloc = new SectionHeader();
reloc.Name = ".reloc";
reloc.VirtualAddress = rsrc.VirtualAddress + writer.ToSectionAlignment(rsrc.VirtualSize);
reloc.VirtualSize = 12;
reloc.PointerToRawData = rsrc.PointerToRawData + rsrc.SizeOfRawData;
reloc.SizeOfRawData = writer.ToFileAlignment(reloc.VirtualSize);
reloc.Characteristics = SectionHeader.IMAGE_SCN_MEM_READ | SectionHeader.IMAGE_SCN_CNT_INITIALIZED_DATA | SectionHeader.IMAGE_SCN_MEM_DISCARDABLE;
writer.Headers.OptionalHeader.DataDirectory[5].VirtualAddress = reloc.VirtualAddress;
writer.Headers.OptionalHeader.DataDirectory[5].Size = reloc.VirtualSize;
writer.Headers.OptionalHeader.SizeOfCode = text.SizeOfRawData;
writer.Headers.OptionalHeader.SizeOfInitializedData = sdata.SizeOfRawData + rsrc.SizeOfRawData + reloc.SizeOfRawData;
writer.Headers.OptionalHeader.SizeOfUninitializedData = 0;
writer.Headers.OptionalHeader.SizeOfImage = reloc.VirtualAddress + writer.ToSectionAlignment(reloc.VirtualSize);
writer.Headers.OptionalHeader.SizeOfHeaders = text.PointerToRawData;
writer.Headers.OptionalHeader.BaseOfCode = code.BaseRVA;
writer.Headers.OptionalHeader.BaseOfData = sdata.VirtualAddress;
writer.Headers.OptionalHeader.ImageBase = (ulong)moduleBuilder.__ImageBase;
if (imageFileMachine == ImageFileMachine.IA64)
{
writer.Headers.OptionalHeader.AddressOfEntryPoint = code.StartupStubRVA + 0x20;
}
else
{
writer.Headers.OptionalHeader.AddressOfEntryPoint = code.StartupStubRVA;
}
writer.WritePEHeaders();
writer.WriteSectionHeader(text);
if (sdata.SizeOfRawData != 0)
{
writer.WriteSectionHeader(sdata);
}
if (rsrc.SizeOfRawData != 0)
{
writer.WriteSectionHeader(rsrc);
}
writer.WriteSectionHeader(reloc);
fs.Seek(text.PointerToRawData, SeekOrigin.Begin);
code.Write(mw, (int)sdata.VirtualAddress);
fs.Seek(sdata.PointerToRawData, SeekOrigin.Begin);
mw.Write(moduleBuilder.initializedData);
if (rsrc.SizeOfRawData != 0)
{
fs.Seek(rsrc.PointerToRawData, SeekOrigin.Begin);
resources.Write(mw, rsrc.VirtualAddress);
}
fs.Seek(reloc.PointerToRawData, SeekOrigin.Begin);
uint relocAddress = code.StartupStubRVA;
switch (imageFileMachine)
{
case ImageFileMachine.I386
case ImageFileMachine.AMD64
relocAddress += 2;
break;
case ImageFileMachine.IA64
relocAddress += 0x20;
break;
}
uint pageRVA = relocAddress & ~0xFFFU;
mw.Write(pageRVA);	// PageRVA
mw.Write(0x000C);	// Block Size
if (imageFileMachine == ImageFileMachine.I386)
{
mw.Write(0x3000 + relocAddress - pageRVA);				// Type / Offset
}
else if (imageFileMachine == ImageFileMachine.AMD64)
{
mw.Write(0xA000 + relocAddress - pageRVA);				// Type / Offset
}
else if (imageFileMachine == ImageFileMachine.IA64)
{
mw.Write((short)(0xA000 + relocAddress - pageRVA));		// Type / Offset
mw.Write((short)(0xA000 + relocAddress - pageRVA + 8));	// Type / Offset
}
mw.Write(new byte[writer.Headers.OptionalHeader.FileAlignment - reloc.VirtualSize]);
if (keyPair != null)
{
StrongName(fs, keyPair, writer.HeaderSize, text.PointerToRawData, code.StrongNameSignatureRVA - text.VirtualAddress + text.PointerToRawData, code.StrongNameSignatureLength);
}
}
if (moduleBuilder.symbolWriter != null)
{
moduleBuilder.WriteSymbolTokenMap();
moduleBuilder.symbolWriter.Close();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ModuleWriter.cs" startline="301" endline="319">
private static int ComputeStrongNameSignatureLength(byte[] publicKey)
{
if (publicKey == null)
{
return 0;
}
else if (publicKey.Length == 16)
{
return 128;
}
else
{
return publicKey.Length - 32;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ModuleWriter.cs" startline="320" endline="370">
private static void StrongName(FileStream fs, StrongNameKeyPair keyPair, uint headerLength, uint textSectionFileOffset, uint strongNameSignatureFileOffset, uint strongNameSignatureLength)
{
SHA1Managed hash = new SHA1Managed();
using (CryptoStream cs = new CryptoStream(Stream.Null, hash, CryptoStreamMode.Write))
{
fs.Seek(0, SeekOrigin.Begin);
byte[] buf = new byte[8192];
HashChunk(fs, cs, buf, (int)headerLength);
fs.Seek(textSectionFileOffset, SeekOrigin.Begin);
HashChunk(fs, cs, buf, (int)(strongNameSignatureFileOffset - textSectionFileOffset));
fs.Seek(strongNameSignatureLength, SeekOrigin.Current);
HashChunk(fs, cs, buf, (int)(fs.Length - (strongNameSignatureFileOffset + strongNameSignatureLength)));
}
using (RSA rsa = CryptoHack.CreateRSA(keyPair))
{
RSAPKCS1SignatureFormatter sign = new RSAPKCS1SignatureFormatter(rsa);
byte[] signature = sign.CreateSignature(hash);
Array.Reverse(signature);
if (signature.Length != strongNameSignatureLength)
{
throw new InvalidOperationException("Signature length mismatch");
}
fs.Seek(strongNameSignatureFileOffset, SeekOrigin.Begin);
fs.Write(signature, 0, signature.Length);
}
fs.Seek(0, SeekOrigin.Begin);
int count = (int)fs.Length / 4;
BinaryReader br = new BinaryReader(fs);
long sum = 0;
for (int i = 0; i < count; i++)
{
sum += br.ReadUInt32();
int carry = (int)(sum >> 32);
sum &= 0xFFFFFFFFU;
sum += carry;
}
for (int i = 0; i < count; i++)
{
sum += br.ReadUInt32();
int carry = (int)(sum >> 32);
sum &= 0xFFFFFFFFU;
sum += carry;
}
while ((sum >> 16) != 0)
{
sum = (sum & 0xFFFF) + (sum >> 16);
}
while ((sum >> 16) != 0)
{
sum = (sum & 0xFFFF) + (sum >> 16);
}
sum += fs.Length;
ByteBuffer bb = new ByteBuffer(4);
bb.Write((int)sum);
fs.Seek(0xD8, SeekOrigin.Begin);
bb.WriteTo(fs);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ModuleWriter.cs" startline="371" endline="380">
internal static void HashChunk(FileStream fs, CryptoStream cs, byte[] buf, int length)
{
while (length > 0)
{
int read = fs.Read(buf, 0, Math.Min(buf.Length, length));
cs.Write(buf, 0, read);
length -= read;
}
while (length > 0)
{
int read = fs.Read(buf, 0, Math.Min(buf.Length, length));
cs.Write(buf, 0, read);
length -= read;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\MetadataRW.cs" startline="58" endline="86">
protected MetadataRW(Module module, bool bigStrings, bool bigGuids, bool bigBlobs)
{
this.bigStrings = bigStrings;
this.bigGuids = bigGuids;
this.bigBlobs = bigBlobs;
this.bigField = module.Field.IsBig;
this.bigMethodDef = module.MethodDef.IsBig;
this.bigParam = module.Param.IsBig;
this.bigTypeDef = module.TypeDef.IsBig;
this.bigProperty = module.Property.IsBig;
this.bigEvent = module.Event.IsBig;
this.bigGenericParam = module.GenericParam.IsBig;
this.bigModuleRef = module.ModuleRef.IsBig;
this.bigResolutionScope = IsBig(2, module.ModuleTable, module.ModuleRef, module.AssemblyRef, module.TypeRef);
this.bigTypeDefOrRef = IsBig(2, module.TypeDef, module.TypeRef, module.TypeSpec);
this.bigMemberRefParent = IsBig(3, module.TypeDef, module.TypeRef, module.ModuleRef, module.MethodDef, module.TypeSpec);
this.bigMethodDefOrRef = IsBig(1, module.MethodDef, module.MemberRef);
this.bigHasCustomAttribute = IsBig(5, module.MethodDef, module.Field, module.TypeRef, module.TypeDef, module.Param, module.InterfaceImpl, module.MemberRef,
module.ModuleTable, /*module.Permission,*/ module.Property, module.Event, module.StandAloneSig, module.ModuleRef, module.TypeSpec, module.AssemblyTable,
module.AssemblyRef, module.File, module.ExportedType, module.ManifestResource);
this.bigCustomAttributeType = IsBig(3, module.MethodDef, module.MemberRef);
this.bigHasConstant = IsBig(2, module.Field, module.Param, module.Property);
this.bigHasSemantics = IsBig(1, module.Event, module.Property);
this.bigHasFieldMarshal = IsBig(1, module.Field, module.Param);
this.bigHasDeclSecurity = IsBig(2, module.TypeDef, module.MethodDef, module.AssemblyTable);
this.bigTypeOrMethodDef = IsBig(1, module.TypeDef, module.MethodDef);
this.bigMemberForwarded = IsBig(1, module.Field, module.MethodDef);
this.bigImplementation = IsBig(2, module.File, module.AssemblyRef, module.ExportedType);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\MetadataRW.cs" startline="87" endline="99">
private static bool IsBig(int bitsUsed, params Table[] tables)
{
int limit = 1 << (16 - bitsUsed);
foreach (Table table in tables)
{
if (table.RowCount >= limit)
{
return true;
}
}
foreach (Table table in tables)
{
if (table.RowCount >= limit)
{
return true;
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="37" endline="44">
private readonly byte[] buffer = new byte[8];
internal MetadataWriter(ModuleBuilder module, Stream stream)
{
this.moduleBuilder = module;
this.stream = stream;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="75" endline="81">
internal void Write(short value)
{
buffer[0] = (byte)value;
buffer[1] = (byte)(value >> 8);
stream.Write(buffer, 0, 2);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="87" endline="95">
internal void Write(int value)
{
buffer[0] = (byte)value;
buffer[1] = (byte)(value >> 8);
buffer[2] = (byte)(value >> 16);
buffer[3] = (byte)(value >> 24);
stream.Write(buffer, 0, 4);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="101" endline="113">
internal void Write(long value)
{
buffer[0] = (byte)value;
buffer[1] = (byte)(value >> 8);
buffer[2] = (byte)(value >> 16);
buffer[3] = (byte)(value >> 24);
buffer[4] = (byte)(value >> 32);
buffer[5] = (byte)(value >> 40);
buffer[6] = (byte)(value >> 48);
buffer[7] = (byte)(value >> 56);
stream.Write(buffer, 0, 8);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="114" endline="133">
internal void WriteCompressedInt(int value)
{
if (value <= 0x7F)
{
Write((byte)value);
}
else if (value <= 0x3FFF)
{
Write((byte)(0x80 | (value >> 8)));
Write((byte)value);
}
else
{
Write((byte)(0xC0 | (value >> 24)));
Write((byte)(value >> 16));
Write((byte)(value >> 8));
Write((byte)value);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="134" endline="149">
internal static int GetCompressedIntLength(int value)
{
if (value <= 0x7F)
{
return 1;
}
else if (value <= 0x3FFF)
{
return 2;
}
else
{
return 4;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="150" endline="161">
internal void WriteStringIndex(int index)
{
if (bigStrings)
{
Write(index);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="162" endline="173">
internal void WriteGuidIndex(int index)
{
if (bigGuids)
{
Write(index);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="174" endline="185">
internal void WriteBlobIndex(int index)
{
if (bigBlobs)
{
Write(index);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="186" endline="213">
internal void WriteTypeDefOrRef(int token)
{
switch (token >> 24)
{
case 0
break;
case TypeDefTable.Index
token = (token & 0xFFFFFF) << 2 | 0;
break;
case TypeRefTable.Index
token = (token & 0xFFFFFF) << 2 | 1;
break;
case TypeSpecTable.Index
token = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
if (bigTypeDefOrRef)
{
Write(token);
}
else
{
Write((short)token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="214" endline="225">
internal void WriteEncodedTypeDefOrRef(int encodedToken)
{
if (bigTypeDefOrRef)
{
Write(encodedToken);
}
else
{
Write((short)encodedToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="226" endline="239">
internal void WriteHasCustomAttribute(int encodedToken)
{
if (bigHasCustomAttribute)
{
Write(encodedToken);
}
else
{
Write((short)encodedToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="240" endline="262">
internal void WriteCustomAttributeType(int token)
{
switch (token >> 24)
{
case MethodDefTable.Index
token = (token & 0xFFFFFF) << 3 | 2;
break;
case MemberRefTable.Index
token = (token & 0xFFFFFF) << 3 | 3;
break;
default
throw new InvalidOperationException();
}
if (bigCustomAttributeType)
{
Write(token);
}
else
{
Write((short)token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="263" endline="274">
internal void WriteField(int index)
{
if (bigField)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="275" endline="286">
internal void WriteMethodDef(int index)
{
if (bigMethodDef)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="287" endline="298">
internal void WriteParam(int index)
{
if (bigParam)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="299" endline="310">
internal void WriteTypeDef(int index)
{
if (bigTypeDef)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="311" endline="322">
internal void WriteEvent(int index)
{
if (bigEvent)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="323" endline="334">
internal void WriteProperty(int index)
{
if (bigProperty)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="335" endline="346">
internal void WriteGenericParam(int index)
{
if (bigGenericParam)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="347" endline="358">
internal void WriteModuleRef(int index)
{
if (bigModuleRef)
{
Write(index & 0xFFFFFF);
}
else
{
Write((short)index);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="359" endline="387">
internal void WriteResolutionScope(int token)
{
switch (token >> 24)
{
case ModuleTable.Index
token = (token & 0xFFFFFF) << 2 | 0;
break;
case ModuleRefTable.Index
token = (token & 0xFFFFFF) << 2 | 1;
break;
case AssemblyRefTable.Index
token = (token & 0xFFFFFF) << 2 | 2;
break;
case TypeRefTable.Index
token = (token & 0xFFFFFF) << 2 | 3;
break;
default
throw new InvalidOperationException();
}
if (bigResolutionScope)
{
Write(token);
}
else
{
Write((short)token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="388" endline="419">
internal void WriteMemberRefParent(int token)
{
switch (token >> 24)
{
case TypeDefTable.Index
token = (token & 0xFFFFFF) << 3 | 0;
break;
case TypeRefTable.Index
token = (token & 0xFFFFFF) << 3 | 1;
break;
case ModuleRefTable.Index
token = (token & 0xFFFFFF) << 3 | 2;
break;
case MethodDefTable.Index
token = (token & 0xFFFFFF) << 3 | 3;
break;
case TypeSpecTable.Index
token = (token & 0xFFFFFF) << 3 | 4;
break;
default
throw new InvalidOperationException();
}
if (bigMemberRefParent)
{
Write(token);
}
else
{
Write((short)token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="420" endline="442">
internal void WriteMethodDefOrRef(int token)
{
switch (token >> 24)
{
case MethodDefTable.Index
token = (token & 0xFFFFFF) << 1 | 0;
break;
case MemberRefTable.Index
token = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
if (bigMethodDefOrRef)
{
Write(token);
}
else
{
Write((short)token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
internal void WriteHasConstant(int encodedToken)
{
if (bigHasConstant)
{
Write(encodedToken);
}
else
{
Write((short)encodedToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="457" endline="470">
internal void WriteHasSemantics(int encodedToken)
{
if (bigHasSemantics)
{
Write(encodedToken);
}
else
{
Write((short)encodedToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="471" endline="498">
internal void WriteImplementation(int token)
{
switch (token >> 24)
{
case 0
break;
case FileTable.Index
token = (token & 0xFFFFFF) << 2 | 0;
break;
case AssemblyRefTable.Index
token = (token & 0xFFFFFF) << 2 | 1;
break;
case ExportedTypeTable.Index
token = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
if (bigImplementation)
{
Write(token);
}
else
{
Write((short)token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="499" endline="512">
internal void WriteTypeOrMethodDef(int encodedToken)
{
if (bigTypeOrMethodDef)
{
Write(encodedToken);
}
else
{
Write((short)encodedToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="513" endline="526">
internal void WriteHasDeclSecurity(int encodedToken)
{
if (bigHasDeclSecurity)
{
Write(encodedToken);
}
else
{
Write((short)encodedToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="527" endline="549">
internal void WriteMemberForwarded(int token)
{
switch (token >> 24)
{
case FieldTable.Index
token = (token & 0xFFFFFF) << 1 | 0;
break;
case MethodDefTable.Index
token = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
if (bigMemberForwarded)
{
Write(token);
}
else
{
Write((short)token);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="550" endline="563">
internal void WriteHasFieldMarshal(int encodedToken)
{
if (bigHasFieldMarshal)
{
Write(encodedToken & 0xFFFFFF);
}
else
{
Write((short)encodedToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MemberInfo.cs" startline="43" endline="53">
}
public abstract Module Module
{
get;
}
public bool IsDefined(Type attributeType, bool inherit)
{
return CustomAttributeData.__GetCustomAttributes(this, attributeType, inherit).Count != 0;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="62" endline="77">
}
public abstract Type BaseType
{
get;
}
public abstract TypeAttributes Attributes
{
get;
}
public virtual Type GetElementType()
{
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="151" endline="160">
}
public virtual bool IsValueType
{
get
{
Type baseType = this.BaseType;
return baseType == this.Module.universe.System_Enum
|| (baseType == this.Module.universe.System_ValueType && this != this.Module.universe.System_Enum);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="186" endline="194">
}
public override string Name
{
get
{
string fullname = FullName;
return fullname.Substring(fullname.LastIndexOf('.') + 1);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="195" endline="208">
}
public virtual string Namespace
{
get
{
if (IsNested)
{
return null;
}
string fullname = FullName;
int index = fullname.LastIndexOf('.');
return index < 0 ? null
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="265" endline="283">
}
public virtual bool ContainsGenericParameters
{
get
{
if (this.IsGenericParameter)
{
return true;
}
foreach (Type arg in this.GetGenericArguments())
{
if (arg.ContainsGenericParameters)
{
return true;
}
}
foreach (Type arg in this.GetGenericArguments())
{
if (arg.ContainsGenericParameters)
{
return true;
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="299" endline="310">
}
public virtual Type GetEnumUnderlyingType()
{
if (!this.IsEnum)
{
throw new ArgumentException();
}
CheckBaked();
return GetEnumUnderlyingTypeImpl();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="311" endline="323">
internal Type GetEnumUnderlyingTypeImpl()
{
foreach (FieldInfo field in __GetDeclaredFields())
{
if (!field.IsStatic)
{
return field.FieldType;
}
}
foreach (FieldInfo field in __GetDeclaredFields())
{
if (!field.IsStatic)
{
return field.FieldType;
}
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="329" endline="358">
public virtual string FullName
{
get
{
Type decl = this.DeclaringType;
string ns = this.Namespace;
if (ns == null)
{
if (decl == null)
{
return this.Name;
}
else
{
return decl.FullName + "+" + this.Name;
}
}
else
{
if (decl == null)
{
return ns + "." + this.Name;
}
else
{
return decl.FullName + "+" + ns + "." + this.Name;
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="369" endline="382">
}
public MemberInfo[] GetDefaultMembers()
{
Type defaultMemberAttribute = this.Module.universe.Import(typeof(System.Reflection.DefaultMemberAttribute));
foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(this))
{
if (cad.Constructor.DeclaringType.Equals(defaultMemberAttribute))
{
return GetMember((string)cad.ConstructorArguments[0].Value);
}
}
foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(this))
{
if (cad.Constructor.DeclaringType.Equals(defaultMemberAttribute))
{
return GetMember((string)cad.ConstructorArguments[0].Value);
}
}
return Empty<MemberInfo>.Array;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="398" endline="409">
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
{
List<MemberInfo> members = new List<MemberInfo>();
members.AddRange(GetConstructors(bindingAttr));
members.AddRange(GetMethods(bindingAttr));
members.AddRange(GetFields(bindingAttr));
members.AddRange(GetProperties(bindingAttr));
members.AddRange(GetEvents(bindingAttr));
members.AddRange(GetNestedTypes(bindingAttr));
return members.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="416" endline="426">
private static void AddMembers(List<MemberInfo> list, MemberFilter filter, object filterCriteria, MemberInfo[] members)
{
foreach (MemberInfo member in members)
{
if (filter == null || filter(member, filterCriteria))
{
list.Add(member);
}
}
foreach (MemberInfo member in members)
{
if (filter == null || filter(member, filterCriteria))
{
list.Add(member);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="427" endline="456">
public MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria)
{
List<MemberInfo> members = new List<MemberInfo>();
if ((memberType & MemberTypes.Constructor) != 0)
{
AddMembers(members, filter, filterCriteria, GetConstructors(bindingAttr));
}
if ((memberType & MemberTypes.Method) != 0)
{
AddMembers(members, filter, filterCriteria, GetMethods(bindingAttr));
}
if ((memberType & MemberTypes.Field) != 0)
{
AddMembers(members, filter, filterCriteria, GetFields(bindingAttr));
}
if ((memberType & MemberTypes.Property) != 0)
{
AddMembers(members, filter, filterCriteria, GetProperties(bindingAttr));
}
if ((memberType & MemberTypes.Event) != 0)
{
AddMembers(members, filter, filterCriteria, GetEvents(bindingAttr));
}
if ((memberType & MemberTypes.NestedType) != 0)
{
AddMembers(members, filter, filterCriteria, GetNestedTypes(bindingAttr));
}
return members.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="462" endline="473">
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
{
foreach (EventInfo evt in GetEvents(bindingAttr))
{
if (evt.Name == name)
{
return evt;
}
}
foreach (EventInfo evt in GetEvents(bindingAttr))
{
if (evt.Name == name)
{
return evt;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="479" endline="509">
public EventInfo[] GetEvents(BindingFlags bindingAttr)
{
List<EventInfo> list = new List<EventInfo>();
Type type = this;
while (type != null)
{
type.CheckBaked();
foreach (EventInfo evt in type.__GetDeclaredEvents())
{
if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(evt);
}
}
foreach (EventInfo evt in type.__GetDeclaredEvents())
{
if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(evt);
}
}
if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
{
if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
{
bindingAttr &= ~BindingFlags.Static;
}
type = type.BaseType;
}
else
{
break;
}
}
while (type != null)
{
type.CheckBaked();
foreach (EventInfo evt in type.__GetDeclaredEvents())
{
if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(evt);
}
}
if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
{
if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
{
bindingAttr &= ~BindingFlags.Static;
}
type = type.BaseType;
}
else
{
break;
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="515" endline="526">
public FieldInfo GetField(string name, BindingFlags bindingAttr)
{
foreach (FieldInfo field in GetFields(bindingAttr))
{
if (field.Name == name)
{
return field;
}
}
foreach (FieldInfo field in GetFields(bindingAttr))
{
if (field.Name == name)
{
return field;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="532" endline="561">
public FieldInfo[] GetFields(BindingFlags bindingAttr)
{
List<FieldInfo> list = new List<FieldInfo>();
CheckBaked();
foreach (FieldInfo field in __GetDeclaredFields())
{
if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(field);
}
}
foreach (FieldInfo field in __GetDeclaredFields())
{
if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(field);
}
}
if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
{
for (Type type = this.BaseType; type != null; type = type.BaseType)
{
type.CheckBaked();
foreach (FieldInfo field in type.__GetDeclaredFields())
{
if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
{
list.Add(field);
}
}
foreach (FieldInfo field in type.__GetDeclaredFields())
{
if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
{
list.Add(field);
}
}
}
for (Type type = this.BaseType; type != null; type = type.BaseType)
{
type.CheckBaked();
foreach (FieldInfo field in type.__GetDeclaredFields())
{
if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
{
list.Add(field);
}
}
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="562" endline="571">
public Type[] GetInterfaces()
{
List<Type> list = new List<Type>();
for (Type type = this; type != null; type = type.BaseType)
{
AddInterfaces(list, type);
}
for (Type type = this; type != null; type = type.BaseType)
{
AddInterfaces(list, type);
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="572" endline="584">
private static void AddInterfaces(List<Type> list, Type type)
{
type.CheckBaked();
foreach (Type iface in type.__GetDeclaredInterfaces())
{
if (!list.Contains(iface))
{
list.Add(iface);
AddInterfaces(list, iface);
}
}
foreach (Type iface in type.__GetDeclaredInterfaces())
{
if (!list.Contains(iface))
{
list.Add(iface);
AddInterfaces(list, iface);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="585" endline="620">
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
{
CheckBaked();
List<MethodInfo> list = new List<MethodInfo>();
foreach (MethodBase mb in __GetDeclaredMethods())
{
MethodInfo mi = mb as MethodInfo;
if (mi != null
&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(mi);
}
}
foreach (MethodBase mb in __GetDeclaredMethods())
{
MethodInfo mi = mb as MethodInfo;
if (mi != null
&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(mi);
}
}
if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
{
for (Type type = this.BaseType; type != null; type = type.BaseType)
{
type.CheckBaked();
foreach (MethodBase mb in type.__GetDeclaredMethods())
{
MethodInfo mi = mb as MethodInfo;
if (mi != null
&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
&& !FindMethod(list, mi))
{
list.Add(mi);
}
}
foreach (MethodBase mb in type.__GetDeclaredMethods())
{
MethodInfo mi = mb as MethodInfo;
if (mi != null
&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
&& !FindMethod(list, mi))
{
list.Add(mi);
}
}
}
for (Type type = this.BaseType; type != null; type = type.BaseType)
{
type.CheckBaked();
foreach (MethodBase mb in type.__GetDeclaredMethods())
{
MethodInfo mi = mb as MethodInfo;
if (mi != null
&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
&& !FindMethod(list, mi))
{
list.Add(mi);
}
}
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="621" endline="632">
private static bool FindMethod(List<MethodInfo> methods, MethodInfo method)
{
foreach (MethodInfo m in methods)
{
if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
{
return true;
}
}
foreach (MethodInfo m in methods)
{
if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
{
return true;
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="643" endline="659">
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
{
MethodInfo found = null;
foreach (MethodInfo method in GetMethods(bindingAttr))
{
if (method.Name == name)
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = method;
}
}
foreach (MethodInfo method in GetMethods(bindingAttr))
{
if (method.Name == name)
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = method;
}
}
return found;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="670" endline="686">
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
{
MethodInfo found = null;
foreach (MethodInfo method in GetMethods(bindingAttr))
{
if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = method;
}
}
foreach (MethodInfo method in GetMethods(bindingAttr))
{
if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = method;
}
}
return found;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="698" endline="714">
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
{
CheckBaked();
List<ConstructorInfo> list = new List<ConstructorInfo>();
foreach (MethodBase mb in __GetDeclaredMethods())
{
ConstructorInfo constructor = mb as ConstructorInfo;
if (constructor != null
&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(constructor);
}
}
foreach (MethodBase mb in __GetDeclaredMethods())
{
ConstructorInfo constructor = mb as ConstructorInfo;
if (constructor != null
&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(constructor);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="720" endline="731">
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
{
foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
{
if (constructor.MethodSignature.MatchParameterTypes(types))
{
return constructor;
}
}
foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
{
if (constructor.MethodSignature.MatchParameterTypes(types))
{
return constructor;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="743" endline="754">
public virtual Type GetNestedType(string name, BindingFlags bindingAttr)
{
foreach (Type type in GetNestedTypes(bindingAttr))
{
if (type.Name == name)
{
return type;
}
}
foreach (Type type in GetNestedTypes(bindingAttr))
{
if (type.Name == name)
{
return type;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="760" endline="773">
public Type[] GetNestedTypes(BindingFlags bindingAttr)
{
CheckBaked();
List<Type> list = new List<Type>();
foreach (Type type in __GetDeclaredTypes())
{
if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
{
list.Add(type);
}
}
foreach (Type type in __GetDeclaredTypes())
{
if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
{
list.Add(type);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="779" endline="809">
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
{
List<PropertyInfo> list = new List<PropertyInfo>();
Type type = this;
while (type != null)
{
type.CheckBaked();
foreach (PropertyInfo property in type.__GetDeclaredProperties())
{
if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(property);
}
}
foreach (PropertyInfo property in type.__GetDeclaredProperties())
{
if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(property);
}
}
if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
{
if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
{
bindingAttr &= ~BindingFlags.Static;
}
type = type.BaseType;
}
else
{
break;
}
}
while (type != null)
{
type.CheckBaked();
foreach (PropertyInfo property in type.__GetDeclaredProperties())
{
if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
{
list.Add(property);
}
}
if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
{
if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
{
bindingAttr &= ~BindingFlags.Static;
}
type = type.BaseType;
}
else
{
break;
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="815" endline="826">
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
{
foreach (PropertyInfo prop in GetProperties(bindingAttr))
{
if (prop.Name == name)
{
return prop;
}
}
foreach (PropertyInfo prop in GetProperties(bindingAttr))
{
if (prop.Name == name)
{
return prop;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="827" endline="843">
public PropertyInfo GetProperty(string name, Type returnType)
{
PropertyInfo found = null;
foreach (PropertyInfo prop in GetProperties())
{
if (prop.Name == name && prop.PropertyType.Equals(returnType))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = prop;
}
}
foreach (PropertyInfo prop in GetProperties())
{
if (prop.Name == name && prop.PropertyType.Equals(returnType))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = prop;
}
}
return found;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="844" endline="860">
public PropertyInfo GetProperty(string name, Type[] types)
{
PropertyInfo found = null;
foreach (PropertyInfo prop in GetProperties())
{
if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = prop;
}
}
foreach (PropertyInfo prop in GetProperties())
{
if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = prop;
}
}
return found;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="861" endline="876">
private static bool MatchParameterTypes(ParameterInfo[] parameters, Type[] types)
{
if (parameters.Length == types.Length)
{
for (int i = 0; i < parameters.Length; i++)
{
if (!parameters[i].ParameterType.Equals(types[i]))
{
return false;
}
}
for (int i = 0; i < parameters.Length; i++)
{
if (!parameters[i].ParameterType.Equals(types[i]))
{
return false;
}
}
return true;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="887" endline="903">
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
{
PropertyInfo found = null;
foreach (PropertyInfo prop in GetProperties(bindingAttr))
{
if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = prop;
}
}
foreach (PropertyInfo prop in GetProperties(bindingAttr))
{
if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
{
if (found != null)
{
throw new AmbiguousMatchException();
}
found = prop;
}
}
return found;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="909" endline="924">
public Type GetInterface(string name, bool ignoreCase)
{
if (ignoreCase)
{
throw new NotImplementedException();
}
foreach (Type type in GetInterfaces())
{
if (type.FullName == name)
{
return type;
}
}
foreach (Type type in GetInterfaces())
{
if (type.FullName == name)
{
return type;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="925" endline="937">
public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
{
List<Type> list = new List<Type>();
foreach (Type type in GetInterfaces())
{
if (filter(type, filterCriteria))
{
list.Add(type);
}
}
foreach (Type type in GetInterfaces())
{
if (filter(type, filterCriteria))
{
list.Add(type);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="942" endline="964">
}
public bool IsPrimitive
{
get
{
Universe u = this.Module.universe;
return this == u.System_Boolean
|| this == u.System_Byte
|| this == u.System_SByte
|| this == u.System_Int16
|| this == u.System_UInt16
|| this == u.System_Int32
|| this == u.System_UInt32
|| this == u.System_Int64
|| this == u.System_UInt64
|| this == u.System_IntPtr
|| this == u.System_UIntPtr
|| this == u.System_Char
|| this == u.System_Double
|| this == u.System_Single
;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1153" endline="1161">
public Type __MakeGenericType(Type[] typeArguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
{
if (!this.IsGenericTypeDefinition)
{
throw new InvalidOperationException();
}
return GenericTypeInstance.Make(this, Util.Copy(typeArguments), Util.Copy(requiredCustomModifiers), Util.Copy(optionalCustomModifiers));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1162" endline="1206">
public static System.Type __GetSystemType(TypeCode typeCode)
{
switch (typeCode)
{
case TypeCode.Boolean
return typeof(System.Boolean);
case TypeCode.Byte
return typeof(System.Byte);
case TypeCode.Char
return typeof(System.Char);
case TypeCode.DBNull
return typeof(System.DBNull);
case TypeCode.DateTime
return typeof(System.DateTime);
case TypeCode.Decimal
return typeof(System.Decimal);
case TypeCode.Double
return typeof(System.Double);
case TypeCode.Empty
return null;
case TypeCode.Int16
return typeof(System.Int16);
case TypeCode.Int32
return typeof(System.Int32);
case TypeCode.Int64
return typeof(System.Int64);
case TypeCode.Object
return typeof(System.Object);
case TypeCode.SByte
return typeof(System.SByte);
case TypeCode.Single
return typeof(System.Single);
case TypeCode.String
return typeof(System.String);
case TypeCode.UInt16
return typeof(System.UInt16);
case TypeCode.UInt32
return typeof(System.UInt32);
case TypeCode.UInt64
return typeof(System.UInt64);
default
throw new ArgumentOutOfRangeException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1207" endline="1287">
public static TypeCode GetTypeCode(Type type)
{
if (type == null)
{
return TypeCode.Empty;
}
if (type.IsEnum)
{
type = type.GetEnumUnderlyingType();
}
Universe u = type.Module.universe;
if (type == u.System_Boolean)
{
return TypeCode.Boolean;
}
else if (type == u.System_Char)
{
return TypeCode.Char;
}
else if (type == u.System_SByte)
{
return TypeCode.SByte;
}
else if (type == u.System_Byte)
{
return TypeCode.Byte;
}
else if (type == u.System_Int16)
{
return TypeCode.Int16;
}
else if (type == u.System_UInt16)
{
return TypeCode.UInt16;
}
else if (type == u.System_Int32)
{
return TypeCode.Int32;
}
else if (type == u.System_UInt32)
{
return TypeCode.UInt32;
}
else if (type == u.System_Int64)
{
return TypeCode.Int64;
}
else if (type == u.System_UInt64)
{
return TypeCode.UInt64;
}
else if (type == u.System_Single)
{
return TypeCode.Single;
}
else if (type == u.System_Double)
{
return TypeCode.Double;
}
else if (type == u.System_DateTime)
{
return TypeCode.DateTime;
}
else if (type == u.System_DBNull)
{
return TypeCode.DBNull;
}
else if (type == u.System_Decimal)
{
return TypeCode.Decimal;
}
else if (type == u.System_String)
{
return TypeCode.String;
}
else
{
return TypeCode.Object;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1292" endline="1339">
}
public bool IsAssignableFrom(Type type)
{
if (this.Equals(type))
{
return true;
}
else if (type == null)
{
return false;
}
else if (this.IsArray && type.IsArray)
{
if (this.GetArrayRank() != type.GetArrayRank())
{
return false;
}
else if (this.__IsVector && !type.__IsVector)
{
return false;
}
Type e1 = this.GetElementType();
Type e2 = type.GetElementType();
return e1.IsValueType == e2.IsValueType && e1.IsAssignableFrom(e2);
}
else if (this.IsSealed)
{
return false;
}
else if (this.IsInterface)
{
return Array.IndexOf(type.GetInterfaces(), this) != -1;
}
else if (type.IsInterface)
{
return this == this.Module.universe.System_Object;
}
else if (type.IsPointer)
{
return this == this.Module.universe.System_Object || this == this.Module.universe.System_ValueType;
}
else
{
return type.IsSubclassOf(this);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1340" endline="1353">
public bool IsSubclassOf(Type type)
{
Type thisType = this.BaseType;
while (thisType != null)
{
if (thisType.Equals(type))
{
return true;
}
thisType = thisType.BaseType;
}
while (thisType != null)
{
if (thisType.Equals(type))
{
return true;
}
thisType = thisType.BaseType;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1354" endline="1367">
private bool IsDirectlyImplementedInterface(Type interfaceType)
{
foreach (Type iface in __GetDeclaredInterfaces())
{
if (interfaceType.IsAssignableFrom(iface))
{
return true;
}
}
foreach (Type iface in __GetDeclaredInterfaces())
{
if (interfaceType.IsAssignableFrom(iface))
{
return true;
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1368" endline="1414">
public InterfaceMapping GetInterfaceMap(Type interfaceType)
{
CheckBaked();
InterfaceMapping map = new InterfaceMapping();
if (!IsDirectlyImplementedInterface(interfaceType))
{
Type baseType = this.BaseType;
if (baseType == null)
{
throw new ArgumentException();
}
else
{
map = baseType.GetInterfaceMap(interfaceType);
}
}
else
{
map.InterfaceMethods = interfaceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
map.InterfaceType = interfaceType;
map.TargetMethods = new MethodInfo[map.InterfaceMethods.Length];
FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
MethodInfo[] methods = GetMethods(BindingFlags.Instance | BindingFlags.Public);
for (int i = 0; i < map.TargetMethods.Length; i++)
{
if (map.TargetMethods[i] == null)
{
for (int j = 0; j < methods.Length; j++)
{
if (methods[j].Name == map.InterfaceMethods[i].Name
&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
{
map.TargetMethods[i] = methods[j];
}
}
for (int j = 0; j < methods.Length; j++)
{
if (methods[j].Name == map.InterfaceMethods[i].Name
&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
{
map.TargetMethods[i] = methods[j];
}
}
}
}
for (int i = 0; i < map.TargetMethods.Length; i++)
{
if (map.TargetMethods[i] == null)
{
for (int j = 0; j < methods.Length; j++)
{
if (methods[j].Name == map.InterfaceMethods[i].Name
&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
{
map.TargetMethods[i] = methods[j];
}
}
}
}
for (Type baseType = this.BaseType; baseType != null && interfaceType.IsAssignableFrom(baseType); baseType = baseType.BaseType)
{
baseType.FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
}
for (Type baseType = this.BaseType; baseType != null && interfaceType.IsAssignableFrom(baseType); baseType = baseType.BaseType)
{
baseType.FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
}
}
map.TargetType = this;
return map;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1415" endline="1430">
internal void FillInExplicitInterfaceMethods(MethodInfo[] interfaceMethods, MethodInfo[] targetMethods)
{
__MethodImplMap impl = __GetMethodImplMap();
for (int i = 0; i < impl.MethodDeclarations.Length; i++)
{
for (int j = 0; j < impl.MethodDeclarations[i].Length; j++)
{
int index = Array.IndexOf(interfaceMethods, impl.MethodDeclarations[i][j]);
if (index != -1 && targetMethods[index] == null)
{
targetMethods[index] = impl.MethodBodies[i];
}
}
for (int j = 0; j < impl.MethodDeclarations[i].Length; j++)
{
int index = Array.IndexOf(interfaceMethods, impl.MethodDeclarations[i][j]);
if (index != -1 && targetMethods[index] == null)
{
targetMethods[index] = impl.MethodBodies[i];
}
}
}
for (int i = 0; i < impl.MethodDeclarations.Length; i++)
{
for (int j = 0; j < impl.MethodDeclarations[i].Length; j++)
{
int index = Array.IndexOf(interfaceMethods, impl.MethodDeclarations[i][j]);
if (index != -1 && targetMethods[index] == null)
{
targetMethods[index] = impl.MethodBodies[i];
}
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1450" endline="1464">
}
internal virtual Type BindTypeParameters(IGenericBinder binder)
{
if (IsGenericTypeDefinition)
{
Type[] args = GetGenericArguments();
Type.InplaceBindTypeParameters(binder, args);
return GenericTypeInstance.Make(this, args, null, null);
}
else
{
return this;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1465" endline="1472">
internal static void InplaceBindTypeParameters(IGenericBinder binder, Type[] types)
{
for (int i = 0; i < types.Length; i++)
{
types[i] = types[i].BindTypeParameters(binder);
}
for (int i = 0; i < types.Length; i++)
{
types[i] = types[i].BindTypeParameters(binder);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1473" endline="1484">
internal MethodBase FindMethod(string name, MethodSignature signature)
{
foreach (MethodBase method in __GetDeclaredMethods())
{
if (method.Name == name && method.MethodSignature.Equals(signature))
{
return method;
}
}
foreach (MethodBase method in __GetDeclaredMethods())
{
if (method.Name == name && method.MethodSignature.Equals(signature))
{
return method;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1485" endline="1496">
internal FieldInfo FindField(string name, FieldSignature signature)
{
foreach (FieldInfo field in __GetDeclaredFields())
{
if (field.Name == name && field.FieldSignature.Equals(signature))
{
return field;
}
}
foreach (FieldInfo field in __GetDeclaredFields())
{
if (field.Name == name && field.FieldSignature.Equals(signature))
{
return field;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1497" endline="1514">
internal bool IsAllowMultipleCustomAttribute
{
get
{
IList<CustomAttributeData> cad = GetCustomAttributesData(this.Module.universe.System_AttributeUsageAttribute);
if (cad.Count == 1)
{
foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
{
if (arg.MemberInfo.Name == "AllowMultiple")
{
return (bool)arg.TypedValue.Value;
}
}
foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
{
if (arg.MemberInfo.Name == "AllowMultiple")
{
return (bool)arg.TypedValue.Value;
}
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1515" endline="1536">
}
internal bool IsPseudoCustomAttribute
{
get
{
Universe u = this.Module.universe;
return this == u.System_NonSerializedAttribute
|| this == u.System_SerializableAttribute
|| this == u.System_Runtime_InteropServices_DllImportAttribute
|| this == u.System_Runtime_InteropServices_FieldOffsetAttribute
|| this == u.System_Runtime_InteropServices_InAttribute
|| this == u.System_Runtime_InteropServices_MarshalAsAttribute
|| this == u.System_Runtime_InteropServices_OutAttribute
|| this == u.System_Runtime_InteropServices_StructLayoutAttribute
|| this == u.System_Runtime_InteropServices_OptionalAttribute
|| this == u.System_Runtime_InteropServices_PreserveSigAttribute
|| this == u.System_Runtime_InteropServices_ComImportAttribute
|| this == u.System_Runtime_CompilerServices_SpecialNameAttribute
|| this == u.System_Runtime_CompilerServices_MethodImplAttribute
;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="45" endline="57">
internal GenericTypeParameterBuilder(string name, TypeBuilder type, MethodBuilder method, int position)
{
this.name = name;
this.type = type;
this.method = method;
this.position = position;
GenericParamTable.Record rec = new GenericParamTable.Record();
rec.Number = (short)position;
rec.Flags = 0;
rec.Owner = type != null ? type.MetadataToken
rec.Name = this.ModuleBuilder.Strings.Add(name);
this.paramPseudoIndex = this.ModuleBuilder.GenericParam.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="142" endline="157">
}
public override GenericParameterAttributes GenericParameterAttributes
{
get
{
if (type != null)
{
type.CheckBaked();
}
else
{
method.CheckBaked();
}
return attr;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="158" endline="166">
}
private void AddConstraint(Type type)
{
GenericParamConstraintTable.Record rec = new GenericParamConstraintTable.Record();
rec.Owner = paramPseudoIndex;
rec.Constraint = this.ModuleBuilder.GetTypeTokenForMemberRef(type);
this.ModuleBuilder.GenericParamConstraint.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="173" endline="180">
public void SetInterfaceConstraints(params Type[] interfaceConstraints)
{
foreach (Type type in interfaceConstraints)
{
AddConstraint(type);
}
foreach (Type type in interfaceConstraints)
{
AddConstraint(type);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="198" endline="208">
internal override int GetModuleBuilderToken()
{
if (typeToken == 0)
{
ByteBuffer spec = new ByteBuffer(5);
Signature.WriteTypeSpec(this.ModuleBuilder, spec, this);
typeToken = 0x1B000000 | this.ModuleBuilder.TypeSpec.AddRecord(this.ModuleBuilder.Blobs.Add(spec));
}
return typeToken;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="209" endline="220">
internal override Type BindTypeParameters(IGenericBinder binder)
{
if (type != null)
{
return binder.BindTypeParameter(this);
}
else
{
return binder.BindMethodParameter(this);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="221" endline="268">
}
public sealed class TypeBuilder
{
public const int UnspecifiedTypeSize = 0;
private readonly ITypeOwner owner;
private readonly int token;
private int extends;
private Type baseType;
private readonly int typeName;
private readonly int typeNameSpace;
private readonly string nameOrFullName;
private readonly List<MethodBuilder> methods = new List<MethodBuilder>();
private readonly List<FieldBuilder> fields = new List<FieldBuilder>();
private List<PropertyBuilder> properties;
private List<EventBuilder> events;
private TypeAttributes attribs;
private TypeFlags typeFlags;
private GenericTypeParameterBuilder[] gtpb;
private List<CustomAttributeBuilder> declarativeSecurity;
private List<Type> interfaces;
[Flags]
private enum TypeFlags
{
IsGenericTypeDefinition = 1,
HasNestedTypes = 2,
Baked = 4,
}
internal TypeBuilder(ITypeOwner owner, string name, Type baseType, TypeAttributes attribs)
{
this.owner = owner;
this.token = this.ModuleBuilder.TypeDef.AllocToken();
this.nameOrFullName = TypeNameParser.Escape(name);
SetParent(baseType);
this.attribs = attribs;
if (!this.IsNested)
{
int lastdot = name.LastIndexOf('.');
if (lastdot > 0)
{
this.typeNameSpace = this.ModuleBuilder.Strings.Add(name.Substring(0, lastdot));
name = name.Substring(lastdot + 1);
}
}
this.typeName = this.ModuleBuilder.Strings.Add(name);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="269" endline="278">
public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes)
{
ConstructorBuilder cb = DefineConstructor(attributes, CallingConventions.Standard, Type.EmptyTypes);
ILGenerator ilgen = cb.GetILGenerator();
ilgen.Emit(OpCodes.Ldarg_0);
ilgen.Emit(OpCodes.Call, baseType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null));
ilgen.Emit(OpCodes.Ret);
return cb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="284" endline="291">
public ConstructorBuilder DefineConstructor(MethodAttributes attribs, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
{
attribs |= MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
string name = (attribs & MethodAttributes.Static) == 0 ? ConstructorInfo.ConstructorName
MethodBuilder mb = DefineMethod(name, attribs, callingConvention, null, null, null, parameterTypes, requiredCustomModifiers, optionalCustomModifiers);
return new ConstructorBuilder(mb);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="298" endline="305">
private MethodBuilder CreateMethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention)
{
this.ModuleBuilder.MethodDef.AddVirtualRecord();
MethodBuilder mb = new MethodBuilder(this, name, attributes, callingConvention);
methods.Add(mb);
return mb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="326" endline="332">
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
{
MethodBuilder mb = CreateMethodBuilder(name, attributes, callingConvention);
mb.SetSignature(returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
return mb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="343" endline="354">
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention,
Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers,
CallingConvention nativeCallConv, CharSet nativeCharSet)
{
MethodBuilder mb = DefineMethod(name, attributes | MethodAttributes.PinvokeImpl, callingConvention,
returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
mb.SetDllImportPseudoCustomAttribute(dllName, entryName, nativeCallConv, nativeCharSet, null, null, null, null, null);
return mb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="355" endline="363">
public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration)
{
MethodImplTable.Record rec = new MethodImplTable.Record();
rec.Class = token;
rec.MethodBody = this.ModuleBuilder.GetMethodToken(methodInfoBody).Token;
rec.MethodDeclaration = this.ModuleBuilder.GetMethodToken(methodInfoDeclaration).Token;
this.ModuleBuilder.MethodImpl.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="369" endline="375">
public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
{
FieldBuilder fb = new FieldBuilder(this, fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
fields.Add(fb);
return fb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="381" endline="387">
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
{
return DefinePropertyImpl(name, attributes, CallingConventions.Standard, true, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="388" endline="395">
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention,
Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
{
return DefinePropertyImpl(name, attributes, callingConvention, false, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="396" endline="410">
private PropertyBuilder DefinePropertyImpl(string name, PropertyAttributes attributes, CallingConventions callingConvention, bool patchCallingConvention,
Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
{
if (properties == null)
{
properties = new List<PropertyBuilder>();
}
PropertySignature sig = PropertySignature.Create(callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
parameterTypes, parameterTypeOptionalCustomModifiers, parameterTypeRequiredCustomModifiers);
PropertyBuilder pb = new PropertyBuilder(this, name, attributes, sig, patchCallingConvention);
properties.Add(pb);
return pb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="411" endline="421">
public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype)
{
if (events == null)
{
events = new List<EventBuilder>();
}
EventBuilder eb = new EventBuilder(this, name, attributes, eventtype);
events.Add(eb);
return eb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="432" endline="441">
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
{
TypeBuilder tb = DefineNestedType(name, attr, parent);
foreach (Type iface in interfaces)
{
tb.AddInterfaceImplementation(iface);
}
foreach (Type iface in interfaces)
{
tb.AddInterfaceImplementation(iface);
}
return tb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="465" endline="473">
public void AddInterfaceImplementation(Type interfaceType)
{
if (interfaces == null)
{
interfaces = new List<Type>();
}
interfaces.Add(interfaceType);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="474" endline="487">
public int Size
{
get
{
for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
{
if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
{
return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
}
}
for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
{
if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
{
return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
}
}
return 0;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="488" endline="502">
}
public PackingSize PackingSize
{
get
{
for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
{
if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
{
return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
}
}
for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
{
if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
{
return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
}
}
return PackingSize.Unspecified;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="503" endline="555">
}
private void SetStructLayoutPseudoCustomAttribute(CustomAttributeBuilder customBuilder)
{
object val = customBuilder.GetConstructorArgument(0);
LayoutKind layout;
if (val is short)
{
layout = (LayoutKind)(short)val;
}
else
{
layout = (LayoutKind)val;
}
int? pack = (int?)customBuilder.GetFieldValue("Pack");
int? size = (int?)customBuilder.GetFieldValue("Size");
if (pack.HasValue || size.HasValue)
{
ClassLayoutTable.Record rec = new ClassLayoutTable.Record();
rec.PackingSize = (short)(pack ?? 0);
rec.ClassSize = size ?? 0;
rec.Parent = token;
this.ModuleBuilder.ClassLayout.AddOrReplaceRecord(rec);
}
attribs &= ~TypeAttributes.LayoutMask;
switch (layout)
{
case LayoutKind.Auto
attribs |= TypeAttributes.AutoLayout;
break;
case LayoutKind.Explicit
attribs |= TypeAttributes.ExplicitLayout;
break;
case LayoutKind.Sequential
attribs |= TypeAttributes.SequentialLayout;
break;
}
CharSet? charSet = customBuilder.GetFieldValue<CharSet>("CharSet");
attribs &= ~TypeAttributes.StringFormatMask;
switch (charSet ?? CharSet.None)
{
case CharSet.None
case CharSet.Ansi
attribs |= TypeAttributes.AnsiClass;
break;
case CharSet.Auto
attribs |= TypeAttributes.AutoClass;
break;
case CharSet.Unicode
attribs |= TypeAttributes.UnicodeClass;
break;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="561" endline="590">
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
{
Universe u = this.ModuleBuilder.universe;
Type type = customBuilder.Constructor.DeclaringType;
if (type == u.System_Runtime_InteropServices_StructLayoutAttribute)
{
SetStructLayoutPseudoCustomAttribute(customBuilder.DecodeBlob(this.Assembly));
}
else if (type == u.System_SerializableAttribute)
{
attribs |= TypeAttributes.Serializable;
}
else if (type == u.System_Runtime_InteropServices_ComImportAttribute)
{
attribs |= TypeAttributes.Import;
}
else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
{
attribs |= TypeAttributes.SpecialName;
}
else
{
if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
{
attribs |= TypeAttributes.HasSecurity;
}
this.ModuleBuilder.SetCustomAttribute(token, customBuilder);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="591" endline="600">
public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
{
attribs |= TypeAttributes.HasSecurity;
if (declarativeSecurity == null)
{
declarativeSecurity = new List<CustomAttributeBuilder>();
}
declarativeSecurity.Add(customBuilder);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="607" endline="617">
public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
{
typeFlags |= TypeFlags.IsGenericTypeDefinition;
gtpb = new GenericTypeParameterBuilder[names.Length];
for (int i = 0; i < names.Length; i++)
{
gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
}
for (int i = 0; i < names.Length; i++)
{
gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
}
return (GenericTypeParameterBuilder[])gtpb.Clone();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="648" endline="680">
public Type CreateType()
{
if ((typeFlags & TypeFlags.Baked) != 0)
{
throw new NotImplementedException();
}
typeFlags |= TypeFlags.Baked;
foreach (MethodBuilder mb in methods)
{
mb.Bake();
}
foreach (MethodBuilder mb in methods)
{
mb.Bake();
}
if (declarativeSecurity != null)
{
this.ModuleBuilder.AddDeclarativeSecurity(token, declarativeSecurity);
}
if (baseType != null)
{
extends = this.ModuleBuilder.GetTypeToken(baseType).Token;
}
if (interfaces != null)
{
foreach (Type interfaceType in interfaces)
{
InterfaceImplTable.Record rec = new InterfaceImplTable.Record();
rec.Class = token;
rec.Interface = this.ModuleBuilder.GetTypeToken(interfaceType).Token;
this.ModuleBuilder.InterfaceImpl.AddRecord(rec);
}
foreach (Type interfaceType in interfaces)
{
InterfaceImplTable.Record rec = new InterfaceImplTable.Record();
rec.Class = token;
rec.Interface = this.ModuleBuilder.GetTypeToken(interfaceType).Token;
this.ModuleBuilder.InterfaceImpl.AddRecord(rec);
}
}
return new BakedType(this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="681" endline="706">
internal void PopulatePropertyAndEventTables()
{
if (properties != null)
{
PropertyMapTable.Record rec = new PropertyMapTable.Record();
rec.Parent = token;
rec.PropertyList = this.ModuleBuilder.Property.RowCount + 1;
this.ModuleBuilder.PropertyMap.AddRecord(rec);
foreach (PropertyBuilder pb in properties)
{
pb.Bake();
}
foreach (PropertyBuilder pb in properties)
{
pb.Bake();
}
}
if (events != null)
{
EventMapTable.Record rec = new EventMapTable.Record();
rec.Parent = token;
rec.EventList = this.ModuleBuilder.Event.RowCount + 1;
this.ModuleBuilder.EventMap.AddRecord(rec);
foreach (EventBuilder eb in events)
{
eb.Bake();
}
foreach (EventBuilder eb in events)
{
eb.Bake();
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="711" endline="725">
}
public override string FullName
{
get
{
if (this.IsNested)
{
return this.DeclaringType.FullName + "+" + nameOrFullName;
}
else
{
return nameOrFullName;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="726" endline="740">
}
public override string Name
{
get
{
if (this.IsNested)
{
return nameOrFullName;
}
else
{
return base.Name;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="741" endline="749">
}
public override string Namespace
{
get
{
return base.Namespace ?? "";
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="773" endline="790">
public override MethodBase[] __GetDeclaredMethods()
{
MethodBase[] methods = new MethodBase[this.methods.Count];
for (int i = 0; i < methods.Length; i++)
{
MethodBuilder mb = this.methods[i];
if (mb.IsConstructor)
{
methods[i] = new ConstructorInfoImpl(mb);
}
else
{
methods[i] = mb;
}
}
for (int i = 0; i < methods.Length; i++)
{
MethodBuilder mb = this.methods[i];
if (mb.IsConstructor)
{
methods[i] = new ConstructorInfoImpl(mb);
}
else
{
methods[i] = mb;
}
}
return methods;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="791" endline="823">
public override StructLayoutAttribute StructLayoutAttribute
{
get
{
StructLayoutAttribute attr;
if ((attribs & TypeAttributes.ExplicitLayout) != 0)
{
attr = new StructLayoutAttribute(LayoutKind.Explicit);
attr.Pack = 8;
attr.Size = 0;
this.ModuleBuilder.ClassLayout.GetLayout(token, ref attr.Pack, ref attr.Size);
}
else
{
attr = new StructLayoutAttribute((attribs & TypeAttributes.SequentialLayout) != 0 ? LayoutKind.Sequential
attr.Pack = 8;
attr.Size = 0;
}
switch (attribs & TypeAttributes.StringFormatMask)
{
case TypeAttributes.AutoClass
attr.CharSet = CharSet.Auto;
break;
case TypeAttributes.UnicodeClass
attr.CharSet = CharSet.Unicode;
break;
case TypeAttributes.AnsiClass
attr.CharSet = CharSet.Ansi;
break;
}
return attr;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="850" endline="863">
public FieldBuilder DefineInitializedData(string name, byte[] data, FieldAttributes attributes)
{
Type fieldType = this.ModuleBuilder.GetType("$ArrayType$" + data.Length);
if (fieldType == null)
{
TypeBuilder tb = this.ModuleBuilder.DefineType("$ArrayType$" + data.Length, TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.ExplicitLayout, this.Module.universe.System_ValueType, PackingSize.Size1, data.Length);
tb.CreateType();
fieldType = tb;
}
FieldBuilder fb = DefineField(name, fieldType, attributes | FieldAttributes.Static);
fb.__SetDataAndRVA(data);
return fb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="888" endline="900">
}
internal void WriteTypeDefRecord(MetadataWriter mw, ref int fieldList, ref int methodList)
{
mw.Write((int)attribs);
mw.WriteStringIndex(typeName);
mw.WriteStringIndex(typeNameSpace);
mw.WriteTypeDefOrRef(extends);
mw.WriteField(fieldList);
mw.WriteMethodDef(methodList);
methodList += methods.Count;
fieldList += fields.Count;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="901" endline="908">
internal void WriteMethodDefRecords(int baseRVA, MetadataWriter mw, ref int paramList)
{
foreach (MethodBuilder mb in methods)
{
mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
}
foreach (MethodBuilder mb in methods)
{
mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="909" endline="920">
internal void ResolveMethodAndFieldTokens(ref int methodToken, ref int fieldToken, ref int parameterToken)
{
foreach (MethodBuilder method in methods)
{
method.FixupToken(methodToken++, ref parameterToken);
}
foreach (MethodBuilder method in methods)
{
method.FixupToken(methodToken++, ref parameterToken);
}
foreach (FieldBuilder field in fields)
{
field.FixupToken(fieldToken++);
}
foreach (FieldBuilder field in fields)
{
field.FixupToken(fieldToken++);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="921" endline="928">
internal void WriteParamRecords(MetadataWriter mw)
{
foreach (MethodBuilder mb in methods)
{
mb.WriteParamRecords(mw);
}
foreach (MethodBuilder mb in methods)
{
mb.WriteParamRecords(mw);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="929" endline="936">
internal void WriteFieldRecords(MetadataWriter mw)
{
foreach (FieldBuilder fb in fields)
{
fb.WriteFieldRecords(mw);
}
foreach (FieldBuilder fb in fields)
{
fb.WriteFieldRecords(mw);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="956" endline="969">
}
internal MethodBase LookupMethod(int token)
{
foreach (MethodBuilder method in methods)
{
if (method.MetadataToken == token)
{
return method;
}
}
foreach (MethodBuilder method in methods)
{
if (method.MetadataToken == token)
{
return method;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="975" endline="982">
internal override void CheckBaked()
{
if ((typeFlags & TypeFlags.Baked) == 0)
{
throw new NotSupportedException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="983" endline="1000">
public override Type[] __GetDeclaredTypes()
{
if (this.HasNestedTypes)
{
List<Type> types = new List<Type>();
List<int> classes = this.ModuleBuilder.NestedClass.GetNestedClasses(token);
foreach (int nestedClass in classes)
{
types.Add(this.ModuleBuilder.ResolveType(nestedClass));
}
foreach (int nestedClass in classes)
{
types.Add(this.ModuleBuilder.ResolveType(nestedClass));
}
return types.ToArray();
}
else
{
return Type.EmptyTypes;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="1020" endline="1030">
}
}
sealed class BakedType
{
private readonly TypeBuilder typeBuilder;
internal BakedType(TypeBuilder typeBuilder)
{
this.typeBuilder = typeBuilder;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="51" endline="57">
set
{
if (value > this.Length || value > buffer.Length)
throw new ArgumentOutOfRangeException();
__length = Math.Max(__length, pos);
pos = value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="63" endline="70">
}
private void Grow(int minGrow)
{
byte[] newbuf = new byte[Math.Max(buffer.Length + minGrow, buffer.Length * 2)];
Buffer.BlockCopy(buffer, 0, newbuf, 0, buffer.Length);
buffer = newbuf;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="71" endline="79">
internal int GetInt32AtCurrentPosition()
{
return buffer[pos]
+ (buffer[pos + 1] << 8)
+ (buffer[pos + 2] << 16)
+ (buffer[pos + 3] << 24);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="86" endline="93">
internal void Write(byte[] value)
{
if (pos + value.Length > buffer.Length)
Grow(value.Length);
Buffer.BlockCopy(value, 0, buffer, pos, value.Length);
pos += value.Length;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="94" endline="100">
internal void Write(byte value)
{
if (pos == buffer.Length)
Grow(1);
buffer[pos++] = value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="111" endline="118">
internal void Write(short value)
{
if (pos + 2 > buffer.Length)
Grow(2);
buffer[pos++] = (byte)value;
buffer[pos++] = (byte)(value >> 8);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="124" endline="133">
internal void Write(int value)
{
if (pos + 4 > buffer.Length)
Grow(4);
buffer[pos++] = (byte)value;
buffer[pos++] = (byte)(value >> 8);
buffer[pos++] = (byte)(value >> 16);
buffer[pos++] = (byte)(value >> 24);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="139" endline="152">
internal void Write(long value)
{
if (pos + 8 > buffer.Length)
Grow(8);
buffer[pos++] = (byte)value;
buffer[pos++] = (byte)(value >> 8);
buffer[pos++] = (byte)(value >> 16);
buffer[pos++] = (byte)(value >> 24);
buffer[pos++] = (byte)(value >> 32);
buffer[pos++] = (byte)(value >> 40);
buffer[pos++] = (byte)(value >> 48);
buffer[pos++] = (byte)(value >> 56);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="163" endline="176">
internal void Write(string str)
{
if (str == null)
{
Write((byte)0xFF);
}
else
{
byte[] buf = Encoding.UTF8.GetBytes(str);
WriteCompressedInt(buf.Length);
Write(buf);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="177" endline="196">
internal void WriteCompressedInt(int value)
{
if (value <= 0x7F)
{
Write((byte)value);
}
else if (value <= 0x3FFF)
{
Write((byte)(0x80 | (value >> 8)));
Write((byte)value);
}
else
{
Write((byte)(0xC0 | (value >> 24)));
Write((byte)(value >> 16));
Write((byte)(value >> 8));
Write((byte)value);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="197" endline="204">
internal void Write(ByteBuffer bb)
{
if (pos + bb.Length > buffer.Length)
Grow(bb.Length);
Buffer.BlockCopy(bb.buffer, 0, buffer, pos, bb.Length);
pos += bb.Length;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="216" endline="224">
internal void Align(int alignment)
{
if (pos + alignment > buffer.Length)
Grow(alignment);
int newpos = (pos + alignment - 1) & ~(alignment - 1);
while (pos < newpos)
buffer[pos++] = 0;
while (pos < newpos)
buffer[pos++] = 0;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="225" endline="242">
internal void WriteTypeDefOrRefEncoded(int token)
{
switch (token >> 24)
{
case TypeDefTable.Index
WriteCompressedInt((token & 0xFFFFFF) << 2 | 0);
break;
case TypeRefTable.Index
WriteCompressedInt((token & 0xFFFFFF) << 2 | 1);
break;
case TypeSpecTable.Index
WriteCompressedInt((token & 0xFFFFFF) << 2 | 2);
break;
default
throw new InvalidOperationException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="243" endline="258">
internal void Write(System.IO.Stream stream)
{
const int chunkSize = 8192;
for (; ; )
{
if (pos + chunkSize > buffer.Length)
Grow(chunkSize);
int read = stream.Read(buffer, pos, chunkSize);
if (read <= 0)
{
break;
}
pos += read;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="259" endline="265">
internal byte[] ToArray()
{
byte[] buf = new byte[pos];
Buffer.BlockCopy(buffer, 0, buf, 0, pos);
return buf;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="276" endline="287">
internal bool Match(int pos, ByteBuffer bb2, int pos2, int len)
{
for (int i = 0; i < len; i++)
{
if (buffer[pos + i] != bb2.buffer[pos2 + i])
{
return false;
}
}
for (int i = 0; i < len; i++)
{
if (buffer[pos + i] != bb2.buffer[pos2 + i])
{
return false;
}
}
return true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="288" endline="299">
internal int Hash()
{
int hash = 0;
int len = this.Length;
for (int i = 0; i < len; i++)
{
hash *= 37;
hash ^= buffer[i];
}
for (int i = 0; i < len; i++)
{
hash *= 37;
hash ^= buffer[i];
}
return hash;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
internal int ReadStringIndex()
{
if (bigStrings)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="68" endline="79">
internal int ReadGuidIndex()
{
if (bigGuids)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="80" endline="91">
internal int ReadBlobIndex()
{
if (bigBlobs)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="92" endline="117">
internal int ReadResolutionScope()
{
int codedIndex;
if (bigResolutionScope)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 3)
{
case 0
return (ModuleTable.Index << 24) + (codedIndex >> 2);
case 1
return (ModuleRefTable.Index << 24) + (codedIndex >> 2);
case 2
return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
case 3
return (TypeRefTable.Index << 24) + (codedIndex >> 2);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="118" endline="141">
internal int ReadTypeDefOrRef()
{
int codedIndex;
if (bigTypeDefOrRef)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 3)
{
case 0
return (TypeDefTable.Index << 24) + (codedIndex >> 2);
case 1
return (TypeRefTable.Index << 24) + (codedIndex >> 2);
case 2
return (TypeSpecTable.Index << 24) + (codedIndex >> 2);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="142" endline="169">
internal int ReadMemberRefParent()
{
int codedIndex;
if (bigMemberRefParent)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 7)
{
case 0
return (TypeDefTable.Index << 24) + (codedIndex >> 3);
case 1
return (TypeRefTable.Index << 24) + (codedIndex >> 3);
case 2
return (ModuleRefTable.Index << 24) + (codedIndex >> 3);
case 3
return (MethodDefTable.Index << 24) + (codedIndex >> 3);
case 4
return (TypeSpecTable.Index << 24) + (codedIndex >> 3);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="170" endline="227">
internal int ReadHasCustomAttribute()
{
int codedIndex;
if (bigHasCustomAttribute)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 31)
{
case 0
return (MethodDefTable.Index << 24) + (codedIndex >> 5);
case 1
return (FieldTable.Index << 24) + (codedIndex >> 5);
case 2
return (TypeRefTable.Index << 24) + (codedIndex >> 5);
case 3
return (TypeDefTable.Index << 24) + (codedIndex >> 5);
case 4
return (ParamTable.Index << 24) + (codedIndex >> 5);
case 5
return (InterfaceImplTable.Index << 24) + (codedIndex >> 5);
case 6
return (MemberRefTable.Index << 24) + (codedIndex >> 5);
case 7
return (ModuleTable.Index << 24) + (codedIndex >> 5);
case 8
throw new BadImageFormatException();
case 9
return (PropertyTable.Index << 24) + (codedIndex >> 5);
case 10
return (EventTable.Index << 24) + (codedIndex >> 5);
case 11
return (StandAloneSigTable.Index << 24) + (codedIndex >> 5);
case 12
return (ModuleRefTable.Index << 24) + (codedIndex >> 5);
case 13
return (TypeSpecTable.Index << 24) + (codedIndex >> 5);
case 14
return (AssemblyTable.Index << 24) + (codedIndex >> 5);
case 15
return (AssemblyRefTable.Index << 24) + (codedIndex >> 5);
case 16
return (FileTable.Index << 24) + (codedIndex >> 5);
case 17
return (ExportedTypeTable.Index << 24) + (codedIndex >> 5);
case 18
return (ManifestResourceTable.Index << 24) + (codedIndex >> 5);
case 19
return (GenericParamTable.Index << 24) + (codedIndex >> 5);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
internal int ReadCustomAttributeType()
{
int codedIndex;
if (bigCustomAttributeType)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 7)
{
case 2
return (MethodDefTable.Index << 24) + (codedIndex >> 3);
case 3
return (MemberRefTable.Index << 24) + (codedIndex >> 3);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="250" endline="271">
internal int ReadMethodDefOrRef()
{
int codedIndex;
if (bigMethodDefOrRef)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 1)
{
case 0
return (MethodDefTable.Index << 24) + (codedIndex >> 1);
case 1
return (MemberRefTable.Index << 24) + (codedIndex >> 1);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="272" endline="295">
internal int ReadHasConstant()
{
int codedIndex;
if (bigHasConstant)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 3)
{
case 0
return (FieldTable.Index << 24) + (codedIndex >> 2);
case 1
return (ParamTable.Index << 24) + (codedIndex >> 2);
case 2
return (PropertyTable.Index << 24) + (codedIndex >> 2);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="296" endline="317">
internal int ReadHasSemantics()
{
int codedIndex;
if (bigHasSemantics)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 1)
{
case 0
return (EventTable.Index << 24) + (codedIndex >> 1);
case 1
return (PropertyTable.Index << 24) + (codedIndex >> 1);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="318" endline="339">
internal int ReadHasFieldMarshal()
{
int codedIndex;
if (bigHasFieldMarshal)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 1)
{
case 0
return (FieldTable.Index << 24) + (codedIndex >> 1);
case 1
return (ParamTable.Index << 24) + (codedIndex >> 1);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="340" endline="363">
internal int ReadHasDeclSecurity()
{
int codedIndex;
if (bigHasDeclSecurity)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 3)
{
case 0
return (TypeDefTable.Index << 24) + (codedIndex >> 2);
case 1
return (MethodDefTable.Index << 24) + (codedIndex >> 2);
case 2
return (AssemblyTable.Index << 24) + (codedIndex >> 2);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="364" endline="385">
internal int ReadTypeOrMethodDef()
{
int codedIndex;
if (bigTypeOrMethodDef)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 1)
{
case 0
return (TypeDefTable.Index << 24) + (codedIndex >> 1);
case 1
return (MethodDefTable.Index << 24) + (codedIndex >> 1);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="386" endline="407">
internal int ReadMemberForwarded()
{
int codedIndex;
if (bigMemberForwarded)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 1)
{
case 0
return (FieldTable.Index << 24) + (codedIndex >> 1);
case 1
return (MethodDefTable.Index << 24) + (codedIndex >> 1);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="408" endline="431">
internal int ReadImplementation()
{
int codedIndex;
if (bigImplementation)
{
codedIndex = br.ReadInt32();
}
else
{
codedIndex = br.ReadUInt16();
}
switch (codedIndex & 3)
{
case 0
return (FileTable.Index << 24) + (codedIndex >> 2);
case 1
return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
case 2
return (ExportedTypeTable.Index << 24) + (codedIndex >> 2);
default
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="432" endline="445">
private int ReadToken(int table, bool big)
{
int rid;
if (big)
{
rid = br.ReadInt32();
}
else
{
rid = br.ReadUInt16();
}
return rid | (table << 24);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="446" endline="457">
internal int ReadField()
{
if (bigField)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="458" endline="469">
internal int ReadMethodDef()
{
if (bigMethodDef)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="470" endline="481">
internal int ReadParam()
{
if (bigParam)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="482" endline="493">
internal int ReadProperty()
{
if (bigProperty)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="494" endline="505">
internal int ReadEvent()
{
if (bigEvent)
{
return br.ReadInt32();
}
else
{
return br.ReadUInt16();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="36" endline="41">
internal ByteReader(byte[] buffer, int offset, int length)
{
this.buffer = buffer;
this.pos = offset;
this.end = pos + length;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="42" endline="49">
internal static ByteReader FromBlob(byte[] blobHeap, int blob)
{
ByteReader br = new ByteReader(blobHeap, blob, 4);
int length = br.ReadCompressedInt();
br.end = br.pos + length;
return br;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="54" endline="61">
}
internal byte PeekByte()
{
if (pos == end)
throw new BadImageFormatException();
return buffer[pos];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="62" endline="68">
internal byte ReadByte()
{
if (pos == end)
throw new BadImageFormatException();
return buffer[pos++];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="69" endline="80">
internal byte[] ReadBytes(int count)
{
if (count < 0)
throw new BadImageFormatException();
if (end - pos < count)
throw new BadImageFormatException();
byte[] buf = new byte[count];
Buffer.BlockCopy(buffer, pos, buf, 0, count);
pos += count;
return buf;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="81" endline="101">
internal int ReadCompressedInt()
{
byte b1 = ReadByte();
if (b1 <= 0x7F)
{
return b1;
}
else if ((b1 & 0xC0) == 0x80)
{
byte b2 = ReadByte();
return ((b1 & 0x3F) << 8) | b2;
}
else
{
byte b2 = ReadByte();
byte b3 = ReadByte();
byte b4 = ReadByte();
return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="102" endline="114">
internal string ReadString()
{
if (PeekByte() == 0xFF)
{
pos++;
return null;
}
int length = ReadCompressedInt();
string str = Encoding.UTF8.GetString(buffer, pos, length);
pos += length;
return str;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="125" endline="133">
internal short ReadInt16()
{
if (end - pos < 2)
throw new BadImageFormatException();
byte b1 = buffer[pos++];
byte b2 = buffer[pos++];
return (short)(b1 | (b2 << 8));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="139" endline="149">
internal int ReadInt32()
{
if (end - pos < 4)
throw new BadImageFormatException();
byte b1 = buffer[pos++];
byte b2 = buffer[pos++];
byte b3 = buffer[pos++];
byte b4 = buffer[pos++];
return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="155" endline="161">
internal long ReadInt64()
{
ulong lo = ReadUInt32();
ulong hi = ReadUInt32();
return (long)(lo | (hi << 32));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="177" endline="185">
internal ByteReader Slice(int length)
{
if (end - pos < length)
throw new BadImageFormatException();
ByteReader br = new ByteReader(buffer, pos, length);
pos += length;
return br;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodBase.cs" startline="41" endline="48">
{
if ((this.Attributes & MethodAttributes.RTSpecialName) != 0)
{
string name = this.Name;
return name == ConstructorInfo.ConstructorName || name == ConstructorInfo.TypeConstructorName;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="52" endline="61">
public override string ToString()
{
string str = name.ToString();
if (culture != null)
{
str = str.Replace("Culture=neutral", "Culture=" + culture);
}
return str;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="77" endline="85">
}
internal string Culture
{
set
{
culture = value;
name.CultureInfo = CultureInfo.InvariantCulture;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="148" endline="160">
}
public string FullName
{
get
{
string str = name.FullName;
if (culture != null)
{
str = str.Replace("Culture=neutral", "Culture=" + culture);
}
return str;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="161" endline="167">
}
public override bool Equals(object obj)
{
AssemblyName other = obj as AssemblyName;
return other != null && other.FullName == this.FullName;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="183" endline="207">
public static AssemblyName GetAssemblyName(string path)
{
try
{
path = Path.GetFullPath(path);
using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
{
ModuleReader module = new ModuleReader(null, null, fs, path);
if (module.Assembly == null)
{
throw new BadImageFormatException("Module does not contain a manifest");
}
return module.Assembly.GetName();
}
}
catch (IOException x)
{
throw new FileNotFoundException(x.Message, x);
}
catch (UnauthorizedAccessException x)
{
throw new FileNotFoundException(x.Message, x);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="51" endline="59">
{
Signature = br.ReadUInt32();
if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
{
throw new BadImageFormatException();
}
FileHeader.Read(br);
OptionalHeader.Read(br);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="49" endline="90">
internal void Read(BinaryReader br)
{
Signature = br.ReadUInt32();
if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
{
throw new BadImageFormatException();
}
FileHeader.Read(br);
OptionalHeader.Read(br);
}
}
sealed class IMAGE_FILE_HEADER
{
public const WORD IMAGE_FILE_MACHINE_I386 = 0x014c;
public const WORD IMAGE_FILE_MACHINE_IA64 = 0x0200;
public const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;
public const WORD IMAGE_FILE_32BIT_MACHINE = 0x0100;
public const WORD IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
public const WORD IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
public const WORD IMAGE_FILE_DLL = 0x2000;
public WORD Machine;
public WORD NumberOfSections;
public DWORD TimeDateStamp;
public DWORD PointerToSymbolTable;
public DWORD NumberOfSymbols;
public WORD SizeOfOptionalHeader;
public WORD Characteristics;
internal void Read(BinaryReader br)
{
Machine = br.ReadUInt16();
NumberOfSections = br.ReadUInt16();
TimeDateStamp = br.ReadUInt32();
PointerToSymbolTable = br.ReadUInt32();
NumberOfSymbols = br.ReadUInt32();
SizeOfOptionalHeader = br.ReadUInt16();
Characteristics = br.ReadUInt16();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="91" endline="197">
}
sealed class IMAGE_OPTIONAL_HEADER
{
public const WORD IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
public const WORD IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
public const WORD IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
public const WORD IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
public const WORD IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040;
public const WORD IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100;
public const WORD IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400;
public const WORD IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000;
public WORD Magic;
public BYTE MajorLinkerVersion;
public BYTE MinorLinkerVersion;
public DWORD SizeOfCode;
public DWORD SizeOfInitializedData;
public DWORD SizeOfUninitializedData;
public DWORD AddressOfEntryPoint;
public DWORD BaseOfCode;
public DWORD BaseOfData;
public ULONGLONG ImageBase;
public DWORD SectionAlignment;
public DWORD FileAlignment;
public WORD MajorOperatingSystemVersion;
public WORD MinorOperatingSystemVersion;
public WORD MajorImageVersion;
public WORD MinorImageVersion;
public WORD MajorSubsystemVersion;
public WORD MinorSubsystemVersion;
public DWORD Win32VersionValue;
public DWORD SizeOfImage;
public DWORD SizeOfHeaders;
public DWORD CheckSum;
public WORD Subsystem;
public WORD DllCharacteristics;
public ULONGLONG SizeOfStackReserve;
public ULONGLONG SizeOfStackCommit;
public ULONGLONG SizeOfHeapReserve;
public ULONGLONG SizeOfHeapCommit;
public DWORD LoaderFlags;
public DWORD NumberOfRvaAndSizes;
public IMAGE_DATA_DIRECTORY[] DataDirectory;
internal void Read(BinaryReader br)
{
Magic = br.ReadUInt16();
if (Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC && Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
{
throw new BadImageFormatException();
}
MajorLinkerVersion = br.ReadByte();
MinorLinkerVersion = br.ReadByte();
SizeOfCode = br.ReadUInt32();
SizeOfInitializedData = br.ReadUInt32();
SizeOfUninitializedData = br.ReadUInt32();
AddressOfEntryPoint = br.ReadUInt32();
BaseOfCode = br.ReadUInt32();
if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
{
BaseOfData = br.ReadUInt32();
ImageBase = br.ReadUInt32();
}
else
{
ImageBase = br.ReadUInt64();
}
SectionAlignment = br.ReadUInt32();
FileAlignment = br.ReadUInt32();
MajorOperatingSystemVersion = br.ReadUInt16();
MinorOperatingSystemVersion = br.ReadUInt16();
MajorImageVersion = br.ReadUInt16();
MinorImageVersion = br.ReadUInt16();
MajorSubsystemVersion = br.ReadUInt16();
MinorSubsystemVersion = br.ReadUInt16();
Win32VersionValue = br.ReadUInt32();
SizeOfImage = br.ReadUInt32();
SizeOfHeaders = br.ReadUInt32();
CheckSum = br.ReadUInt32();
Subsystem = br.ReadUInt16();
DllCharacteristics = br.ReadUInt16();
if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
{
SizeOfStackReserve = br.ReadUInt32();
SizeOfStackCommit = br.ReadUInt32();
SizeOfHeapReserve = br.ReadUInt32();
SizeOfHeapCommit = br.ReadUInt32();
}
else
{
SizeOfStackReserve = br.ReadUInt64();
SizeOfStackCommit = br.ReadUInt64();
SizeOfHeapReserve = br.ReadUInt64();
SizeOfHeapCommit = br.ReadUInt64();
}
LoaderFlags = br.ReadUInt32();
NumberOfRvaAndSizes = br.ReadUInt32();
DataDirectory = new IMAGE_DATA_DIRECTORY[NumberOfRvaAndSizes];
for (uint i = 0; i < NumberOfRvaAndSizes; i++)
{
DataDirectory[i] = new IMAGE_DATA_DIRECTORY();
DataDirectory[i].Read(br);
}
for (uint i = 0; i < NumberOfRvaAndSizes; i++)
{
DataDirectory[i] = new IMAGE_DATA_DIRECTORY();
DataDirectory[i].Read(br);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="198" endline="209">
}
struct IMAGE_DATA_DIRECTORY
{
public DWORD VirtualAddress;
public DWORD Size;
internal void Read(BinaryReader br)
{
VirtualAddress = br.ReadUInt32();
Size = br.ReadUInt32();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="210" endline="255">
}
class SectionHeader
{
public const DWORD IMAGE_SCN_CNT_CODE = 0x00000020;
public const DWORD IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040;
public const DWORD IMAGE_SCN_MEM_DISCARDABLE = 0x02000000;
public const DWORD IMAGE_SCN_MEM_EXECUTE = 0x20000000;
public const DWORD IMAGE_SCN_MEM_READ = 0x40000000;
public const DWORD IMAGE_SCN_MEM_WRITE = 0x80000000;
public string Name;		// 8 byte UTF8 encoded 0-padded
public DWORD VirtualSize;
public DWORD VirtualAddress;
public DWORD SizeOfRawData;
public DWORD PointerToRawData;
public DWORD PointerToRelocations;
public DWORD PointerToLinenumbers;
public WORD NumberOfRelocations;
public WORD NumberOfLinenumbers;
public DWORD Characteristics;
internal void Read(BinaryReader br)
{
char[] name = new char[8];
int len = 8;
for (int i = 0; i < 8; i++)
{
byte b = br.ReadByte();
name[i] = (char)b;
if (b == 0 && len == 8)
{
len = i;
}
}
for (int i = 0; i < 8; i++)
{
byte b = br.ReadByte();
name[i] = (char)b;
if (b == 0 && len == 8)
{
len = i;
}
}
Name = new String(name, 0, len);
VirtualSize = br.ReadUInt32();
VirtualAddress = br.ReadUInt32();
SizeOfRawData = br.ReadUInt32();
PointerToRawData = br.ReadUInt32();
PointerToRelocations = br.ReadUInt32();
PointerToLinenumbers = br.ReadUInt32();
NumberOfRelocations = br.ReadUInt16();
NumberOfLinenumbers = br.ReadUInt16();
Characteristics = br.ReadUInt32();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="256" endline="283">
}
sealed class PEReader
{
private MSDOS_HEADER msdos = new MSDOS_HEADER();
private IMAGE_NT_HEADERS headers = new IMAGE_NT_HEADERS();
private SectionHeader[] sections;
internal void Read(BinaryReader br)
{
msdos.signature = br.ReadUInt16();
br.BaseStream.Seek(58, SeekOrigin.Current);
msdos.peSignatureOffset = br.ReadUInt32();
if (msdos.signature != MSDOS_HEADER.MAGIC_MZ)
{
throw new BadImageFormatException();
}
br.BaseStream.Seek(msdos.peSignatureOffset, SeekOrigin.Begin);
headers.Read(br);
sections = new SectionHeader[headers.FileHeader.NumberOfSections];
for (int i = 0; i < sections.Length; i++)
{
sections[i] = new SectionHeader();
sections[i].Read(br);
}
for (int i = 0; i < sections.Length; i++)
{
sections[i] = new SectionHeader();
sections[i].Read(br);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="305" endline="316">
internal long RvaToFileOffset(DWORD rva)
{
for (int i = 0; i < sections.Length; i++)
{
if (rva >= sections[i].VirtualAddress && rva < sections[i].VirtualAddress + sections[i].VirtualSize)
{
return sections[i].PointerToRawData + rva - sections[i].VirtualAddress;
}
}
for (int i = 0; i < sections.Length; i++)
{
if (rva >= sections[i].VirtualAddress && rva < sections[i].VirtualAddress + sections[i].VirtualSize)
{
return sections[i].PointerToRawData + rva - sections[i].VirtualAddress;
}
}
throw new BadImageFormatException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\EventInfo.cs" startline="32" endline="45">
}
public abstract EventAttributes Attributes { get; }
public abstract MethodInfo GetAddMethod(bool nonPublic);
public abstract MethodInfo GetRaiseMethod(bool nonPublic);
public abstract MethodInfo GetRemoveMethod(bool nonPublic);
public abstract MethodInfo[] GetOtherMethods(bool nonPublic);
public abstract Type EventHandlerType { get; }
internal abstract bool IsPublic { get; }
internal abstract bool IsStatic { get; }
public bool IsSpecialName
{
get { return (Attributes & EventAttributes.SpecialName) != 0; }
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="40" endline="45">
internal EventInfoImpl(ModuleReader module, Type declaringType, int index)
{
this.module = module;
this.declaringType = declaringType;
this.index = index;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
}
internal override bool IsPublic
{
get
{
if (!flagsCached)
{
ComputeFlags();
}
return isPublic;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="118" endline="129">
}
internal override bool IsStatic
{
get
{
if (!flagsCached)
{
ComputeFlags();
}
return isStatic;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="130" endline="136">
}
private void ComputeFlags()
{
module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
flagsCached = true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="38" endline="48">
}
internal abstract int RowCount { get; set; }
internal abstract void Write(MetadataWriter mw);
internal abstract void Read(MetadataReader mr);
internal int GetLength(MetadataWriter md)
{
return RowCount * GetRowSize(new RowSizeCalc(md));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="49" endline="394">
protected abstract int GetRowSize(RowSizeCalc rsc);
protected sealed class RowSizeCalc
{
private readonly MetadataWriter mw;
private int size;
internal RowSizeCalc(MetadataWriter mw)
{
this.mw = mw;
}
internal RowSizeCalc AddFixed(int size)
{
this.size += size;
return this;
}
internal RowSizeCalc WriteStringIndex()
{
if (mw.bigStrings)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteGuidIndex()
{
if (mw.bigGuids)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteBlobIndex()
{
if (mw.bigBlobs)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteTypeDefOrRef()
{
if (mw.bigTypeDefOrRef)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteField()
{
if (mw.bigField)
{
size += 4;
}
else
{
size += 2;
}
return this;
}
internal RowSizeCalc WriteMethodDef()
{
if (mw.bigMethodDef)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteParam()
{
if (mw.bigParam)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteResolutionScope()
{
if (mw.bigResolutionScope)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteMemberRefParent()
{
if (mw.bigMemberRefParent)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteHasCustomAttribute()
{
if (mw.bigHasCustomAttribute)
{
size += 4;
}
else
{
size += 2;
}
return this;
}
internal RowSizeCalc WriteCustomAttributeType()
{
if (mw.bigCustomAttributeType)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteHasConstant()
{
if (mw.bigHasConstant)
{
size += 4;
}
else
{
size += 2;
}
return this;
}
internal RowSizeCalc WriteTypeDef()
{
if (mw.bigTypeDef)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteMethodDefOrRef()
{
if (mw.bigMethodDefOrRef)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteEvent()
{
if (mw.bigEvent)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteProperty()
{
if (mw.bigProperty)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteHasSemantics()
{
if (mw.bigHasSemantics)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteImplementation()
{
if (mw.bigImplementation)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteTypeOrMethodDef()
{
if (mw.bigTypeOrMethodDef)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteGenericParam()
{
if (mw.bigGenericParam)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteHasDeclSecurity()
{
if (mw.bigHasDeclSecurity)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteMemberForwarded()
{
if (mw.bigMemberForwarded)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteModuleRef()
{
if (mw.bigModuleRef)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal RowSizeCalc WriteHasFieldMarshal()
{
if (mw.bigHasFieldMarshal)
{
this.size += 4;
}
else
{
this.size += 2;
}
return this;
}
internal int Value
{
get { return size; }
}
}
}
abstract class Table<T>
{
internal T[] records = new T[1];
protected int rowCount;
internal sealed override int RowCount
{
get { return rowCount; }
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="401" endline="413">
}
internal int AddRecord(T newRecord)
{
if (rowCount == records.Length)
{
T[] newarr = new T[records.Length * 2];
Array.Copy(records, newarr, records.Length);
records = newarr;
}
records[rowCount++] = newRecord;
return rowCount;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="390" endline="449">
protected int rowCount;
internal sealed override int RowCount
{
get { return rowCount; }
set { rowCount = value; records = new T[value]; }
}
protected override int GetRowSize(RowSizeCalc rsc)
{
throw new InvalidOperationException();
}
internal int AddRecord(T newRecord)
{
if (rowCount == records.Length)
{
T[] newarr = new T[records.Length * 2];
Array.Copy(records, newarr, records.Length);
records = newarr;
}
records[rowCount++] = newRecord;
return rowCount;
}
internal int AddVirtualRecord()
{
return ++rowCount;
}
internal override void Write(MetadataWriter mw)
{
throw new InvalidOperationException();
}
}
sealed class ModuleTable
{
internal const int Index = 0x00;
internal struct Record
{
internal short Generation;
internal int Name; // -> StringHeap
internal int Mvid; // -> GuidHeap
internal int EncId; // -> GuidHeap
internal int EncBaseId; // -> GuidHeap
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Generation = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Mvid = mr.ReadGuidIndex();
records[i].EncId = mr.ReadGuidIndex();
records[i].EncBaseId = mr.ReadGuidIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Generation = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Mvid = mr.ReadGuidIndex();
records[i].EncId = mr.ReadGuidIndex();
records[i].EncBaseId = mr.ReadGuidIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="450" endline="461">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Generation);
mw.WriteStringIndex(records[i].Name);
mw.WriteGuidIndex(records[i].Mvid);
mw.WriteGuidIndex(records[i].EncId);
mw.WriteGuidIndex(records[i].EncBaseId);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Generation);
mw.WriteStringIndex(records[i].Name);
mw.WriteGuidIndex(records[i].Mvid);
mw.WriteGuidIndex(records[i].EncId);
mw.WriteGuidIndex(records[i].EncBaseId);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="462" endline="472">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteStringIndex()
.WriteGuidIndex()
.WriteGuidIndex()
.WriteGuidIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="473" endline="483">
internal void Add(short generation, int name, int mvid, int encid, int encbaseid)
{
Record record = new Record();
record.Generation = generation;
record.Name = name;
record.Mvid = mvid;
record.EncId = encid;
record.EncBaseId = encbaseid;
AddRecord(record);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="484" endline="505">
}
sealed class TypeRefTable
{
internal const int Index = 0x01;
internal struct Record
{
internal int ResolutionScope;
internal int TypeName;
internal int TypeNameSpace;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].ResolutionScope = mr.ReadResolutionScope();
records[i].TypeName = mr.ReadStringIndex();
records[i].TypeNameSpace = mr.ReadStringIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].ResolutionScope = mr.ReadResolutionScope();
records[i].TypeName = mr.ReadStringIndex();
records[i].TypeNameSpace = mr.ReadStringIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="506" endline="515">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteResolutionScope(records[i].ResolutionScope);
mw.WriteStringIndex(records[i].TypeName);
mw.WriteStringIndex(records[i].TypeNameSpace);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteResolutionScope(records[i].ResolutionScope);
mw.WriteStringIndex(records[i].TypeName);
mw.WriteStringIndex(records[i].TypeNameSpace);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="516" endline="524">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteResolutionScope()
.WriteStringIndex()
.WriteStringIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="525" endline="552">
}
sealed class TypeDefTable
{
internal const int Index = 0x02;
internal struct Record
{
internal int Flags;
internal int TypeName;
internal int TypeNamespace;
internal int Extends;
internal int FieldList;
internal int MethodList;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt32();
records[i].TypeName = mr.ReadStringIndex();
records[i].TypeNamespace = mr.ReadStringIndex();
records[i].Extends = mr.ReadTypeDefOrRef();
records[i].FieldList = mr.ReadField();
records[i].MethodList = mr.ReadMethodDef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt32();
records[i].TypeName = mr.ReadStringIndex();
records[i].TypeNamespace = mr.ReadStringIndex();
records[i].Extends = mr.ReadTypeDefOrRef();
records[i].FieldList = mr.ReadField();
records[i].MethodList = mr.ReadMethodDef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="563" endline="574">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(4)
.WriteStringIndex()
.WriteStringIndex()
.WriteTypeDefOrRef()
.WriteField()
.WriteMethodDef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="575" endline="596">
}
sealed class FieldTable
{
internal const int Index = 0x04;
internal struct Record
{
internal short Flags;
internal int Name;
internal int Signature;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Signature = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Signature = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteStringIndex()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="611" endline="639">
}
sealed class MethodDefTable
{
internal const int Index = 0x06;
private int baseRVA;
internal struct Record
{
internal int RVA;
internal short ImplFlags;
internal short Flags;
internal int Name;
internal int Signature;
internal int ParamList;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].RVA = mr.ReadInt32();
records[i].ImplFlags = mr.ReadInt16();
records[i].Flags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Signature = mr.ReadBlobIndex();
records[i].ParamList = mr.ReadParam();
}
for (int i = 0; i < records.Length; i++)
{
records[i].RVA = mr.ReadInt32();
records[i].ImplFlags = mr.ReadInt16();
records[i].Flags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Signature = mr.ReadBlobIndex();
records[i].ParamList = mr.ReadParam();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="645" endline="654">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(8)
.WriteStringIndex()
.WriteBlobIndex()
.WriteParam()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="660" endline="681">
}
sealed class ParamTable
{
internal const int Index = 0x08;
internal struct Record
{
internal short Flags;
internal short Sequence;
internal int Name;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt16();
records[i].Sequence = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt16();
records[i].Sequence = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="687" endline="694">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(4)
.WriteStringIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
}
sealed class InterfaceImplTable
{
internal const int Index = 0x09;
internal struct Record
{
internal int Class;
internal int Interface;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Class = mr.ReadTypeDef();
records[i].Interface = mr.ReadTypeDefOrRef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Class = mr.ReadTypeDef();
records[i].Interface = mr.ReadTypeDefOrRef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="715" endline="723">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Class);
mw.WriteEncodedTypeDefOrRef(records[i].Interface);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Class);
mw.WriteEncodedTypeDefOrRef(records[i].Interface);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="724" endline="731">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteTypeDef()
.WriteTypeDefOrRef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="732" endline="757">
internal void Fixup()
{
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Interface;
switch (token >> 24)
{
case 0
break;
case TypeDefTable.Index
token = (token & 0xFFFFFF) << 2 | 0;
break;
case TypeRefTable.Index
token = (token & 0xFFFFFF) << 2 | 1;
break;
case TypeSpecTable.Index
token = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
records[i].Interface = token;
}
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Interface;
switch (token >> 24)
{
case 0
break;
case TypeDefTable.Index
token = (token & 0xFFFFFF) << 2 | 0;
break;
case TypeRefTable.Index
token = (token & 0xFFFFFF) << 2 | 1;
break;
case TypeSpecTable.Index
token = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
records[i].Interface = token;
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="758" endline="766">
int IComparer<Record>.Compare(Record x, Record y)
{
if (x.Class == y.Class)
{
return x.Interface == y.Interface ? 0
}
return x.Class > y.Class ? 1
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="767" endline="788">
}
sealed class MemberRefTable
{
internal const int Index = 0x0A;
internal struct Record
{
internal int Class;
internal int Name;
internal int Signature;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Class = mr.ReadMemberRefParent();
records[i].Name = mr.ReadStringIndex();
records[i].Signature = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Class = mr.ReadMemberRefParent();
records[i].Name = mr.ReadStringIndex();
records[i].Signature = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="789" endline="798">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteMemberRefParent(records[i].Class);
mw.WriteStringIndex(records[i].Name);
mw.WriteBlobIndex(records[i].Signature);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteMemberRefParent(records[i].Class);
mw.WriteStringIndex(records[i].Name);
mw.WriteBlobIndex(records[i].Signature);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="799" endline="807">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteMemberRefParent()
.WriteStringIndex()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="808" endline="821">
internal int FindOrAddRecord(Record record)
{
for (int i = 0; i < rowCount; i++)
{
if (records[i].Class == record.Class
&& records[i].Name == record.Name
&& records[i].Signature == record.Signature)
{
return i + 1;
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i].Class == record.Class
&& records[i].Name == record.Name
&& records[i].Signature == record.Signature)
{
return i + 1;
}
}
return AddRecord(record);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="822" endline="832">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Class))
{
records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
}
}
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Class))
{
records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="833" endline="854">
}
sealed class ConstantTable
{
internal const int Index = 0x0B;
internal struct Record
{
internal short Type;
internal int Parent;
internal int Value;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Type = mr.ReadInt16();
records[i].Parent = mr.ReadHasConstant();
records[i].Value = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Type = mr.ReadInt16();
records[i].Parent = mr.ReadHasConstant();
records[i].Value = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="855" endline="864">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Type);
mw.WriteHasConstant(records[i].Parent);
mw.WriteBlobIndex(records[i].Value);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Type);
mw.WriteHasConstant(records[i].Parent);
mw.WriteBlobIndex(records[i].Value);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="865" endline="873">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteHasConstant()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="874" endline="901">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Parent;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case FieldTable.Index
records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
break;
case ParamTable.Index
records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
break;
case PropertyTable.Index
records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
}
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Parent;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case FieldTable.Index
records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
break;
case ParamTable.Index
records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
break;
case PropertyTable.Index
records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="907" endline="964">
internal object GetRawConstantValue(Module module, int parent)
{
for (int i = 0; i < module.Constant.records.Length; i++)
{
if (module.Constant.records[i].Parent == parent)
{
ByteReader br = module.GetBlob(module.Constant.records[i].Value);
switch (module.Constant.records[i].Type)
{
case Signature.ELEMENT_TYPE_BOOLEAN
return br.ReadByte() != 0;
case Signature.ELEMENT_TYPE_I1
return br.ReadSByte();
case Signature.ELEMENT_TYPE_I2
return br.ReadInt16();
case Signature.ELEMENT_TYPE_I4
return br.ReadInt32();
case Signature.ELEMENT_TYPE_I8
return br.ReadInt64();
case Signature.ELEMENT_TYPE_U1
return br.ReadByte();
case Signature.ELEMENT_TYPE_U2
return br.ReadUInt16();
case Signature.ELEMENT_TYPE_U4
return br.ReadUInt32();
case Signature.ELEMENT_TYPE_U8
return br.ReadUInt64();
case Signature.ELEMENT_TYPE_R4
return br.ReadSingle();
case Signature.ELEMENT_TYPE_R8
return br.ReadDouble();
case Signature.ELEMENT_TYPE_CHAR
return br.ReadChar();
case Signature.ELEMENT_TYPE_STRING
{
char[] chars = new char[br.Length / 2];
for (int j = 0; j < chars.Length; j++)
{
chars[j] = br.ReadChar();
}
for (int j = 0; j < chars.Length; j++)
{
chars[j] = br.ReadChar();
}
return new String(chars);
}
case Signature.ELEMENT_TYPE_CLASS
if (br.ReadInt32() != 0)
{
throw new BadImageFormatException();
}
return null;
default
throw new BadImageFormatException();
}
}
}
for (int i = 0; i < module.Constant.records.Length; i++)
{
if (module.Constant.records[i].Parent == parent)
{
ByteReader br = module.GetBlob(module.Constant.records[i].Value);
switch (module.Constant.records[i].Type)
{
case Signature.ELEMENT_TYPE_BOOLEAN
return br.ReadByte() != 0;
case Signature.ELEMENT_TYPE_I1
return br.ReadSByte();
case Signature.ELEMENT_TYPE_I2
return br.ReadInt16();
case Signature.ELEMENT_TYPE_I4
return br.ReadInt32();
case Signature.ELEMENT_TYPE_I8
return br.ReadInt64();
case Signature.ELEMENT_TYPE_U1
return br.ReadByte();
case Signature.ELEMENT_TYPE_U2
return br.ReadUInt16();
case Signature.ELEMENT_TYPE_U4
return br.ReadUInt32();
case Signature.ELEMENT_TYPE_U8
return br.ReadUInt64();
case Signature.ELEMENT_TYPE_R4
return br.ReadSingle();
case Signature.ELEMENT_TYPE_R8
return br.ReadDouble();
case Signature.ELEMENT_TYPE_CHAR
return br.ReadChar();
case Signature.ELEMENT_TYPE_STRING
{
char[] chars = new char[br.Length / 2];
for (int j = 0; j < chars.Length; j++)
{
chars[j] = br.ReadChar();
}
return new String(chars);
}
case Signature.ELEMENT_TYPE_CLASS
if (br.ReadInt32() != 0)
{
throw new BadImageFormatException();
}
return null;
default
throw new BadImageFormatException();
}
}
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="965" endline="986">
}
sealed class CustomAttributeTable
{
internal const int Index = 0x0C;
internal struct Record
{
internal int Parent;
internal int Type;
internal int Value;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadHasCustomAttribute();
records[i].Type = mr.ReadCustomAttributeType();
records[i].Value = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadHasCustomAttribute();
records[i].Type = mr.ReadCustomAttributeType();
records[i].Value = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="987" endline="996">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteHasCustomAttribute(records[i].Parent);
mw.WriteCustomAttributeType(records[i].Type);
mw.WriteBlobIndex(records[i].Value);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteHasCustomAttribute(records[i].Parent);
mw.WriteCustomAttributeType(records[i].Type);
mw.WriteBlobIndex(records[i].Value);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="997" endline="1005">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteHasCustomAttribute()
.WriteCustomAttributeType()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1006" endline="1087">
internal void Fixup(ModuleBuilder moduleBuilder)
{
int[] genericParamFixup = moduleBuilder.GenericParam.GetIndexFixup();
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Type))
{
records[i].Type = moduleBuilder.ResolvePseudoToken(records[i].Type);
}
int token = records[i].Parent;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case MethodDefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 0;
break;
case FieldTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 1;
break;
case TypeRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 2;
break;
case TypeDefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 3;
break;
case ParamTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 4;
break;
case InterfaceImplTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 5;
break;
case MemberRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 6;
break;
case ModuleTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 7;
break;
case PropertyTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 9;
break;
case EventTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 10;
break;
case StandAloneSigTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 11;
break;
case ModuleRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 12;
break;
case TypeSpecTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 13;
break;
case AssemblyTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 14;
break;
case AssemblyRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 15;
break;
case FileTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 16;
break;
case ExportedTypeTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 17;
break;
case ManifestResourceTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 18;
break;
case GenericParamTable.Index
records[i].Parent = (genericParamFixup[(token & 0xFFFFFF) - 1] + 1) << 5 | 19;
break;
default
throw new InvalidOperationException();
}
}
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Type))
{
records[i].Type = moduleBuilder.ResolvePseudoToken(records[i].Type);
}
int token = records[i].Parent;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case MethodDefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 0;
break;
case FieldTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 1;
break;
case TypeRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 2;
break;
case TypeDefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 3;
break;
case ParamTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 4;
break;
case InterfaceImplTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 5;
break;
case MemberRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 6;
break;
case ModuleTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 7;
break;
case PropertyTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 9;
break;
case EventTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 10;
break;
case StandAloneSigTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 11;
break;
case ModuleRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 12;
break;
case TypeSpecTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 13;
break;
case AssemblyTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 14;
break;
case AssemblyRefTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 15;
break;
case FileTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 16;
break;
case ExportedTypeTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 17;
break;
case ManifestResourceTable.Index
records[i].Parent = (token & 0xFFFFFF) << 5 | 18;
break;
case GenericParamTable.Index
records[i].Parent = (genericParamFixup[(token & 0xFFFFFF) - 1] + 1) << 5 | 19;
break;
default
throw new InvalidOperationException();
}
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1093" endline="1112">
}
sealed class FieldMarshalTable
{
internal const int Index = 0x0D;
internal struct Record
{
internal int Parent;
internal int NativeType;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadHasFieldMarshal();
records[i].NativeType = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadHasFieldMarshal();
records[i].NativeType = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1113" endline="1121">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteHasFieldMarshal(records[i].Parent);
mw.WriteBlobIndex(records[i].NativeType);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteHasFieldMarshal(records[i].Parent);
mw.WriteBlobIndex(records[i].NativeType);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1122" endline="1129">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteHasFieldMarshal()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1130" endline="1150">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
int token = moduleBuilder.ResolvePseudoToken(records[i].Parent);
switch (token >> 24)
{
case FieldTable.Index
records[i].Parent = (token & 0xFFFFFF) << 1 | 0;
break;
case ParamTable.Index
records[i].Parent = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
}
for (int i = 0; i < rowCount; i++)
{
int token = moduleBuilder.ResolvePseudoToken(records[i].Parent);
switch (token >> 24)
{
case FieldTable.Index
records[i].Parent = (token & 0xFFFFFF) << 1 | 0;
break;
case ParamTable.Index
records[i].Parent = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1156" endline="1177">
}
sealed class DeclSecurityTable
{
internal const int Index = 0x0E;
internal struct Record
{
internal short Action;
internal int Parent;
internal int PermissionSet;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Action = mr.ReadInt16();
records[i].Parent = mr.ReadHasDeclSecurity();
records[i].PermissionSet = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Action = mr.ReadInt16();
records[i].Parent = mr.ReadHasDeclSecurity();
records[i].PermissionSet = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1178" endline="1187">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Action);
mw.WriteHasDeclSecurity(records[i].Parent);
mw.WriteBlobIndex(records[i].PermissionSet);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Action);
mw.WriteHasDeclSecurity(records[i].Parent);
mw.WriteBlobIndex(records[i].PermissionSet);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1188" endline="1196">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteHasDeclSecurity()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1197" endline="1225">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Parent;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case TypeDefTable.Index
token = (token & 0xFFFFFF) << 2 | 0;
break;
case MethodDefTable.Index
token = (token & 0xFFFFFF) << 2 | 1;
break;
case AssemblyTable.Index
token = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
records[i].Parent = token;
}
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Parent;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case TypeDefTable.Index
token = (token & 0xFFFFFF) << 2 | 0;
break;
case MethodDefTable.Index
token = (token & 0xFFFFFF) << 2 | 1;
break;
case AssemblyTable.Index
token = (token & 0xFFFFFF) << 2 | 2;
break;
default
throw new InvalidOperationException();
}
records[i].Parent = token;
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1231" endline="1255">
}
sealed class ClassLayoutTable
{
internal const int Index = 0x0f;
internal struct Record
{
internal short PackingSize;
internal int ClassSize;
internal int Parent;
}
internal void AddOrReplaceRecord(Record rec)
{
for (int i = 0; i < records.Length; i++)
{
if (records[i].Parent == rec.Parent)
{
records[i] = rec;
return;
}
}
for (int i = 0; i < records.Length; i++)
{
if (records[i].Parent == rec.Parent)
{
records[i] = rec;
return;
}
}
AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1256" endline="1265">
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].PackingSize = mr.ReadInt16();
records[i].ClassSize = mr.ReadInt32();
records[i].Parent = mr.ReadTypeDef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].PackingSize = mr.ReadInt16();
records[i].ClassSize = mr.ReadInt32();
records[i].Parent = mr.ReadTypeDef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1266" endline="1276">
internal override void Write(MetadataWriter mw)
{
Array.Sort(records, 0, rowCount, this);
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].PackingSize);
mw.Write(records[i].ClassSize);
mw.WriteTypeDef(records[i].Parent);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].PackingSize);
mw.Write(records[i].ClassSize);
mw.WriteTypeDef(records[i].Parent);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1277" endline="1284">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(6)
.WriteTypeDef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1290" endline="1302">
internal void GetLayout(int token, ref int pack, ref int size)
{
for (int i = 0; i < rowCount; i++)
{
if (records[i].Parent == token)
{
pack = records[i].PackingSize;
size = records[i].ClassSize;
break;
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i].Parent == token)
{
pack = records[i].PackingSize;
size = records[i].ClassSize;
break;
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1303" endline="1322">
}
sealed class FieldLayoutTable
{
internal const int Index = 0x10;
internal struct Record
{
internal int Offset;
internal int Field;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Offset = mr.ReadInt32();
records[i].Field = mr.ReadField();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Offset = mr.ReadInt32();
records[i].Field = mr.ReadField();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1323" endline="1331">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Offset);
mw.WriteField(records[i].Field);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Offset);
mw.WriteField(records[i].Field);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1332" endline="1339">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(4)
.WriteField()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1340" endline="1348">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
}
for (int i = 0; i < rowCount; i++)
{
records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1354" endline="1366">
}
sealed class StandAloneSigTable
{
internal const int Index = 0x11;
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i] = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i] = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1367" endline="1374">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteBlobIndex(records[i]);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteBlobIndex(records[i]);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1380" endline="1391">
internal int FindOrAddRecord(int blob)
{
for (int i = 0; i < rowCount; i++)
{
if (records[i] == blob)
{
return i + 1;
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i] == blob)
{
return i + 1;
}
}
return AddRecord(blob);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1392" endline="1411">
}
sealed class EventMapTable
{
internal const int Index = 0x12;
internal struct Record
{
internal int Parent;
internal int EventList;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadTypeDef();
records[i].EventList = mr.ReadEvent();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadTypeDef();
records[i].EventList = mr.ReadEvent();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1412" endline="1420">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Parent);
mw.WriteEvent(records[i].EventList);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Parent);
mw.WriteEvent(records[i].EventList);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1421" endline="1428">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteTypeDef()
.WriteEvent()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1429" endline="1450">
}
sealed class EventTable
{
internal const int Index = 0x14;
internal struct Record
{
internal short EventFlags;
internal int Name;
internal int EventType;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].EventFlags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].EventType = mr.ReadTypeDefOrRef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].EventFlags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].EventType = mr.ReadTypeDefOrRef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1451" endline="1460">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].EventFlags);
mw.WriteStringIndex(records[i].Name);
mw.WriteTypeDefOrRef(records[i].EventType);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].EventFlags);
mw.WriteStringIndex(records[i].Name);
mw.WriteTypeDefOrRef(records[i].EventType);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1461" endline="1469">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteStringIndex()
.WriteTypeDefOrRef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1470" endline="1489">
}
sealed class PropertyMapTable
{
internal const int Index = 0x15;
internal struct Record
{
internal int Parent;
internal int PropertyList;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadTypeDef();
records[i].PropertyList = mr.ReadProperty();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Parent = mr.ReadTypeDef();
records[i].PropertyList = mr.ReadProperty();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1490" endline="1498">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Parent);
mw.WriteProperty(records[i].PropertyList);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Parent);
mw.WriteProperty(records[i].PropertyList);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1499" endline="1506">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteTypeDef()
.WriteProperty()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1507" endline="1528">
}
sealed class PropertyTable
{
internal const int Index = 0x17;
internal struct Record
{
internal short Flags;
internal int Name;
internal int Type;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Type = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt16();
records[i].Name = mr.ReadStringIndex();
records[i].Type = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1529" endline="1538">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Flags);
mw.WriteStringIndex(records[i].Name);
mw.WriteBlobIndex(records[i].Type);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Flags);
mw.WriteStringIndex(records[i].Name);
mw.WriteBlobIndex(records[i].Type);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1539" endline="1547">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteStringIndex()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1548" endline="1577">
}
sealed class MethodSemanticsTable
{
internal const int Index = 0x18;
internal const short Setter = 0x0001;
internal const short Getter = 0x0002;
internal const short Other = 0x0004;
internal const short AddOn = 0x0008;
internal const short RemoveOn = 0x0010;
internal const short Fire = 0x0020;
internal struct Record
{
internal short Semantics;
internal int Method;
internal int Association;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Semantics = mr.ReadInt16();
records[i].Method = mr.ReadMethodDef();
records[i].Association = mr.ReadHasSemantics();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Semantics = mr.ReadInt16();
records[i].Method = mr.ReadMethodDef();
records[i].Association = mr.ReadHasSemantics();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1578" endline="1587">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Semantics);
mw.WriteMethodDef(records[i].Method);
mw.WriteHasSemantics(records[i].Association);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Semantics);
mw.WriteMethodDef(records[i].Method);
mw.WriteHasSemantics(records[i].Association);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1588" endline="1596">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteMethodDef()
.WriteHasSemantics()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1597" endline="1622">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Method))
{
records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
}
int token = records[i].Association;
switch (token >> 24)
{
case EventTable.Index
token = (token & 0xFFFFFF) << 1 | 0;
break;
case PropertyTable.Index
token = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
records[i].Association = token;
}
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Method))
{
records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
}
int token = records[i].Association;
switch (token >> 24)
{
case EventTable.Index
token = (token & 0xFFFFFF) << 1 | 0;
break;
case PropertyTable.Index
token = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
records[i].Association = token;
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1634" endline="1644">
internal MethodInfo[] GetMethods(Module module, int token, bool nonPublic, short semantics)
{
List<MethodInfo> methods = new List<MethodInfo>();
MethodInfo method;
for (int i = 0; (method = GetNextMethod(module, token, nonPublic, semantics, ref i)) != null; )
{
methods.Add(method);
}
for (int i = 0; (method = GetNextMethod(module, token, nonPublic, semantics, ref i)) != null; )
{
methods.Add(method);
}
return methods.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1645" endline="1665">
private MethodInfo GetNextMethod(Module module, int token, bool nonPublic, short semantics, ref int i)
{
for (; i < records.Length; i++)
{
if (records[i].Association == token)
{
if ((records[i].Semantics & semantics) != 0)
{
MethodInfo method = (MethodInfo)module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
if (nonPublic || method.IsPublic)
{
i++;
return method;
}
}
}
}
for (; i < records.Length; i++)
{
if (records[i].Association == token)
{
if ((records[i].Semantics & semantics) != 0)
{
MethodInfo method = (MethodInfo)module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
if (nonPublic || method.IsPublic)
{
i++;
return method;
}
}
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1666" endline="1683">
internal void ComputeFlags(Module module, int token, out bool isPublic, out bool isStatic)
{
isPublic = false;
isStatic = false;
MethodInfo method;
for (int i = 0; (method = GetNextMethod(module, token, true, -1, ref i)) != null; )
{
if (method.IsPublic)
{
isPublic = true;
}
if (method.IsStatic)
{
isStatic = true;
}
}
for (int i = 0; (method = GetNextMethod(module, token, true, -1, ref i)) != null; )
{
if (method.IsPublic)
{
isPublic = true;
}
if (method.IsStatic)
{
isStatic = true;
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1684" endline="1705">
}
sealed class MethodImplTable
{
internal const int Index = 0x19;
internal struct Record
{
internal int Class;
internal int MethodBody;
internal int MethodDeclaration;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Class = mr.ReadTypeDef();
records[i].MethodBody = mr.ReadMethodDefOrRef();
records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Class = mr.ReadTypeDef();
records[i].MethodBody = mr.ReadMethodDefOrRef();
records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1706" endline="1715">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Class);
mw.WriteMethodDefOrRef(records[i].MethodBody);
mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].Class);
mw.WriteMethodDefOrRef(records[i].MethodBody);
mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1716" endline="1724">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteTypeDef()
.WriteMethodDefOrRef()
.WriteMethodDefOrRef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1725" endline="1740">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
{
records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
}
if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
{
records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
}
}
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
{
records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
}
if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
{
records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
}
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1746" endline="1758">
}
sealed class ModuleRefTable
{
internal const int Index = 0x1A;
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i] = mr.ReadStringIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i] = mr.ReadStringIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteStringIndex(records[i]);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteStringIndex(records[i]);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1767" endline="1773">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteStringIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1774" endline="1785">
internal int FindOrAddRecord(int str)
{
for (int i = 0; i < rowCount; i++)
{
if (records[i] == str)
{
return i + 1;
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i] == str)
{
return i + 1;
}
}
return AddRecord(str);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1786" endline="1798">
}
sealed class TypeSpecTable
{
internal const int Index = 0x1B;
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i] = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i] = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1799" endline="1806">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteBlobIndex(records[i]);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteBlobIndex(records[i]);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1812" endline="1835">
}
sealed class ImplMapTable
{
internal const int Index = 0x1C;
internal struct Record
{
internal short MappingFlags;
internal int MemberForwarded;
internal int ImportName;
internal int ImportScope;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].MappingFlags = mr.ReadInt16();
records[i].MemberForwarded = mr.ReadMemberForwarded();
records[i].ImportName = mr.ReadStringIndex();
records[i].ImportScope = mr.ReadModuleRef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].MappingFlags = mr.ReadInt16();
records[i].MemberForwarded = mr.ReadMemberForwarded();
records[i].ImportName = mr.ReadStringIndex();
records[i].ImportScope = mr.ReadModuleRef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1836" endline="1846">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].MappingFlags);
mw.WriteMemberForwarded(records[i].MemberForwarded);
mw.WriteStringIndex(records[i].ImportName);
mw.WriteModuleRef(records[i].ImportScope);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].MappingFlags);
mw.WriteMemberForwarded(records[i].MemberForwarded);
mw.WriteStringIndex(records[i].ImportName);
mw.WriteModuleRef(records[i].ImportScope);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1847" endline="1856">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(2)
.WriteMemberForwarded()
.WriteStringIndex()
.WriteModuleRef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1857" endline="1868">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
{
records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
}
}
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
{
records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
}
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1874" endline="1893">
}
sealed class FieldRVATable
{
internal const int Index = 0x1D;
internal struct Record
{
internal int RVA;
internal int Field;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].RVA = mr.ReadInt32();
records[i].Field = mr.ReadField();
}
for (int i = 0; i < records.Length; i++)
{
records[i].RVA = mr.ReadInt32();
records[i].Field = mr.ReadField();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1894" endline="1902">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].RVA);
mw.WriteField(records[i].Field);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].RVA);
mw.WriteField(records[i].Field);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1903" endline="1910">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(4)
.WriteField()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1911" endline="1923">
internal void Fixup(ModuleBuilder moduleBuilder, int sdataRVA)
{
for (int i = 0; i < rowCount; i++)
{
records[i].RVA += sdataRVA;
if (moduleBuilder.IsPseudoToken(records[i].Field))
{
records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
}
}
for (int i = 0; i < rowCount; i++)
{
records[i].RVA += sdataRVA;
if (moduleBuilder.IsPseudoToken(records[i].Field))
{
records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
}
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1929" endline="1962">
}
sealed class AssemblyTable
{
internal const int Index = 0x20;
internal struct Record
{
internal int HashAlgId;
internal ushort MajorVersion;
internal ushort MinorVersion;
internal ushort BuildNumber;
internal ushort RevisionNumber;
internal int Flags;
internal int PublicKey;
internal int Name;
internal int Culture;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].HashAlgId = mr.ReadInt32();
records[i].MajorVersion = mr.ReadUInt16();
records[i].MinorVersion = mr.ReadUInt16();
records[i].BuildNumber = mr.ReadUInt16();
records[i].RevisionNumber = mr.ReadUInt16();
records[i].Flags = mr.ReadInt32();
records[i].PublicKey = mr.ReadBlobIndex();
records[i].Name = mr.ReadStringIndex();
records[i].Culture = mr.ReadStringIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].HashAlgId = mr.ReadInt32();
records[i].MajorVersion = mr.ReadUInt16();
records[i].MinorVersion = mr.ReadUInt16();
records[i].BuildNumber = mr.ReadUInt16();
records[i].RevisionNumber = mr.ReadUInt16();
records[i].Flags = mr.ReadInt32();
records[i].PublicKey = mr.ReadBlobIndex();
records[i].Name = mr.ReadStringIndex();
records[i].Culture = mr.ReadStringIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1963" endline="1978">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].HashAlgId);
mw.Write(records[i].MajorVersion);
mw.Write(records[i].MinorVersion);
mw.Write(records[i].BuildNumber);
mw.Write(records[i].RevisionNumber);
mw.Write(records[i].Flags);
mw.WriteBlobIndex(records[i].PublicKey);
mw.WriteStringIndex(records[i].Name);
mw.WriteStringIndex(records[i].Culture);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].HashAlgId);
mw.Write(records[i].MajorVersion);
mw.Write(records[i].MinorVersion);
mw.Write(records[i].BuildNumber);
mw.Write(records[i].RevisionNumber);
mw.Write(records[i].Flags);
mw.WriteBlobIndex(records[i].PublicKey);
mw.WriteStringIndex(records[i].Name);
mw.WriteStringIndex(records[i].Culture);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1979" endline="1988">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(16)
.WriteBlobIndex()
.WriteStringIndex()
.WriteStringIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1989" endline="2027">
}
sealed class AssemblyRefTable
{
internal const int Index = 0x23;
internal struct Record
{
internal ushort MajorVersion;
internal ushort MinorVersion;
internal ushort BuildNumber;
internal ushort RevisionNumber;
internal int Flags;
internal int PublicKeyOrToken;
internal int Name;
internal int Culture;
internal int HashValue;
}
internal int FindOrAddRecord(Record rec)
{
for (int i = 0; i < rowCount; i++)
{
if (records[i].Name == rec.Name
&& records[i].MajorVersion == rec.MajorVersion
&& records[i].MinorVersion == rec.MinorVersion
&& records[i].BuildNumber == rec.BuildNumber
&& records[i].RevisionNumber == rec.RevisionNumber
&& records[i].Flags == rec.Flags
&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
&& records[i].Culture == rec.Culture
&& records[i].HashValue == rec.HashValue
)
{
return i + 1;
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i].Name == rec.Name
&& records[i].MajorVersion == rec.MajorVersion
&& records[i].MinorVersion == rec.MinorVersion
&& records[i].BuildNumber == rec.BuildNumber
&& records[i].RevisionNumber == rec.RevisionNumber
&& records[i].Flags == rec.Flags
&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
&& records[i].Culture == rec.Culture
&& records[i].HashValue == rec.HashValue
)
{
return i + 1;
}
}
return AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2028" endline="2043">
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].MajorVersion = mr.ReadUInt16();
records[i].MinorVersion = mr.ReadUInt16();
records[i].BuildNumber = mr.ReadUInt16();
records[i].RevisionNumber = mr.ReadUInt16();
records[i].Flags = mr.ReadInt32();
records[i].PublicKeyOrToken = mr.ReadBlobIndex();
records[i].Name = mr.ReadStringIndex();
records[i].Culture = mr.ReadStringIndex();
records[i].HashValue = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].MajorVersion = mr.ReadUInt16();
records[i].MinorVersion = mr.ReadUInt16();
records[i].BuildNumber = mr.ReadUInt16();
records[i].RevisionNumber = mr.ReadUInt16();
records[i].Flags = mr.ReadInt32();
records[i].PublicKeyOrToken = mr.ReadBlobIndex();
records[i].Name = mr.ReadStringIndex();
records[i].Culture = mr.ReadStringIndex();
records[i].HashValue = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2044" endline="2059">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].MajorVersion);
mw.Write(records[i].MinorVersion);
mw.Write(records[i].BuildNumber);
mw.Write(records[i].RevisionNumber);
mw.Write(records[i].Flags);
mw.WriteBlobIndex(records[i].PublicKeyOrToken);
mw.WriteStringIndex(records[i].Name);
mw.WriteStringIndex(records[i].Culture);
mw.WriteBlobIndex(records[i].HashValue);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].MajorVersion);
mw.Write(records[i].MinorVersion);
mw.Write(records[i].BuildNumber);
mw.Write(records[i].RevisionNumber);
mw.Write(records[i].Flags);
mw.WriteBlobIndex(records[i].PublicKeyOrToken);
mw.WriteStringIndex(records[i].Name);
mw.WriteStringIndex(records[i].Culture);
mw.WriteBlobIndex(records[i].HashValue);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2060" endline="2070">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(12)
.WriteBlobIndex()
.WriteStringIndex()
.WriteStringIndex()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2071" endline="2092">
}
sealed class FileTable
{
internal const int Index = 0x26;
internal struct Record
{
internal int Flags;
internal int Name;
internal int HashValue;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt32();
records[i].Name = mr.ReadStringIndex();
records[i].HashValue = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt32();
records[i].Name = mr.ReadStringIndex();
records[i].HashValue = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2093" endline="2102">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Flags);
mw.WriteStringIndex(records[i].Name);
mw.WriteBlobIndex(records[i].HashValue);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Flags);
mw.WriteStringIndex(records[i].Name);
mw.WriteBlobIndex(records[i].HashValue);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2103" endline="2111">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(4)
.WriteStringIndex()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2112" endline="2137">
}
sealed class ExportedTypeTable
{
internal const int Index = 0x27;
internal struct Record
{
internal int Flags;
internal int TypeDefId;
internal int TypeName;
internal int TypeNamespace;
internal int Implementation;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt32();
records[i].TypeDefId = mr.ReadInt32();
records[i].TypeName = mr.ReadStringIndex();
records[i].TypeNamespace = mr.ReadStringIndex();
records[i].Implementation = mr.ReadImplementation();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Flags = mr.ReadInt32();
records[i].TypeDefId = mr.ReadInt32();
records[i].TypeName = mr.ReadStringIndex();
records[i].TypeNamespace = mr.ReadStringIndex();
records[i].Implementation = mr.ReadImplementation();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2138" endline="2149">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Flags);
mw.Write(records[i].TypeDefId);
mw.WriteStringIndex(records[i].TypeName);
mw.WriteStringIndex(records[i].TypeNamespace);
mw.WriteImplementation(records[i].Implementation);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Flags);
mw.Write(records[i].TypeDefId);
mw.WriteStringIndex(records[i].TypeName);
mw.WriteStringIndex(records[i].TypeNamespace);
mw.WriteImplementation(records[i].Implementation);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2150" endline="2159">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(8)
.WriteStringIndex()
.WriteStringIndex()
.WriteImplementation()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2160" endline="2173">
internal int FindOrAddRecord(Record rec)
{
for (int i = 0; i < rowCount; i++)
{
if (records[i].Implementation == rec.Implementation
&& records[i].TypeName == rec.TypeName
&& records[i].TypeNamespace == rec.TypeNamespace)
{
return i + 1;
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i].Implementation == rec.Implementation
&& records[i].TypeName == rec.TypeName
&& records[i].TypeNamespace == rec.TypeNamespace)
{
return i + 1;
}
}
return AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2174" endline="2197">
}
sealed class ManifestResourceTable
{
internal const int Index = 0x28;
internal struct Record
{
internal int Offset;
internal int Flags;
internal int Name;
internal int Implementation;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Offset = mr.ReadInt32();
records[i].Flags = mr.ReadInt32();
records[i].Name = mr.ReadStringIndex();
records[i].Implementation = mr.ReadImplementation();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Offset = mr.ReadInt32();
records[i].Flags = mr.ReadInt32();
records[i].Name = mr.ReadStringIndex();
records[i].Implementation = mr.ReadImplementation();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2198" endline="2208">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Offset);
mw.Write(records[i].Flags);
mw.WriteStringIndex(records[i].Name);
mw.WriteImplementation(records[i].Implementation);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Offset);
mw.Write(records[i].Flags);
mw.WriteStringIndex(records[i].Name);
mw.WriteImplementation(records[i].Implementation);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2209" endline="2217">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(8)
.WriteStringIndex()
.WriteImplementation()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2218" endline="2237">
}
sealed class NestedClassTable
{
internal const int Index = 0x29;
internal struct Record
{
internal int NestedClass;
internal int EnclosingClass;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].NestedClass = mr.ReadTypeDef();
records[i].EnclosingClass = mr.ReadTypeDef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].NestedClass = mr.ReadTypeDef();
records[i].EnclosingClass = mr.ReadTypeDef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2238" endline="2246">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].NestedClass);
mw.WriteTypeDef(records[i].EnclosingClass);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteTypeDef(records[i].NestedClass);
mw.WriteTypeDef(records[i].EnclosingClass);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2247" endline="2254">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteTypeDef()
.WriteTypeDef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2255" endline="2267">
internal List<int> GetNestedClasses(int enclosingClass)
{
List<int> nestedClasses = new List<int>();
for (int i = 0; i < rowCount; i++)
{
if (records[i].EnclosingClass == enclosingClass)
{
nestedClasses.Add(records[i].NestedClass);
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i].EnclosingClass == enclosingClass)
{
nestedClasses.Add(records[i].NestedClass);
}
}
return nestedClasses;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2268" endline="2293">
}
sealed class GenericParamTable
{
internal const int Index = 0x2A;
internal struct Record
{
internal short Number;
internal short Flags;
internal int Owner;
internal int Name;
internal int unsortedIndex;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Number = mr.ReadInt16();
records[i].Flags = mr.ReadInt16();
records[i].Owner = mr.ReadTypeOrMethodDef();
records[i].Name = mr.ReadStringIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Number = mr.ReadInt16();
records[i].Flags = mr.ReadInt16();
records[i].Owner = mr.ReadTypeOrMethodDef();
records[i].Name = mr.ReadStringIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2294" endline="2304">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Number);
mw.Write(records[i].Flags);
mw.WriteTypeOrMethodDef(records[i].Owner);
mw.WriteStringIndex(records[i].Name);
}
for (int i = 0; i < rowCount; i++)
{
mw.Write(records[i].Number);
mw.Write(records[i].Flags);
mw.WriteTypeOrMethodDef(records[i].Owner);
mw.WriteStringIndex(records[i].Name);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2305" endline="2313">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.AddFixed(4)
.WriteTypeOrMethodDef()
.WriteStringIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2314" endline="2339">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Owner;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case TypeDefTable.Index
records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
break;
case MethodDefTable.Index
records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
records[i].unsortedIndex = i;
}
for (int i = 0; i < rowCount; i++)
{
int token = records[i].Owner;
if (moduleBuilder.IsPseudoToken(token))
{
token = moduleBuilder.ResolvePseudoToken(token);
}
switch (token >> 24)
{
case TypeDefTable.Index
records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
break;
case MethodDefTable.Index
records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
break;
default
throw new InvalidOperationException();
}
records[i].unsortedIndex = i;
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2340" endline="2348">
int IComparer<Record>.Compare(Record x, Record y)
{
if (x.Owner == y.Owner)
{
return x.Number == y.Number ? 0
}
return x.Owner > y.Owner ? 1
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2359" endline="2368">
internal int[] GetIndexFixup()
{
int[] array = new int[rowCount];
for (int i = 0; i < rowCount; i++)
{
array[records[i].unsortedIndex] = i;
}
for (int i = 0; i < rowCount; i++)
{
array[records[i].unsortedIndex] = i;
}
return array;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2369" endline="2381">
internal int FindFirstByOwner(int token)
{
for (int i = 0; i < records.Length; i++)
{
if (records[i].Owner == token)
{
return i;
}
}
for (int i = 0; i < records.Length; i++)
{
if (records[i].Owner == token)
{
return i;
}
}
return -1;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2382" endline="2401">
}
sealed class MethodSpecTable
{
internal const int Index = 0x2B;
internal struct Record
{
internal int Method;
internal int Instantiation;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Method = mr.ReadMethodDefOrRef();
records[i].Instantiation = mr.ReadBlobIndex();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Method = mr.ReadMethodDefOrRef();
records[i].Instantiation = mr.ReadBlobIndex();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2402" endline="2410">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteMethodDefOrRef(records[i].Method);
mw.WriteBlobIndex(records[i].Instantiation);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteMethodDefOrRef(records[i].Method);
mw.WriteBlobIndex(records[i].Instantiation);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2411" endline="2418">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteMethodDefOrRef()
.WriteBlobIndex()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2419" endline="2431">
internal int FindOrAddRecord(Record record)
{
for (int i = 0; i < rowCount; i++)
{
if (records[i].Method == record.Method
&& records[i].Instantiation == record.Instantiation)
{
return i + 1;
}
}
for (int i = 0; i < rowCount; i++)
{
if (records[i].Method == record.Method
&& records[i].Instantiation == record.Instantiation)
{
return i + 1;
}
}
return AddRecord(record);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2432" endline="2442">
internal void Fixup(ModuleBuilder moduleBuilder)
{
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Method))
{
records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
}
}
for (int i = 0; i < rowCount; i++)
{
if (moduleBuilder.IsPseudoToken(records[i].Method))
{
records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2443" endline="2462">
}
sealed class GenericParamConstraintTable
{
internal const int Index = 0x2C;
internal struct Record
{
internal int Owner;
internal int Constraint;
}
internal override void Read(MetadataReader mr)
{
for (int i = 0; i < records.Length; i++)
{
records[i].Owner = mr.ReadGenericParam();
records[i].Constraint = mr.ReadTypeDefOrRef();
}
for (int i = 0; i < records.Length; i++)
{
records[i].Owner = mr.ReadGenericParam();
records[i].Constraint = mr.ReadTypeDefOrRef();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2463" endline="2471">
internal override void Write(MetadataWriter mw)
{
for (int i = 0; i < rowCount; i++)
{
mw.WriteGenericParam(records[i].Owner);
mw.WriteTypeDefOrRef(records[i].Constraint);
}
for (int i = 0; i < rowCount; i++)
{
mw.WriteGenericParam(records[i].Owner);
mw.WriteTypeDefOrRef(records[i].Constraint);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2472" endline="2479">
protected override int GetRowSize(RowSizeCalc rsc)
{
return rsc
.WriteGenericParam()
.WriteTypeDefOrRef()
.Value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2480" endline="2489">
internal void Fixup(ModuleBuilder moduleBuilder)
{
int[] fixups = moduleBuilder.GenericParam.GetIndexFixup();
for (int i = 0; i < rowCount; i++)
{
records[i].Owner = fixups[records[i].Owner - 1] + 1;
}
for (int i = 0; i < rowCount; i++)
{
records[i].Owner = fixups[records[i].Owner - 1] + 1;
}
Array.Sort(records, 0, rowCount, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="83" endline="96">
}
static class Util
{
internal static Type[] Copy(Type[] array)
{
if (array == null || array.Length == 0)
{
return Type.EmptyTypes;
}
Type[] copy = new Type[array.Length];
Array.Copy(array, copy, array.Length);
return copy;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="97" endline="110">
internal static Type[][] Copy(Type[][] types)
{
if (types == null || types.Length == 0)
{
return types;
}
Type[][] newArray = new Type[types.Length][];
for (int i = 0; i < newArray.Length; i++)
{
newArray[i] = Copy(types[i]);
}
for (int i = 0; i < newArray.Length; i++)
{
newArray[i] = Copy(types[i]);
}
return newArray;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="111" endline="124">
internal static T[] ToArray<T, V>(List<V> list, T[] empty) where V
{
if (list == null || list.Count == 0)
{
return empty;
}
T[] array = new T[list.Count];
for (int i = 0; i < array.Length; i++)
{
array[i] = list[i];
}
for (int i = 0; i < array.Length; i++)
{
array[i] = list[i];
}
return array;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="125" endline="153">
internal static bool ArrayEquals(Type[] t1, Type[] t2)
{
if (t1 == t2)
{
return true;
}
if (t1 == null)
{
return t2.Length == 0;
}
else if (t2 == null)
{
return t1.Length == 0;
}
if (t1.Length == t2.Length)
{
for (int i = 0; i < t1.Length; i++)
{
if (!TypeEquals(t1[i], t2[i]))
{
return false;
}
}
for (int i = 0; i < t1.Length; i++)
{
if (!TypeEquals(t1[i], t2[i]))
{
return false;
}
}
return true;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="154" endline="181">
internal static bool ArrayEquals(Type[][] t1, Type[][] t2)
{
if (t1 == t2)
{
return true;
}
if (t1 == null)
{
return t2.Length == 0;
}
else if (t2 == null)
{
return t1.Length == 0;
}
if (t1.Length == t2.Length)
{
for (int i = 0; i < t1.Length; i++)
{
if (!ArrayEquals(t1[i], t2[i]))
{
return false;
}
}
for (int i = 0; i < t1.Length; i++)
{
if (!ArrayEquals(t1[i], t2[i]))
{
return false;
}
}
return true;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="182" endline="209">
internal static bool ArrayEquals(Type[][][] t1, Type[][][] t2)
{
if (t1 == t2)
{
return true;
}
if (t1 == null)
{
return t2.Length == 0;
}
else if (t2 == null)
{
return t1.Length == 0;
}
if (t1.Length == t2.Length)
{
for (int i = 0; i < t1.Length; i++)
{
if (!ArrayEquals(t1[i], t2[i]))
{
return false;
}
}
for (int i = 0; i < t1.Length; i++)
{
if (!ArrayEquals(t1[i], t2[i]))
{
return false;
}
}
return true;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="210" endline="222">
internal static bool TypeEquals(Type t1, Type t2)
{
if (t1 == t2)
{
return true;
}
if (t1 == null)
{
return false;
}
return t1.Equals(t2);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="223" endline="240">
internal static int GetHashCode(Type[] types)
{
if (types == null)
{
return 0;
}
int h = 0;
foreach (Type t in types)
{
if (t != null)
{
h *= 3;
h ^= t.GetHashCode();
}
}
foreach (Type t in types)
{
if (t != null)
{
h *= 3;
h ^= t.GetHashCode();
}
}
return h;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="241" endline="253">
internal static int GetHashCode(Type[][] types)
{
int h = 0;
if (types != null)
{
foreach (Type[] array in types)
{
h ^= GetHashCode(array);
}
foreach (Type[] array in types)
{
h ^= GetHashCode(array);
}
}
return h;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="254" endline="266">
internal static int GetHashCode(Type[][][] types)
{
int h = 0;
if (types != null)
{
foreach (Type[][] array in types)
{
h ^= GetHashCode(array);
}
foreach (Type[][] array in types)
{
h ^= GetHashCode(array);
}
}
return h;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="267" endline="282">
}
[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
struct SingleConverter
{
[System.Runtime.InteropServices.FieldOffset(0)]
private int i;
[System.Runtime.InteropServices.FieldOffset(0)]
private float f;
internal static int SingleToInt32Bits(float v)
{
SingleConverter c = new SingleConverter();
c.f = v;
return c.i;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="283" endline="289">
internal static float Int32BitsToSingle(int v)
{
SingleConverter c = new SingleConverter();
c.i = v;
return c.f;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodBody.cs" startline="40" endline="121">
internal MethodBody(ModuleReader module, int rva, IGenericContext context)
{
const byte CorILMethod_TinyFormat = 0x02;
const byte CorILMethod_FatFormat = 0x03;
const byte CorILMethod_MoreSects = 0x08;
const byte CorILMethod_InitLocals = 0x10;
const byte CorILMethod_Sect_EHTable = 0x01;
const byte CorILMethod_Sect_FatFormat = 0x40;
const byte CorILMethod_Sect_MoreSects = 0x80;
List<ExceptionHandlingClause> exceptionClauses = new List<ExceptionHandlingClause>();
List<LocalVariableInfo> locals = new List<LocalVariableInfo>();
module.SeekRVA(rva);
BinaryReader br = new BinaryReader(module.stream);
byte b = br.ReadByte();
if ((b & 3) == CorILMethod_TinyFormat)
{
initLocals = true;
body = br.ReadBytes(b >> 2);
}
else if ((b & 3) == CorILMethod_FatFormat)
{
initLocals = (b & CorILMethod_InitLocals) != 0;
short flagsAndSize = (short)(b | (br.ReadByte() << 8));
if ((flagsAndSize >> 12) != 3)
{
throw new BadImageFormatException("Fat format method header size should be 3");
}
maxStack = br.ReadUInt16();
int codeLength = br.ReadInt32();
localVarSigTok = br.ReadInt32();
body = br.ReadBytes(codeLength);
if ((b & CorILMethod_MoreSects) != 0)
{
module.stream.Position = (module.stream.Position + 3) & ~3;
int hdr = br.ReadInt32();
if ((hdr & CorILMethod_Sect_MoreSects) != 0 || (hdr & CorILMethod_Sect_EHTable) == 0)
{
throw new NotImplementedException();
}
else if ((hdr & CorILMethod_Sect_FatFormat) != 0)
{
int count = ComputeExceptionCount((hdr >> 8) & 0xFFFFFF, 24);
for (int i = 0; i < count; i++)
{
int flags = br.ReadInt32();
int tryOffset = br.ReadInt32();
int tryLength = br.ReadInt32();
int handlerOffset = br.ReadInt32();
int handlerLength = br.ReadInt32();
int classTokenOrFilterOffset = br.ReadInt32();
exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
}
for (int i = 0; i < count; i++)
{
int flags = br.ReadInt32();
int tryOffset = br.ReadInt32();
int tryLength = br.ReadInt32();
int handlerOffset = br.ReadInt32();
int handlerLength = br.ReadInt32();
int classTokenOrFilterOffset = br.ReadInt32();
exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
}
}
else
{
int count = ComputeExceptionCount((hdr >> 8) & 0xFF, 12);
for (int i = 0; i < count; i++)
{
int flags = br.ReadUInt16();
int tryOffset = br.ReadUInt16();
int tryLength = br.ReadByte();
int handlerOffset = br.ReadUInt16();
int handlerLength = br.ReadByte();
int classTokenOrFilterOffset = br.ReadInt32();
exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
}
for (int i = 0; i < count; i++)
{
int flags = br.ReadUInt16();
int tryOffset = br.ReadUInt16();
int tryLength = br.ReadByte();
int handlerOffset = br.ReadUInt16();
int handlerLength = br.ReadByte();
int classTokenOrFilterOffset = br.ReadInt32();
exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
}
}
}
if (localVarSigTok != 0)
{
ByteReader sig = module.ResolveSignature(localVarSigTok);
Signature.ReadLocalVarSig(module, sig, context, locals);
}
}
else
{
throw new BadImageFormatException();
}
this.exceptionClauses = exceptionClauses.AsReadOnly();
this.locals = locals.AsReadOnly();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ConstructorInfo.cs" startline="49" endline="59">
}
public sealed override ParameterInfo[] GetParameters()
{
ParameterInfo[] parameters = GetMethodInfo().GetParameters();
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
}
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
}
return parameters;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ParameterInfo.cs" startline="50" endline="64">
public abstract string Name { get; }
public abstract Type ParameterType { get; }
public abstract ParameterAttributes Attributes { get; }
public abstract int Position { get; }
public abstract object RawDefaultValue { get; }
public abstract Type[] GetOptionalCustomModifiers();
public abstract Type[] GetRequiredCustomModifiers();
public abstract MemberInfo Member { get; }
public abstract int MetadataToken { get; }
internal abstract Module Module { get; }
public bool IsIn
{
get { return (Attributes & ParameterAttributes.In) != 0; }
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="38" endline="47">
{
int pos = mw.Position;
WriteImpl(mw);
Debug.Assert(mw.Position == pos + unalignedlength);
int align = Length - unalignedlength;
for (int i = 0; i < align; i++)
{
mw.Write((byte)0);
}
for (int i = 0; i < align; i++)
{
mw.Write((byte)0);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="52" endline="61">
}
internal int Length
{
get
{
if (!frozen)
throw new InvalidOperationException();
return (unalignedlength + 3) & ~3;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="62" endline="75">
}
protected abstract void WriteImpl(MetadataWriter mw);
}
abstract class SimpleHeap
{
internal void Freeze()
{
if (frozen)
throw new InvalidOperationException();
frozen = true;
unalignedlength = GetLength();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="76" endline="88">
protected abstract int GetLength();
}
sealed class TableHeap
{
internal void Freeze(MetadataWriter mw)
{
if (frozen)
throw new InvalidOperationException();
frozen = true;
unalignedlength = GetLength(mw);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="89" endline="146">
protected override void WriteImpl(MetadataWriter mw)
{
Table[] tables = mw.ModuleBuilder.GetTables();
mw.Write(0);		// Reserved
int ver = mw.ModuleBuilder.MDStreamVersion;
mw.Write((byte)(ver >> 16));	// MajorVersion
mw.Write((byte)ver);			// MinorVersion
byte heapSizes = 0;
if (mw.ModuleBuilder.Strings.IsBig)
{
heapSizes |= 0x01;
}
if (mw.ModuleBuilder.Guids.IsBig)
{
heapSizes |= 0x02;
}
if (mw.ModuleBuilder.Blobs.IsBig)
{
heapSizes |= 0x04;
}
mw.Write(heapSizes);// HeapSizes
mw.Write((byte)0x10);	// Reserved
long bit = 1;
long valid = 0;
foreach (Table table in tables)
{
if (table != null && table.RowCount > 0)
{
valid |= bit;
}
bit <<= 1;
}
foreach (Table table in tables)
{
if (table != null && table.RowCount > 0)
{
valid |= bit;
}
bit <<= 1;
}
mw.Write(valid);	// Valid
mw.Write(0x0016003301FA00L);	// Sorted
foreach (Table table in tables)
{
if (table != null && table.RowCount > 0)
{
mw.Write(table.RowCount);
}
}
foreach (Table table in tables)
{
if (table != null && table.RowCount > 0)
{
mw.Write(table.RowCount);
}
}
foreach (Table table in tables)
{
if (table != null && table.RowCount > 0)
{
int pos = mw.Position;
table.Write(mw);
Debug.Assert(mw.Position - pos == table.GetLength(mw));
}
}
foreach (Table table in tables)
{
if (table != null && table.RowCount > 0)
{
int pos = mw.Position;
table.Write(mw);
Debug.Assert(mw.Position - pos == table.GetLength(mw));
}
}
mw.Write((byte)0);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="147" endline="161">
private int GetLength(MetadataWriter mw)
{
int len = 4 + 4 + 8 + 8;
foreach (Table table in mw.ModuleBuilder.GetTables())
{
if (table != null && table.RowCount > 0)
{
len += 4;	// row count
len += table.GetLength(mw);
}
}
foreach (Table table in mw.ModuleBuilder.GetTables())
{
if (table != null && table.RowCount > 0)
{
len += 4;	// row count
len += table.GetLength(mw);
}
}
return len + 1;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="162" endline="173">
}
sealed class StringHeap
{
private List<string> list = new List<string>();
private Dictionary<string, int> strings = new Dictionary<string, int>();
private int nextOffset;
internal StringHeap()
{
Add("");
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="174" endline="187">
internal int Add(string str)
{
Debug.Assert(!frozen);
int offset;
if (!strings.TryGetValue(str, out offset))
{
offset = nextOffset;
nextOffset += System.Text.Encoding.UTF8.GetByteCount(str) + 1;
list.Add(str);
strings.Add(str, offset);
}
return offset;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="193" endline="201">
protected override void WriteImpl(MetadataWriter mw)
{
foreach (string str in list)
{
mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
mw.Write((byte)0);
}
foreach (string str in list)
{
mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
mw.Write((byte)0);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="202" endline="213">
}
sealed class UserStringHeap
{
private List<string> list = new List<string>();
private Dictionary<string, int> strings = new Dictionary<string, int>();
private int nextOffset;
internal UserStringHeap()
{
nextOffset = 1;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="218" endline="237">
}
internal int Add(string str)
{
Debug.Assert(!frozen);
int offset;
if (!strings.TryGetValue(str, out offset))
{
int length = str.Length * 2 + 1 + MetadataWriter.GetCompressedIntLength(str.Length * 2 + 1);
if (nextOffset + length > 0xFFFFFF)
{
throw new FileFormatLimitationExceededException("No logical space left to create more user strings.", FileFormatLimitationExceededException.META_E_STRINGSPACE_FULL);
}
offset = nextOffset;
nextOffset += length;
list.Add(str);
strings.Add(str, offset);
}
return offset;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="243" endline="268">
protected override void WriteImpl(MetadataWriter mw)
{
mw.Write((byte)0);
foreach (string str in list)
{
mw.WriteCompressedInt(str.Length * 2 + 1);
byte hasSpecialChars = 0;
foreach (char ch in str)
{
mw.Write((ushort)ch);
if (hasSpecialChars == 0 && (ch < 0x20 || ch > 0x7E))
{
if (ch > 0x7E
|| (ch >= 0x01 && ch <= 0x08)
|| (ch >= 0x0E && ch <= 0x1F)
|| ch == 0x27
|| ch == 0x2D)
{
hasSpecialChars = 1;
}
}
}
foreach (char ch in str)
{
mw.Write((ushort)ch);
if (hasSpecialChars == 0 && (ch < 0x20 || ch > 0x7E))
{
if (ch > 0x7E
|| (ch >= 0x01 && ch <= 0x08)
|| (ch >= 0x0E && ch <= 0x1F)
|| ch == 0x27
|| ch == 0x2D)
{
hasSpecialChars = 1;
}
}
}
mw.Write(hasSpecialChars);
}
foreach (string str in list)
{
mw.WriteCompressedInt(str.Length * 2 + 1);
byte hasSpecialChars = 0;
foreach (char ch in str)
{
mw.Write((ushort)ch);
if (hasSpecialChars == 0 && (ch < 0x20 || ch > 0x7E))
{
if (ch > 0x7E
|| (ch >= 0x01 && ch <= 0x08)
|| (ch >= 0x0E && ch <= 0x1F)
|| ch == 0x27
|| ch == 0x2D)
{
hasSpecialChars = 1;
}
}
}
mw.Write(hasSpecialChars);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="269" endline="277">
}
sealed class GuidHeap
{
private List<Guid> list = new List<Guid>();
internal GuidHeap()
{
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="278" endline="284">
internal int Add(Guid guid)
{
Debug.Assert(!frozen);
list.Add(guid);
return list.Count;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="290" endline="297">
protected override void WriteImpl(MetadataWriter mw)
{
foreach (Guid guid in list)
{
mw.Write(guid.ToByteArray());
}
foreach (Guid guid in list)
{
mw.Write(guid.ToByteArray());
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="298" endline="316">
}
sealed class BlobHeap
{
private Key[] map = new Key[8179];
private readonly ByteBuffer buf = new ByteBuffer(32);
private struct Key
{
internal Key[] next;
internal int len;
internal int hash;
internal int offset;
}
internal BlobHeap()
{
buf.Write((byte)0);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="317" endline="360">
internal int Add(ByteBuffer bb)
{
Debug.Assert(!frozen);
if (bb.Length == 0)
{
return 0;
}
int lenlen = MetadataWriter.GetCompressedIntLength(bb.Length);
int hash = bb.Hash();
int index = (hash & 0x7FFFFFFF) % map.Length;
Key[] keys = map;
int last = index;
while (keys[index].offset != 0)
{
if (keys[index].hash == hash
&& keys[index].len == bb.Length
&& buf.Match(keys[index].offset + lenlen, bb, 0, bb.Length))
{
return keys[index].offset;
}
if (index == last)
{
if (keys[index].next == null)
{
keys[index].next = new Key[4];
keys = keys[index].next;
index = 0;
break;
}
keys = keys[index].next;
index = -1;
last = keys.Length - 1;
}
index++;
}
while (keys[index].offset != 0)
{
if (keys[index].hash == hash
&& keys[index].len == bb.Length
&& buf.Match(keys[index].offset + lenlen, bb, 0, bb.Length))
{
return keys[index].offset;
}
if (index == last)
{
if (keys[index].next == null)
{
keys[index].next = new Key[4];
keys = keys[index].next;
index = 0;
break;
}
keys = keys[index].next;
index = -1;
last = keys.Length - 1;
}
index++;
}
int offset = buf.Position;
buf.WriteCompressedInt(bb.Length);
buf.Write(bb);
keys[index].len = bb.Length;
keys[index].hash = hash;
keys[index].offset = offset;
return offset;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodInfo.cs" startline="34" endline="41">
}
public abstract Type ReturnType { get; }
public abstract ParameterInfo ReturnParameter { get; }
public virtual MethodInfo MakeGenericMethod(params Type[] typeArguments)
{
throw new NotSupportedException(this.GetType().FullName);
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodInfo.cs" startline="47" endline="74">
}
public override string ToString()
{
StringBuilder sb = new StringBuilder();
sb.Append(this.ReturnType.Name).Append(' ').Append(this.Name);
string sep;
if (this.IsGenericMethod)
{
sb.Append('[');
sep = "";
foreach (Type arg in GetGenericArguments())
{
sb.Append(sep).Append(arg);
sep = ", ";
}
foreach (Type arg in GetGenericArguments())
{
sb.Append(sep).Append(arg);
sep = ", ";
}
sb.Append(']');
}
sb.Append('(');
sep = "";
foreach (ParameterInfo arg in GetParameters())
{
sb.Append(sep).Append(arg.ParameterType);
sep = ", ";
}
foreach (ParameterInfo arg in GetParameters())
{
sb.Append(sep).Append(arg.ParameterType);
sep = ", ";
}
sb.Append(')');
return sb.ToString();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodInfo.cs" startline="79" endline="96">
}
public MethodInfo GetBaseDefinition()
{
MethodInfo match = this;
if (match.IsVirtual)
{
for (Type type = this.DeclaringType.BaseType; type != null && !match.IsNewSlot; type = type.BaseType)
{
MethodInfo method = type.FindMethod(this.Name, this.MethodSignature) as MethodInfo;
if (method != null && method.IsVirtual)
{
match = method;
}
}
for (Type type = this.DeclaringType.BaseType; type != null && !match.IsNewSlot; type = type.BaseType)
{
MethodInfo method = type.FindMethod(this.Name, this.MethodSignature) as MethodInfo;
if (method != null && method.IsVirtual)
{
match = method;
}
}
}
return match;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="40" endline="164">
{
for (int i = 0; i < module.FieldMarshal.records.Length; i++)
{
if (module.FieldMarshal.records[i].Parent == token)
{
ByteReader blob = module.GetBlob(module.FieldMarshal.records[i].NativeType);
UnmanagedType unmanagedType = (UnmanagedType)blob.ReadCompressedInt();
UnmanagedType? arraySubType = null;
short? sizeParamIndex = null;
int? sizeConst = null;
VarEnum? safeArraySubType = null;
Type safeArrayUserDefinedSubType = null;
int? iidParameterIndex = null;
string marshalType = null;
string marshalCookie = null;
Type marshalTypeRef = null;
if (unmanagedType == UnmanagedType.LPArray)
{
arraySubType = (UnmanagedType)blob.ReadCompressedInt();
if (arraySubType == NATIVE_TYPE_MAX)
{
arraySubType = null;
}
if (blob.Length != 0)
{
sizeParamIndex = (short)blob.ReadCompressedInt();
if (blob.Length != 0)
{
sizeConst = blob.ReadCompressedInt();
if (blob.Length != 0 && blob.ReadCompressedInt() == 0)
{
sizeParamIndex = null;
}
}
}
}
else if (unmanagedType == UnmanagedType.SafeArray)
{
if (blob.Length != 0)
{
safeArraySubType = (VarEnum)blob.ReadCompressedInt();
if (blob.Length != 0)
{
safeArrayUserDefinedSubType = ReadType(module, blob);
}
}
}
else if (unmanagedType == UnmanagedType.ByValArray)
{
sizeConst = blob.ReadCompressedInt();
if (blob.Length != 0)
{
arraySubType = (UnmanagedType)blob.ReadCompressedInt();
}
}
else if (unmanagedType == UnmanagedType.ByValTStr)
{
sizeConst = blob.ReadCompressedInt();
}
else if (unmanagedType == UnmanagedType.Interface
|| unmanagedType == UnmanagedType.IDispatch
|| unmanagedType == UnmanagedType.IUnknown)
{
if (blob.Length != 0)
{
iidParameterIndex = blob.ReadCompressedInt();
}
}
else if (unmanagedType == UnmanagedType.CustomMarshaler)
{
blob.ReadCompressedInt();
blob.ReadCompressedInt();
marshalType = ReadString(blob);
marshalCookie = ReadString(blob);
marshalTypeRef = module.Assembly.GetType(marshalType) ?? module.universe.GetType(marshalType);
}
Type typeofMarshalAs = module.universe.System_Runtime_InteropServices_MarshalAsAttribute;
Type typeofUnmanagedType = module.universe.System_Runtime_InteropServices_UnmanagedType;
Type typeofVarEnum = module.universe.System_Runtime_InteropServices_VarEnum;
Type typeofType = module.universe.System_Type;
List<CustomAttributeNamedArgument> named = new List<CustomAttributeNamedArgument>();
if (arraySubType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("ArraySubType"), new CustomAttributeTypedArgument(typeofUnmanagedType, arraySubType.Value)));
}
if (sizeParamIndex != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeParamIndex"), new CustomAttributeTypedArgument(module.universe.System_Int16, sizeParamIndex.Value)));
}
if (sizeConst != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeConst"), new CustomAttributeTypedArgument(module.universe.System_Int32, sizeConst.Value)));
}
if (safeArraySubType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArraySubType"), new CustomAttributeTypedArgument(typeofVarEnum, safeArraySubType.Value)));
}
if (safeArrayUserDefinedSubType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArrayUserDefinedSubType"), new CustomAttributeTypedArgument(typeofType, safeArrayUserDefinedSubType)));
}
if (iidParameterIndex != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("IidParameterIndex"), new CustomAttributeTypedArgument(module.universe.System_Int32, iidParameterIndex.Value)));
}
if (marshalType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalType"), new CustomAttributeTypedArgument(module.universe.System_String, marshalType)));
}
if (marshalTypeRef != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalTypeRef"), new CustomAttributeTypedArgument(module.universe.System_Type, marshalTypeRef)));
}
if (marshalCookie != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalCookie"), new CustomAttributeTypedArgument(module.universe.System_String, marshalCookie)));
}
ConstructorInfo constructor = typeofMarshalAs.GetConstructor(new Type[] { typeofUnmanagedType });
return new CustomAttributeData(constructor, new object[] { unmanagedType }, named);
}
}
for (int i = 0; i < module.FieldMarshal.records.Length; i++)
{
if (module.FieldMarshal.records[i].Parent == token)
{
ByteReader blob = module.GetBlob(module.FieldMarshal.records[i].NativeType);
UnmanagedType unmanagedType = (UnmanagedType)blob.ReadCompressedInt();
UnmanagedType? arraySubType = null;
short? sizeParamIndex = null;
int? sizeConst = null;
VarEnum? safeArraySubType = null;
Type safeArrayUserDefinedSubType = null;
int? iidParameterIndex = null;
string marshalType = null;
string marshalCookie = null;
Type marshalTypeRef = null;
if (unmanagedType == UnmanagedType.LPArray)
{
arraySubType = (UnmanagedType)blob.ReadCompressedInt();
if (arraySubType == NATIVE_TYPE_MAX)
{
arraySubType = null;
}
if (blob.Length != 0)
{
sizeParamIndex = (short)blob.ReadCompressedInt();
if (blob.Length != 0)
{
sizeConst = blob.ReadCompressedInt();
if (blob.Length != 0 && blob.ReadCompressedInt() == 0)
{
sizeParamIndex = null;
}
}
}
}
else if (unmanagedType == UnmanagedType.SafeArray)
{
if (blob.Length != 0)
{
safeArraySubType = (VarEnum)blob.ReadCompressedInt();
if (blob.Length != 0)
{
safeArrayUserDefinedSubType = ReadType(module, blob);
}
}
}
else if (unmanagedType == UnmanagedType.ByValArray)
{
sizeConst = blob.ReadCompressedInt();
if (blob.Length != 0)
{
arraySubType = (UnmanagedType)blob.ReadCompressedInt();
}
}
else if (unmanagedType == UnmanagedType.ByValTStr)
{
sizeConst = blob.ReadCompressedInt();
}
else if (unmanagedType == UnmanagedType.Interface
|| unmanagedType == UnmanagedType.IDispatch
|| unmanagedType == UnmanagedType.IUnknown)
{
if (blob.Length != 0)
{
iidParameterIndex = blob.ReadCompressedInt();
}
}
else if (unmanagedType == UnmanagedType.CustomMarshaler)
{
blob.ReadCompressedInt();
blob.ReadCompressedInt();
marshalType = ReadString(blob);
marshalCookie = ReadString(blob);
marshalTypeRef = module.Assembly.GetType(marshalType) ?? module.universe.GetType(marshalType);
}
Type typeofMarshalAs = module.universe.System_Runtime_InteropServices_MarshalAsAttribute;
Type typeofUnmanagedType = module.universe.System_Runtime_InteropServices_UnmanagedType;
Type typeofVarEnum = module.universe.System_Runtime_InteropServices_VarEnum;
Type typeofType = module.universe.System_Type;
List<CustomAttributeNamedArgument> named = new List<CustomAttributeNamedArgument>();
if (arraySubType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("ArraySubType"), new CustomAttributeTypedArgument(typeofUnmanagedType, arraySubType.Value)));
}
if (sizeParamIndex != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeParamIndex"), new CustomAttributeTypedArgument(module.universe.System_Int16, sizeParamIndex.Value)));
}
if (sizeConst != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeConst"), new CustomAttributeTypedArgument(module.universe.System_Int32, sizeConst.Value)));
}
if (safeArraySubType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArraySubType"), new CustomAttributeTypedArgument(typeofVarEnum, safeArraySubType.Value)));
}
if (safeArrayUserDefinedSubType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArrayUserDefinedSubType"), new CustomAttributeTypedArgument(typeofType, safeArrayUserDefinedSubType)));
}
if (iidParameterIndex != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("IidParameterIndex"), new CustomAttributeTypedArgument(module.universe.System_Int32, iidParameterIndex.Value)));
}
if (marshalType != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalType"), new CustomAttributeTypedArgument(module.universe.System_String, marshalType)));
}
if (marshalTypeRef != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalTypeRef"), new CustomAttributeTypedArgument(module.universe.System_Type, marshalTypeRef)));
}
if (marshalCookie != null)
{
named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalCookie"), new CustomAttributeTypedArgument(module.universe.System_String, marshalCookie)));
}
ConstructorInfo constructor = typeofMarshalAs.GetConstructor(new Type[] { typeofUnmanagedType });
return new CustomAttributeData(constructor, new object[] { unmanagedType }, named);
}
}
throw new BadImageFormatException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="165" endline="173">
internal static void SetMarshalAsAttribute(ModuleBuilder module, int token, CustomAttributeBuilder attribute)
{
attribute = attribute.DecodeBlob(module.Assembly);
FieldMarshalTable.Record rec = new FieldMarshalTable.Record();
rec.Parent = token;
rec.NativeType = WriteMarshallingDescriptor(module, attribute);
module.FieldMarshal.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="174" endline="270">
private static int WriteMarshallingDescriptor(ModuleBuilder module, CustomAttributeBuilder attribute)
{
UnmanagedType unmanagedType;
object val = attribute.GetConstructorArgument(0);
if (val is short)
{
unmanagedType = (UnmanagedType)(short)val;
}
else if (val is int)
{
unmanagedType = (UnmanagedType)(int)val;
}
else
{
unmanagedType = (UnmanagedType)val;
}
ByteBuffer bb = new ByteBuffer(5);
bb.WriteCompressedInt((int)unmanagedType);
if (unmanagedType == UnmanagedType.LPArray)
{
UnmanagedType arraySubType = attribute.GetFieldValue<UnmanagedType>("ArraySubType") ?? NATIVE_TYPE_MAX;
bb.WriteCompressedInt((int)arraySubType);
int? sizeParamIndex = attribute.GetFieldValue<short>("SizeParamIndex");
int? sizeConst = attribute.GetFieldValue<int>("SizeConst");
if (sizeParamIndex != null)
{
bb.WriteCompressedInt(sizeParamIndex.Value);
if (sizeConst != null)
{
bb.WriteCompressedInt(sizeConst.Value);
bb.WriteCompressedInt(1); // flag that says that SizeParamIndex was specified
}
}
else if (sizeConst != null)
{
bb.WriteCompressedInt(0); // SizeParamIndex
bb.WriteCompressedInt(sizeConst.Value);
bb.WriteCompressedInt(0); // flag that says that SizeParamIndex was not specified
}
}
else if (unmanagedType == UnmanagedType.SafeArray)
{
VarEnum? safeArraySubType = attribute.GetFieldValue<VarEnum>("SafeArraySubType");
if (safeArraySubType != null)
{
bb.WriteCompressedInt((int)safeArraySubType);
Type safeArrayUserDefinedSubType = (Type)attribute.GetFieldValue("SafeArrayUserDefinedSubType");
if (safeArrayUserDefinedSubType != null)
{
WriteType(module, bb, safeArrayUserDefinedSubType);
}
}
}
else if (unmanagedType == UnmanagedType.ByValArray)
{
bb.WriteCompressedInt(attribute.GetFieldValue<int>("SizeConst") ?? 1);
UnmanagedType? arraySubType = attribute.GetFieldValue<UnmanagedType>("ArraySubType");
if (arraySubType != null)
{
bb.WriteCompressedInt((int)arraySubType);
}
}
else if (unmanagedType == UnmanagedType.ByValTStr)
{
bb.WriteCompressedInt(attribute.GetFieldValue<int>("SizeConst").Value);
}
else if (unmanagedType == UnmanagedType.Interface
|| unmanagedType == UnmanagedType.IDispatch
|| unmanagedType == UnmanagedType.IUnknown)
{
int? iidParameterIndex = attribute.GetFieldValue<int>("IidParameterIndex");
if (iidParameterIndex != null)
{
bb.WriteCompressedInt(iidParameterIndex.Value);
}
}
else if (unmanagedType == UnmanagedType.CustomMarshaler)
{
bb.WriteCompressedInt(0);
bb.WriteCompressedInt(0);
string marshalType = (string)attribute.GetFieldValue("MarshalType");
if (marshalType != null)
{
WriteString(bb, marshalType);
}
else
{
WriteType(module, bb, (Type)attribute.GetFieldValue("MarshalTypeRef"));
}
WriteString(bb, (string)attribute.GetFieldValue("MarshalCookie") ?? "");
}
return module.Blobs.Add(bb);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="271" endline="280">
private static Type ReadType(Module module, ByteReader br)
{
string str = ReadString(br);
if (str == "")
{
return null;
}
return module.Assembly.GetType(str) ?? module.universe.GetType(str, true);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="291" endline="297">
private static void WriteString(ByteBuffer bb, string str)
{
byte[] buf = Encoding.UTF8.GetBytes(str);
bb.WriteCompressedInt(buf.Length);
bb.Write(buf);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\LocalVariableInfo.cs" startline="34" endline="39">
internal LocalVariableInfo(int index, Type type, bool pinned)
{
this.index = index;
this.type = type;
this.pinned = pinned;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="45" endline="56">
{
if (UseNativeFusion)
{
bool equivalent;
Marshal.ThrowExceptionForHR(CompareAssemblyIdentity(assemblyIdentity1, unified1, assemblyIdentity2, unified2, out equivalent, out result));
return equivalent;
}
else
{
return CompareAssemblyIdentityPure(assemblyIdentity1, unified1, assemblyIdentity2, unified2, out result);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="57" endline="161">
[DllImport("fusion", CharSet = CharSet.Unicode)]
private static extern int CompareAssemblyIdentity(string pwzAssemblyIdentity1, bool fUnified1, string pwzAssemblyIdentity2, bool fUnified2, out bool pfEquivalent, out AssemblyComparisonResult pResult);
internal static bool CompareAssemblyIdentityPure(string assemblyIdentity1, bool unified1, string assemblyIdentity2, bool unified2, out AssemblyComparisonResult result)
{
ParsedAssemblyName name1;
ParsedAssemblyName name2;
if (!ParseAssemblyName(assemblyIdentity1, out name1)
|| !ParseAssemblyName(assemblyIdentity2, out name2))
{
result = AssemblyComparisonResult.NonEquivalent;
throw new ArgumentException();
}
bool partial = IsPartial(name1);
if ((partial && unified1) || IsPartial(name2))
{
result = AssemblyComparisonResult.NonEquivalent;
throw new ArgumentException();
}
if (!name1.Name.Equals(name2.Name, StringComparison.InvariantCultureIgnoreCase))
{
result = AssemblyComparisonResult.NonEquivalent;
return false;
}
if (name1.Name.Equals("mscorlib", StringComparison.InvariantCultureIgnoreCase))
{
result = AssemblyComparisonResult.EquivalentFullMatch;
return true;
}
if (partial && name1.Culture == null)
{
}
else if (!name1.Culture.Equals(name2.Culture, StringComparison.InvariantCultureIgnoreCase))
{
result = AssemblyComparisonResult.NonEquivalent;
return false;
}
if (IsStrongNamed(name2))
{
if (partial && name1.PublicKeyToken == null)
{
}
else if (name1.PublicKeyToken != name2.PublicKeyToken)
{
result = AssemblyComparisonResult.NonEquivalent;
return false;
}
if (partial && name1.Version == null)
{
result = AssemblyComparisonResult.EquivalentPartialMatch;
return true;
}
else if (IsFrameworkAssembly(name2))
{
result = partial ? AssemblyComparisonResult.EquivalentPartialFXUnified
return true;
}
else if (name1.Version < name2.Version)
{
if (unified2)
{
result = partial ? AssemblyComparisonResult.EquivalentPartialUnified
return true;
}
else
{
result = partial ? AssemblyComparisonResult.NonEquivalentPartialVersion
return false;
}
}
else if (name1.Version > name2.Version)
{
if (unified1)
{
result = partial ? AssemblyComparisonResult.EquivalentPartialUnified
return true;
}
else
{
result = partial ? AssemblyComparisonResult.NonEquivalentPartialVersion
return false;
}
}
else
{
result = partial ? AssemblyComparisonResult.EquivalentPartialMatch
return true;
}
}
else if (IsStrongNamed(name1))
{
result = AssemblyComparisonResult.NonEquivalent;
return false;
}
else
{
result = partial ? AssemblyComparisonResult.EquivalentPartialWeakNamed
return true;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="162" endline="217">
static bool IsFrameworkAssembly(ParsedAssemblyName name)
{
switch (name.Name)
{
case "System"
case "System.Core"
case "System.Data"
case "System.Data.DataSetExtensions"
case "System.Data.Linq"
case "System.Data.OracleClient"
case "System.Data.Services"
case "System.Data.Services.Client"
case "System.IdentityModel"
case "System.IdentityModel.Selectors"
case "System.Runtime.Remoting"
case "System.Runtime.Serialization"
case "System.ServiceModel"
case "System.Transactions"
case "System.Windows.Forms"
case "System.Xml"
case "System.Xml.Linq"
return name.PublicKeyToken == "b77a5c561934e089";
case "System.Configuration"
case "System.Configuration.Install"
case "System.Design"
case "System.DirectoryServices"
case "System.Drawing"
case "System.Drawing.Design"
case "System.EnterpriseServices"
case "System.Management"
case "System.Messaging"
case "System.Runtime.Serialization.Formatters.Soap"
case "System.Security"
case "System.ServiceProcess"
case "System.Web"
case "System.Web.Mobile"
case "System.Web.Services"
return name.PublicKeyToken == "b03f5f7f11d50a3a";
case "System.ComponentModel.DataAnnotations"
case "System.ServiceModel.Web"
case "System.Web.Abstractions"
case "System.Web.Extensions"
case "System.Web.Extensions.Design"
case "System.Web.DynamicData"
case "System.Web.Routing"
return name.PublicKeyToken == "31bf3856ad364e35";
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="218" endline="299">
private static bool ParseAssemblyName(string fullName, out ParsedAssemblyName parsedName)
{
parsedName = new ParsedAssemblyName();
StringBuilder sb = new StringBuilder();
int pos = 0;
while (pos < fullName.Length)
{
char ch = fullName[pos++];
if (ch == '\\')
{
if (pos == fullName.Length)
{
return false;
}
ch = fullName[pos++];
}
else if (ch == ',')
{
break;
}
sb.Append(ch);
}
while (pos < fullName.Length)
{
char ch = fullName[pos++];
if (ch == '\\')
{
if (pos == fullName.Length)
{
return false;
}
ch = fullName[pos++];
}
else if (ch == ',')
{
break;
}
sb.Append(ch);
}
parsedName.Name = sb.ToString().Trim();
if (pos < fullName.Length)
{
string[] parts = fullName.Substring(pos).Split(',');
for (int i = 0; i < parts.Length; i++)
{
string[] kv = parts[i].Split('=');
if (kv.Length != 2)
{
return false;
}
switch (kv[0].Trim().ToLowerInvariant())
{
case "version"
if (parsedName.Version != null)
{
return false;
}
if (!ParseVersion(kv[1].Trim(), out parsedName.Version))
{
return false;
}
break;
case "culture"
if (parsedName.Culture != null)
{
return false;
}
if (!ParseCulture(kv[1].Trim(), out parsedName.Culture))
{
return false;
}
break;
case "publickeytoken"
if (parsedName.PublicKeyToken != null)
{
return false;
}
if (!ParsePublicKeyToken(kv[1].Trim(), out parsedName.PublicKeyToken))
{
return false;
}
break;
case "publickey"
if (parsedName.PublicKeyToken != null)
{
return false;
}
if (!ParsePublicKey(kv[1].Trim(), out parsedName.PublicKeyToken))
{
return false;
}
break;
}
}
for (int i = 0; i < parts.Length; i++)
{
string[] kv = parts[i].Split('=');
if (kv.Length != 2)
{
return false;
}
switch (kv[0].Trim().ToLowerInvariant())
{
case "version"
if (parsedName.Version != null)
{
return false;
}
if (!ParseVersion(kv[1].Trim(), out parsedName.Version))
{
return false;
}
break;
case "culture"
if (parsedName.Culture != null)
{
return false;
}
if (!ParseCulture(kv[1].Trim(), out parsedName.Culture))
{
return false;
}
break;
case "publickeytoken"
if (parsedName.PublicKeyToken != null)
{
return false;
}
if (!ParsePublicKeyToken(kv[1].Trim(), out parsedName.PublicKeyToken))
{
return false;
}
break;
case "publickey"
if (parsedName.PublicKeyToken != null)
{
return false;
}
if (!ParsePublicKey(kv[1].Trim(), out parsedName.PublicKeyToken))
{
return false;
}
break;
}
}
}
return true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="300" endline="318">
private static bool ParseVersion(string str, out Version version)
{
string[] parts = str.Split('.');
if (parts.Length == 4)
{
ushort major, minor, build, revision;
if (ushort.TryParse(parts[0], System.Globalization.NumberStyles.Integer, null, out major)
&& ushort.TryParse(parts[1], System.Globalization.NumberStyles.Integer, null, out minor)
&& ushort.TryParse(parts[2], System.Globalization.NumberStyles.Integer, null, out build)
&& ushort.TryParse(parts[3], System.Globalization.NumberStyles.Integer, null, out revision))
{
version = new Version(major, minor, build, revision);
return true;
}
}
version = null;
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="319" endline="329">
private static bool ParseCulture(string str, out string culture)
{
if (str == null)
{
culture = null;
return false;
}
culture = str;
return true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="330" endline="340">
private static bool ParsePublicKeyToken(string str, out string publicKeyToken)
{
if (str == null)
{
publicKeyToken = null;
return false;
}
publicKeyToken = str.ToLowerInvariant();
return true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="341" endline="358">
private static bool ParsePublicKey(string str, out string publicKeyToken)
{
if (str == null)
{
publicKeyToken = null;
return false;
}
byte[] token = new AssemblyName("Foo, PublicKey=" + str).GetPublicKeyToken();
StringBuilder sb = new StringBuilder(token.Length * 2);
for (int i = 0; i < token.Length; i++)
{
sb.AppendFormat("{0
}
for (int i = 0; i < token.Length; i++)
{
sb.AppendFormat("{0
}
publicKeyToken = sb.ToString();
return true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
private static bool IsEqual(byte[] b1, byte[] b2)
{
if (b1.Length != b2.Length)
{
return false;
}
for (int i = 0; i < b1.Length; i++)
{
if (b1[i] != b2[i])
{
return false;
}
}
for (int i = 0; i < b1.Length; i++)
{
if (b1[i] != b2[i])
{
return false;
}
}
return true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" startline="53" endline="70">
{
Cb = br.ReadUInt32();
MajorRuntimeVersion = br.ReadUInt16();
MinorRuntimeVersion = br.ReadUInt16();
MetaDataRVA = br.ReadUInt32();
MetaDataSize = br.ReadUInt32();
Flags = br.ReadUInt32();
EntryPointToken = br.ReadUInt32();
ResourcesRVA = br.ReadUInt32();
ResourcesSize = br.ReadUInt32();
StrongNameSignatureRVA = br.ReadUInt32();
StrongNameSignatureSize = br.ReadUInt32();
CodeManagerTable = br.ReadUInt32();
VTableFixupsRVA = br.ReadUInt32();
VTableFixupsSize = br.ReadUInt32();
ExportAddressTableJumps = br.ReadUInt32();
ManagedNativeHeader = br.ReadUInt32();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" startline="71" endline="90">
internal void Write(IKVM.Reflection.Writer.MetadataWriter mw)
{
mw.Write(Cb);
mw.Write(MajorRuntimeVersion);
mw.Write(MinorRuntimeVersion);
mw.Write(MetaDataRVA);
mw.Write(MetaDataSize);
mw.Write(Flags);
mw.Write(EntryPointToken);
mw.Write(ResourcesRVA);
mw.Write(ResourcesSize);
mw.Write(StrongNameSignatureRVA);
mw.Write(StrongNameSignatureSize);
mw.Write(CodeManagerTable);
mw.Write(VTableFixupsRVA);
mw.Write(VTableFixupsSize);
mw.Write(ExportAddressTableJumps);
mw.Write(ManagedNativeHeader);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCode.cs" startline="38" endline="60">
private static readonly StackBehaviour[] pop = {
StackBehaviour.Pop0,
StackBehaviour.Pop1,
StackBehaviour.Pop1_pop1,
StackBehaviour.Popi,
StackBehaviour.Popi_pop1,
StackBehaviour.Popi_popi,
StackBehaviour.Popi_popi8,
StackBehaviour.Popi_popi_popi,
StackBehaviour.Popi_popr4,
StackBehaviour.Popi_popr8,
StackBehaviour.Popref,
StackBehaviour.Popref_pop1,
StackBehaviour.Popref_popi,
StackBehaviour.Popref_popi_popi,
StackBehaviour.Popref_popi_popi8,
StackBehaviour.Popref_popi_popr4,
StackBehaviour.Popref_popi_popr8,
StackBehaviour.Popref_popi_popref,
StackBehaviour.Varpop,
StackBehaviour.Popref_popi_pop1
};
private static readonly StackBehaviour[] push = {
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="37" endline="58">
public abstract Type[] GetTypes();
public abstract string FullName { get; }
public abstract AssemblyName GetName();
public abstract string ImageRuntimeVersion { get; }
public abstract Module ManifestModule { get; }
public abstract MethodInfo EntryPoint { get; }
public abstract string Location { get; }
public abstract AssemblyName[] GetReferencedAssemblies();
public abstract Module[] GetModules(bool getResourceModules);
public abstract Module[] GetLoadedModules(bool getResourceModules);
public abstract Module GetModule(string name);
public abstract string[] GetManifestResourceNames();
public abstract ManifestResourceInfo GetManifestResourceInfo(string resourceName);
public abstract System.IO.Stream GetManifestResourceStream(string resourceName);
internal abstract Type GetTypeImpl(string typeName);
public Module[] GetModules()
{
return GetModules(true);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
}
public Type[] GetExportedTypes()
{
List<Type> list = new List<Type>();
foreach (Type type in GetTypes())
{
if (type.IsVisible)
{
list.Add(type);
}
}
foreach (Type type in GetTypes())
{
if (type.IsVisible)
{
list.Add(type);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="92" endline="112">
public Type GetType(string typeName, bool throwOnError)
{
TypeNameParser parser = TypeNameParser.Parse(typeName, throwOnError);
if (parser.Error)
{
return null;
}
if (parser.AssemblyName != null)
{
if (throwOnError)
{
throw new ArgumentException("Type names passed to Assembly.GetType() must not specify an assembly.");
}
else
{
return null;
}
}
return parser.Expand(GetTypeImpl(parser.FirstNamePart), this, throwOnError, typeName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="143" endline="154">
public string CodeBase
{
get
{
string path = this.Location.Replace(System.IO.Path.DirectorySeparatorChar, '/');
if (!path.StartsWith("/"))
{
path = "/" + path;
}
return "file
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Impl\CryptoHack.cs" startline="35" endline="54">
{
SerializationInfo ser = new SerializationInfo(typeof(StrongNameKeyPair), new FormatterConverter());
((ISerializable)keyPair.keyPair).GetObjectData(ser, new StreamingContext());
byte[] key = (byte[])ser.GetValue("_keyPairArray", typeof(byte[]));
string keycontainer = ser.GetString("_keyPairContainer");
if (keycontainer != null)
{
CspParameters parm = new CspParameters();
parm.Flags = CspProviderFlags.UseMachineKeyStore;
parm.KeyContainerName = keycontainer;
parm.KeyNumber = 2;	// Signature
return new RSACryptoServiceProvider(parm);
}
else
{
return Mono.Security.Cryptography.CryptoConvert.FromCapiKeyBlob(key);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="42" endline="48">
internal TextSection(PEWriter peWriter, CliHeader cliHeader, ModuleBuilder moduleBuilder, int strongNameSignatureLength)
{
this.peWriter = peWriter;
this.cliHeader = cliHeader;
this.moduleBuilder = moduleBuilder;
this.strongNameSignatureLength = (uint)strongNameSignatureLength;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="63" endline="77">
}
internal uint ImportAddressTableLength
{
get
{
if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
{
return 8;
}
else
{
return 16;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="98" endline="112">
}
private uint ResourcesRVA
{
get
{
if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
{
return (MethodBodiesRVA + MethodBodiesLength + 3) & ~3U;
}
else
{
return (MethodBodiesRVA + MethodBodiesLength + 15) & ~15U;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="118" endline="125">
}
internal uint StrongNameSignatureRVA
{
get
{
return (ResourcesRVA + ResourcesLength + 3) & ~3U;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="126" endline="133">
}
internal uint StrongNameSignatureLength
{
get
{
return strongNameSignatureLength;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="134" endline="141">
}
private uint MetadataRVA
{
get
{
return (StrongNameSignatureRVA + StrongNameSignatureLength + 3) & ~3U;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="152" endline="163">
}
internal uint DebugDirectoryLength
{
get
{
if (DebugDirectoryContentsLength != 0)
{
return 28;
}
return 0;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="164" endline="176">
}
private uint DebugDirectoryContentsLength
{
get
{
if (moduleBuilder.symbolWriter != null)
{
IMAGE_DEBUG_DIRECTORY idd = new IMAGE_DEBUG_DIRECTORY();
return (uint)SymbolSupport.GetDebugInfo(moduleBuilder.symbolWriter, ref idd).Length;
}
return 0;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="188" endline="202">
}
private uint ImportHintNameTableRVA
{
get
{
if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
{
return (ImportDirectoryRVA + 48 + 15) & ~15U;
}
else
{
return (ImportDirectoryRVA + 48 + 4 + 15) & ~15U;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="203" endline="219">
}
internal uint StartupStubRVA
{
get
{
if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
{
return (ImportDirectoryRVA + ImportDirectoryLength + 15U) & ~15U;
}
else
{
return 2 + ((ImportDirectoryRVA + ImportDirectoryLength + 3U) & ~3U);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="220" endline="238">
}
internal uint StartupStubLength
{
get
{
if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64)
{
return 12;
}
else if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
{
return 48;
}
else
{
return 6;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="239" endline="251">
}
private void WriteRVA(MetadataWriter mw, uint rva)
{
if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
{
mw.Write(rva);
}
else
{
mw.Write((ulong)rva);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="252" endline="370">
internal void Write(MetadataWriter mw, int sdataRVA)
{
moduleBuilder.MethodDef.Fixup(this);
moduleBuilder.MethodImpl.Fixup(moduleBuilder);
moduleBuilder.MethodSemantics.Fixup(moduleBuilder);
moduleBuilder.InterfaceImpl.Fixup();
moduleBuilder.MemberRef.Fixup(moduleBuilder);
moduleBuilder.Constant.Fixup(moduleBuilder);
moduleBuilder.FieldMarshal.Fixup(moduleBuilder);
moduleBuilder.DeclSecurity.Fixup(moduleBuilder);
moduleBuilder.GenericParam.Fixup(moduleBuilder);
moduleBuilder.CustomAttribute.Fixup(moduleBuilder);
moduleBuilder.FieldLayout.Fixup(moduleBuilder);
moduleBuilder.FieldRVA.Fixup(moduleBuilder, sdataRVA);
moduleBuilder.ImplMap.Fixup(moduleBuilder);
moduleBuilder.MethodSpec.Fixup(moduleBuilder);
moduleBuilder.GenericParamConstraint.Fixup(moduleBuilder);
AssertRVA(mw, ImportAddressTableRVA);
WriteRVA(mw, ImportHintNameTableRVA);
WriteRVA(mw, 0);
AssertRVA(mw, ComDescriptorRVA);
cliHeader.MetaDataRVA = MetadataRVA;
cliHeader.MetaDataSize = MetadataLength;
if (ResourcesLength != 0)
{
cliHeader.ResourcesRVA = ResourcesRVA;
cliHeader.ResourcesSize = ResourcesLength;
}
if (StrongNameSignatureLength != 0)
{
cliHeader.StrongNameSignatureRVA = StrongNameSignatureRVA;
cliHeader.StrongNameSignatureSize = StrongNameSignatureLength;
}
cliHeader.Write(mw);
for (int i = (int)(MethodBodiesRVA - (ComDescriptorRVA + ComDescriptorLength)); i > 0; i--)
{
mw.Write((byte)0);
}
for (int i = (int)(MethodBodiesRVA - (ComDescriptorRVA + ComDescriptorLength)); i > 0; i--)
{
mw.Write((byte)0);
}
mw.Write(moduleBuilder.methodBodies);
for (int i = (int)(ResourcesRVA - (MethodBodiesRVA + MethodBodiesLength)); i > 0; i--)
{
mw.Write((byte)0);
}
for (int i = (int)(ResourcesRVA - (MethodBodiesRVA + MethodBodiesLength)); i > 0; i--)
{
mw.Write((byte)0);
}
mw.Write(moduleBuilder.manifestResources);
for (int i = (int)(MetadataRVA - (ResourcesRVA + ResourcesLength)); i > 0; i--)
{
mw.Write((byte)0);
}
for (int i = (int)(MetadataRVA - (ResourcesRVA + ResourcesLength)); i > 0; i--)
{
mw.Write((byte)0);
}
AssertRVA(mw, MetadataRVA);
moduleBuilder.WriteMetadata(mw);
AssertRVA(mw, DebugDirectoryRVA);
WriteDebugDirectory(mw);
for (int i = (int)(ImportDirectoryRVA - (DebugDirectoryRVA + DebugDirectoryLength + DebugDirectoryContentsLength)); i > 0; i--)
{
mw.Write((byte)0);
}
for (int i = (int)(ImportDirectoryRVA - (DebugDirectoryRVA + DebugDirectoryLength + DebugDirectoryContentsLength)); i > 0; i--)
{
mw.Write((byte)0);
}
AssertRVA(mw, ImportDirectoryRVA);
WriteImportDirectory(mw);
for (int i = (int)(StartupStubRVA - (ImportDirectoryRVA + ImportDirectoryLength)); i > 0; i--)
{
mw.Write((byte)0);
}
for (int i = (int)(StartupStubRVA - (ImportDirectoryRVA + ImportDirectoryLength)); i > 0; i--)
{
mw.Write((byte)0);
}
AssertRVA(mw, StartupStubRVA);
if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64)
{
/*
*   48 A1 00 20 40 00 00 00 00 00        mov         rax,qword ptr [0000000000402000h]
*   FF E0                                jmp         rax
*/
mw.Write((ushort)0xA148);
mw.Write(peWriter.Headers.OptionalHeader.ImageBase + ImportAddressTableRVA);
mw.Write((ushort)0xE0FF);
}
else if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
{
mw.Write(new byte[] {
0x0B, 0x48, 0x00, 0x02, 0x18, 0x10, 0xA0, 0x40, 0x24, 0x30, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00,
0x10, 0x08, 0x00, 0x12, 0x18, 0x10, 0x60, 0x50, 0x04, 0x80, 0x03, 0x00, 0x60, 0x00, 0x80, 0x00
});
mw.Write(peWriter.Headers.OptionalHeader.ImageBase + StartupStubRVA);
mw.Write(peWriter.Headers.OptionalHeader.ImageBase + BaseRVA);
}
else
{
mw.Write((ushort)0x25FF);
mw.Write((uint)peWriter.Headers.OptionalHeader.ImageBase + ImportAddressTableRVA);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="377" endline="397">
private void WriteDebugDirectory(MetadataWriter mw)
{
if (DebugDirectoryLength != 0)
{
IMAGE_DEBUG_DIRECTORY idd = new IMAGE_DEBUG_DIRECTORY();
idd.Characteristics = 0;
idd.TimeDateStamp = peWriter.Headers.FileHeader.TimeDateStamp;
byte[] buf = SymbolSupport.GetDebugInfo(moduleBuilder.symbolWriter, ref idd);
idd.PointerToRawData = (DebugDirectoryRVA - BaseRVA) + DebugDirectoryLength + PointerToRawData;
mw.Write(idd.Characteristics);
mw.Write(idd.TimeDateStamp);
mw.Write(idd.MajorVersion);
mw.Write(idd.MinorVersion);
mw.Write(idd.Type);
mw.Write(idd.SizeOfData);
mw.Write(idd.AddressOfRawData);
mw.Write(idd.PointerToRawData);
mw.Write(buf);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="398" endline="438">
private void WriteImportDirectory(MetadataWriter mw)
{
mw.Write(ImportDirectoryRVA + 40);		// ImportLookupTable
mw.Write(0);							// DateTimeStamp
mw.Write(0);							// ForwarderChain
mw.Write(ImportHintNameTableRVA + 14);	// Name
mw.Write(ImportAddressTableRVA);
mw.Write(new byte[20]);
mw.Write(ImportHintNameTableRVA);		// Hint/Name Table RVA
int size = 48;
if (peWriter.Headers.FileHeader.Machine != IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
{
size += 4;
mw.Write(0);
}
mw.Write(0);
for (int i = (int)(ImportHintNameTableRVA - (ImportDirectoryRVA + size)); i > 0; i--)
{
mw.Write((byte)0);
}
for (int i = (int)(ImportHintNameTableRVA - (ImportDirectoryRVA + size)); i > 0; i--)
{
mw.Write((byte)0);
}
AssertRVA(mw, ImportHintNameTableRVA);
mw.Write((ushort)0);		// Hint
if ((peWriter.Headers.FileHeader.Characteristics & IMAGE_FILE_HEADER.IMAGE_FILE_DLL) != 0)
{
mw.Write(System.Text.Encoding.ASCII.GetBytes("_CorDllMain"));
}
else
{
mw.Write(System.Text.Encoding.ASCII.GetBytes("_CorExeMain"));
}
mw.Write((byte)0);
mw.Write(System.Text.Encoding.ASCII.GetBytes("mscoree.dll"));
mw.Write((ushort)0);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="41" endline="46">
internal MethodDefImpl(ModuleReader module, TypeDefImpl declaringType, int index)
{
this.module = module;
this.index = index;
this.declaringType = declaringType;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="52" endline="62">
internal MethodBody GetMethodBody(IGenericContext context)
{
if ((GetMethodImplementationFlags() & MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.IL)
{
return null;
}
int rva = module.MethodDef.records[index].RVA;
return rva == 0 ? null
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="84" endline="117">
private void PopulateParameters()
{
if (parameters == null)
{
MethodSignature methodSignature = this.MethodSignature;
parameters = new ParameterInfo[methodSignature.GetParameterCount()];
int parameter = module.MethodDef.records[index].ParamList - 1;
int end = module.MethodDef.records.Length > index + 1 ? module.MethodDef.records[index + 1].ParamList - 1
for (; parameter < end; parameter++)
{
int seq = module.Param.records[parameter].Sequence - 1;
if (seq == -1)
{
returnParameter = new ParameterInfoImpl(this, seq, parameter);
}
else
{
parameters[seq] = new ParameterInfoImpl(this, seq, parameter);
}
}
for (; parameter < end; parameter++)
{
int seq = module.Param.records[parameter].Sequence - 1;
if (seq == -1)
{
returnParameter = new ParameterInfoImpl(this, seq, parameter);
}
else
{
parameters[seq] = new ParameterInfoImpl(this, seq, parameter);
}
}
for (int i = 0; i < parameters.Length; i++)
{
if (parameters[i] == null)
{
parameters[i] = new ParameterInfoImpl(this, i, -1);
}
}
for (int i = 0; i < parameters.Length; i++)
{
if (parameters[i] == null)
{
parameters[i] = new ParameterInfoImpl(this, i, -1);
}
}
if (returnParameter == null)
{
returnParameter = new ParameterInfoImpl(this, -1, -1);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="122" endline="130">
}
public override ParameterInfo ReturnParameter
{
get
{
PopulateParameters();
return returnParameter;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="131" endline="138">
}
public override Type ReturnType
{
get
{
return this.ReturnParameter.ParameterType;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="154" endline="162">
}
public override bool IsGenericMethodDefinition
{
get
{
PopulateGenericArguments();
return typeArgs.Length > 0;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="168" endline="174">
}
public override Type[] GetGenericArguments()
{
PopulateGenericArguments();
return Util.Copy(typeArgs);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="175" endline="197">
private void PopulateGenericArguments()
{
if (typeArgs == null)
{
int token = this.MetadataToken;
int first = module.GenericParam.FindFirstByOwner(token);
if (first == -1)
{
typeArgs = Type.EmptyTypes;
}
else
{
List<Type> list = new List<Type>();
int len = module.GenericParam.records.Length;
for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
{
list.Add(new GenericTypeParameter(module, i));
}
for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
{
list.Add(new GenericTypeParameter(module, i));
}
typeArgs = list.ToArray();
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="210" endline="218">
public override MethodInfo GetGenericMethodDefinition()
{
if (this.IsGenericMethodDefinition)
{
return this;
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="228" endline="239">
}
internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
{
List<CustomAttributeData> list = module.GetCustomAttributes(this.MetadataToken, attributeType);
if ((this.Attributes & MethodAttributes.PinvokeImpl) != 0
&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_DllImportAttribute)))
{
CreateDllImportPseudoCustomAttribute(list);
}
return list;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="240" endline="332">
private void CreateDllImportPseudoCustomAttribute(List<CustomAttributeData> attribs)
{
int token = this.MetadataToken;
for (int i = 0; i < module.ImplMap.records.Length; i++)
{
if (module.ImplMap.records[i].MemberForwarded == token)
{
const short NoMangle = 0x0001;
const short CharSetMask = 0x0006;
const short CharSetNotSpec = 0x0000;
const short CharSetAnsi = 0x0002;
const short CharSetUnicode = 0x0004;
const short CharSetAuto = 0x0006;
const short SupportsLastError = 0x0040;
const short CallConvMask = 0x0700;
const short CallConvWinapi = 0x0100;
const short CallConvCdecl = 0x0200;
const short CallConvStdcall = 0x0300;
const short CallConvThiscall = 0x0400;
const short CallConvFastcall = 0x0500;
const short BestFitOn = 0x0010;
const short BestFitOff = 0x0020;
const short CharMapErrorOn = 0x1000;
const short CharMapErrorOff = 0x2000;
Type type = module.universe.System_Runtime_InteropServices_DllImportAttribute;
ConstructorInfo constructor = type.GetConstructor(new Type[] { module.universe.System_String });
List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>();
int flags = module.ImplMap.records[i].MappingFlags;
string entryPoint = module.GetString(module.ImplMap.records[i].ImportName);
string dllName = module.GetString(module.ModuleRef.records[(module.ImplMap.records[i].ImportScope & 0xFFFFFF) - 1]);
System.Runtime.InteropServices.CharSet? charSet;
switch (flags & CharSetMask)
{
case CharSetAnsi
charSet = System.Runtime.InteropServices.CharSet.Ansi;
break;
case CharSetUnicode
charSet = System.Runtime.InteropServices.CharSet.Unicode;
break;
case CharSetAuto
charSet = System.Runtime.InteropServices.CharSet.Auto;
break;
case CharSetNotSpec
default
charSet = null;
break;
}
System.Runtime.InteropServices.CallingConvention callingConvention;
switch (flags & CallConvMask)
{
case CallConvCdecl
callingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
break;
case CallConvFastcall
callingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
break;
case CallConvStdcall
callingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
break;
case CallConvThiscall
callingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
break;
case CallConvWinapi
default
callingConvention = System.Runtime.InteropServices.CallingConvention.Winapi;
break;
}
list.Add(MakeNamedArgument(type, "EntryPoint", entryPoint));
list.Add(MakeNamedArgument(type, "ExactSpelling", flags, NoMangle));
list.Add(MakeNamedArgument(type, "SetLastError", flags, SupportsLastError));
list.Add(MakeNamedArgument(type, "PreserveSig", (int)GetMethodImplementationFlags(), (int)MethodImplAttributes.PreserveSig));
list.Add(MakeNamedArgument(type, "CallingConvention", (int)callingConvention));
if (charSet.HasValue)
{
list.Add(MakeNamedArgument(type, "CharSet", (int)charSet.Value));
}
if ((flags & (BestFitOn | BestFitOff)) != 0)
{
list.Add(MakeNamedArgument(type, "BestFitMapping", flags, BestFitOn));
}
if ((flags & (CharMapErrorOn | CharMapErrorOff)) != 0)
{
list.Add(MakeNamedArgument(type, "ThrowOnUnmappableChar", flags, CharMapErrorOn));
}
attribs.Add(new CustomAttributeData(constructor, new object[] { dllName }, list));
return;
}
}
for (int i = 0; i < module.ImplMap.records.Length; i++)
{
if (module.ImplMap.records[i].MemberForwarded == token)
{
const short NoMangle = 0x0001;
const short CharSetMask = 0x0006;
const short CharSetNotSpec = 0x0000;
const short CharSetAnsi = 0x0002;
const short CharSetUnicode = 0x0004;
const short CharSetAuto = 0x0006;
const short SupportsLastError = 0x0040;
const short CallConvMask = 0x0700;
const short CallConvWinapi = 0x0100;
const short CallConvCdecl = 0x0200;
const short CallConvStdcall = 0x0300;
const short CallConvThiscall = 0x0400;
const short CallConvFastcall = 0x0500;
const short BestFitOn = 0x0010;
const short BestFitOff = 0x0020;
const short CharMapErrorOn = 0x1000;
const short CharMapErrorOff = 0x2000;
Type type = module.universe.System_Runtime_InteropServices_DllImportAttribute;
ConstructorInfo constructor = type.GetConstructor(new Type[] { module.universe.System_String });
List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>();
int flags = module.ImplMap.records[i].MappingFlags;
string entryPoint = module.GetString(module.ImplMap.records[i].ImportName);
string dllName = module.GetString(module.ModuleRef.records[(module.ImplMap.records[i].ImportScope & 0xFFFFFF) - 1]);
System.Runtime.InteropServices.CharSet? charSet;
switch (flags & CharSetMask)
{
case CharSetAnsi
charSet = System.Runtime.InteropServices.CharSet.Ansi;
break;
case CharSetUnicode
charSet = System.Runtime.InteropServices.CharSet.Unicode;
break;
case CharSetAuto
charSet = System.Runtime.InteropServices.CharSet.Auto;
break;
case CharSetNotSpec
default
charSet = null;
break;
}
System.Runtime.InteropServices.CallingConvention callingConvention;
switch (flags & CallConvMask)
{
case CallConvCdecl
callingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
break;
case CallConvFastcall
callingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
break;
case CallConvStdcall
callingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
break;
case CallConvThiscall
callingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
break;
case CallConvWinapi
default
callingConvention = System.Runtime.InteropServices.CallingConvention.Winapi;
break;
}
list.Add(MakeNamedArgument(type, "EntryPoint", entryPoint));
list.Add(MakeNamedArgument(type, "ExactSpelling", flags, NoMangle));
list.Add(MakeNamedArgument(type, "SetLastError", flags, SupportsLastError));
list.Add(MakeNamedArgument(type, "PreserveSig", (int)GetMethodImplementationFlags(), (int)MethodImplAttributes.PreserveSig));
list.Add(MakeNamedArgument(type, "CallingConvention", (int)callingConvention));
if (charSet.HasValue)
{
list.Add(MakeNamedArgument(type, "CharSet", (int)charSet.Value));
}
if ((flags & (BestFitOn | BestFitOff)) != 0)
{
list.Add(MakeNamedArgument(type, "BestFitMapping", flags, BestFitOn));
}
if ((flags & (CharMapErrorOn | CharMapErrorOff)) != 0)
{
list.Add(MakeNamedArgument(type, "ThrowOnUnmappableChar", flags, CharMapErrorOn));
}
attribs.Add(new CustomAttributeData(constructor, new object[] { dllName }, list));
return;
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="358" endline="371">
}
sealed class ParameterInfoImpl
{
private readonly MethodDefImpl method;
private readonly int position;
private readonly int index;
internal ParameterInfoImpl(MethodDefImpl method, int position, int index)
{
this.method = method;
this.position = position;
this.index = index;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="391" endline="437">
}
public override object RawDefaultValue
{
get
{
if ((this.Attributes & ParameterAttributes.HasDefault) != 0)
{
return this.Module.Constant.GetRawConstantValue(this.Module, this.MetadataToken);
}
Universe universe = this.Module.universe;
if (this.ParameterType == universe.System_Decimal)
{
Type attr = universe.System_Runtime_CompilerServices_DecimalConstantAttribute;
if (attr != null)
{
foreach (CustomAttributeData cad in GetCustomAttributesData(attr))
{
IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
if (args.Count == 5)
{
if (args[0].ArgumentType == universe.System_Byte
&& args[1].ArgumentType == universe.System_Byte
&& args[2].ArgumentType == universe.System_Int32
&& args[3].ArgumentType == universe.System_Int32
&& args[4].ArgumentType == universe.System_Int32)
{
return new Decimal((int)args[4].Value, (int)args[3].Value, (int)args[2].Value, (byte)args[1].Value != 0, (byte)args[0].Value);
}
else if (args[0].ArgumentType == universe.System_Byte
&& args[1].ArgumentType == universe.System_Byte
&& args[2].ArgumentType == universe.System_UInt32
&& args[3].ArgumentType == universe.System_UInt32
&& args[4].ArgumentType == universe.System_UInt32)
{
return new Decimal(unchecked((int)(uint)args[4].Value), unchecked((int)(uint)args[3].Value), unchecked((int)(uint)args[2].Value), (byte)args[1].Value != 0, (byte)args[0].Value);
}
}
}
foreach (CustomAttributeData cad in GetCustomAttributesData(attr))
{
IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
if (args.Count == 5)
{
if (args[0].ArgumentType == universe.System_Byte
&& args[1].ArgumentType == universe.System_Byte
&& args[2].ArgumentType == universe.System_Int32
&& args[3].ArgumentType == universe.System_Int32
&& args[4].ArgumentType == universe.System_Int32)
{
return new Decimal((int)args[4].Value, (int)args[3].Value, (int)args[2].Value, (byte)args[1].Value != 0, (byte)args[0].Value);
}
else if (args[0].ArgumentType == universe.System_Byte
&& args[1].ArgumentType == universe.System_Byte
&& args[2].ArgumentType == universe.System_UInt32
&& args[3].ArgumentType == universe.System_UInt32
&& args[4].ArgumentType == universe.System_UInt32)
{
return new Decimal(unchecked((int)(uint)args[4].Value), unchecked((int)(uint)args[3].Value), unchecked((int)(uint)args[2].Value), (byte)args[1].Value != 0, (byte)args[0].Value);
}
}
}
}
}
if ((this.Attributes & ParameterAttributes.Optional) != 0)
{
return Missing.Value;
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="449" endline="456">
public override MemberInfo Member
{
get
{
return method.Module.ResolveMethod(method.MetadataToken);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="457" endline="466">
}
public override int MetadataToken
{
get
{
return (ParamTable.Index << 24) + index + 1;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="472" endline="483">
}
internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
{
IList<CustomAttributeData> list = base.GetCustomAttributesData(attributeType);
if ((this.Attributes & ParameterAttributes.HasFieldMarshal) != 0
&& (attributeType == null || attributeType.IsAssignableFrom(this.Module.universe.System_Runtime_InteropServices_MarshalAsAttribute)))
{
list.Add(MarshalSpec.GetMarshalAsAttribute(this.Module, this.MetadataToken));
}
return list;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="39" endline="46">
internal ParameterBuilder(ModuleBuilder moduleBuilder, int sequence, ParameterAttributes attribs, string name)
{
this.moduleBuilder = moduleBuilder;
this.flags = (short)attribs;
this.sequence = (short)sequence;
this.nameIndex = name == null ? 0
this.name = name;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="47" endline="58">
internal int PseudoToken
{
get
{
if (lazyPseudoToken == 0)
{
lazyPseudoToken = moduleBuilder.AllocPseudoToken();
}
return lazyPseudoToken;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="95" endline="120">
public void SetCustomAttribute(CustomAttributeBuilder customAttributeBuilder)
{
Universe u = moduleBuilder.universe;
if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_InAttribute)
{
flags |= (short)ParameterAttributes.In;
}
else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OutAttribute)
{
flags |= (short)ParameterAttributes.Out;
}
else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OptionalAttribute)
{
flags |= (short)ParameterAttributes.Optional;
}
else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
{
MarshalSpec.SetMarshalAsAttribute(moduleBuilder, PseudoToken, customAttributeBuilder);
flags |= (short)ParameterAttributes.HasFieldMarshal;
}
else
{
moduleBuilder.SetCustomAttribute(PseudoToken, customAttributeBuilder);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="127" endline="133">
internal void WriteParamRecord(MetadataWriter mw)
{
mw.Write(flags);
mw.Write(sequence);
mw.WriteStringIndex(nameIndex);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="134" endline="141">
internal void FixupToken(int parameterToken)
{
if (lazyPseudoToken != 0)
{
moduleBuilder.RegisterTokenFixup(lazyPseudoToken, parameterToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="44" endline="50">
internal EventBuilder(TypeBuilder typeBuilder, string name, EventAttributes attributes, Type eventtype)
{
this.typeBuilder = typeBuilder;
this.name = name;
this.attributes = attributes;
this.eventtype = typeBuilder.ModuleBuilder.GetTypeTokenForMemberRef(eventtype);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="66" endline="74">
public void AddOtherMethod(MethodBuilder mdBuilder)
{
if (otherMethods == null)
{
otherMethods = new List<MethodBuilder>();
}
otherMethods.Add(mdBuilder);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="80" endline="96">
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
{
Universe u = typeBuilder.ModuleBuilder.universe;
if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
{
attributes |= EventAttributes.SpecialName;
}
else
{
if (lazyPseudoToken == 0)
{
lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
}
typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="117" endline="132">
public override MethodInfo[] GetOtherMethods(bool nonPublic)
{
List<MethodInfo> list = new List<MethodInfo>();
if (otherMethods != null)
{
foreach (MethodInfo method in otherMethods)
{
if (nonPublic || method.IsPublic)
{
list.Add(method);
}
}
foreach (MethodInfo method in otherMethods)
{
if (nonPublic || method.IsPublic)
{
list.Add(method);
}
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="147" endline="156">
}
public EventToken GetEventToken()
{
if (lazyPseudoToken == 0)
{
lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
}
return new EventToken(lazyPseudoToken);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="161" endline="195">
}
internal void Bake()
{
EventTable.Record rec = new EventTable.Record();
rec.EventFlags = (short)attributes;
rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
rec.EventType = eventtype;
int token = 0x14000000 | typeBuilder.ModuleBuilder.Event.AddRecord(rec);
if (lazyPseudoToken != 0)
{
typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
}
if (addOnMethod != null)
{
AddMethodSemantics(MethodSemanticsTable.AddOn, addOnMethod.MetadataToken, token);
}
if (removeOnMethod != null)
{
AddMethodSemantics(MethodSemanticsTable.RemoveOn, removeOnMethod.MetadataToken, token);
}
if (fireMethod != null)
{
AddMethodSemantics(MethodSemanticsTable.Fire, fireMethod.MetadataToken, token);
}
if (otherMethods != null)
{
foreach (MethodBuilder method in otherMethods)
{
AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
}
foreach (MethodBuilder method in otherMethods)
{
AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="196" endline="204">
private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
{
MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
rec.Semantics = semantics;
rec.Method = methodToken;
rec.Association = propertyToken;
typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="205" endline="225">
internal override bool IsPublic
{
get
{
if ((addOnMethod != null && addOnMethod.IsPublic) || (removeOnMethod != null && removeOnMethod.IsPublic) || (fireMethod != null && fireMethod.IsPublic))
{
return true;
}
if (otherMethods != null)
{
foreach (MethodBuilder method in otherMethods)
{
if (method.IsPublic)
{
return true;
}
}
foreach (MethodBuilder method in otherMethods)
{
if (method.IsPublic)
{
return true;
}
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="226" endline="247">
}
internal override bool IsStatic
{
get
{
if ((addOnMethod != null && addOnMethod.IsStatic) || (removeOnMethod != null && removeOnMethod.IsStatic) || (fireMethod != null && fireMethod.IsStatic))
{
return true;
}
if (otherMethods != null)
{
foreach (MethodBuilder method in otherMethods)
{
if (method.IsStatic)
{
return true;
}
}
foreach (MethodBuilder method in otherMethods)
{
if (method.IsStatic)
{
return true;
}
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="39" endline="45">
internal GenericMethodInstance(Type declaringType, MethodInfo method, Type[] methodArgs)
{
System.Diagnostics.Debug.Assert(!(method is GenericMethodInstance));
this.declaringType = declaringType;
this.method = method;
this.methodArgs = methodArgs;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="46" endline="54">
public override bool Equals(object obj)
{
GenericMethodInstance other = obj as GenericMethodInstance;
return other != null
&& other.method.Equals(method)
&& other.declaringType.Equals(declaringType)
&& Util.ArrayEquals(other.methodArgs, methodArgs);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="69" endline="79">
}
public override ParameterInfo[] GetParameters()
{
ParameterInfo[] parameters = method.GetParameters();
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
}
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
}
return parameters;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="119" endline="129">
}
public override MethodBody GetMethodBody()
{
IKVM.Reflection.Reader.MethodDefImpl md = method as IKVM.Reflection.Reader.MethodDefImpl;
if (md != null)
{
return md.GetMethodBody(this);
}
throw new NotSupportedException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="144" endline="165">
}
public override bool ContainsGenericParameters
{
get
{
if (declaringType.ContainsGenericParameters)
{
return true;
}
if (methodArgs != null)
{
foreach (Type type in methodArgs)
{
if (type.ContainsGenericParameters)
{
return true;
}
}
foreach (Type type in methodArgs)
{
if (type.ContainsGenericParameters)
{
return true;
}
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="166" endline="186">
}
public override MethodInfo GetGenericMethodDefinition()
{
if (this.IsGenericMethod)
{
if (this.IsGenericMethodDefinition)
{
return this;
}
else if (declaringType.IsGenericType && !declaringType.IsGenericTypeDefinition)
{
return new GenericMethodInstance(declaringType, method, null);
}
else
{
return method;
}
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="187" endline="198">
public override Type[] GetGenericArguments()
{
if (methodArgs == null)
{
return method.GetGenericArguments();
}
else
{
return (Type[])methodArgs.Clone();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="199" endline="210">
internal override Type GetGenericMethodArgument(int index)
{
if (methodArgs == null)
{
return method.GetGenericMethodArgument(index);
}
else
{
return methodArgs[index];
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="226" endline="250">
internal override int ImportTo(Emit.ModuleBuilder module)
{
if (methodArgs == null)
{
return module.ImportMethodOrField(declaringType, method.Name, method.MethodSignature);
}
else
{
Writer.ByteBuffer spec = new Writer.ByteBuffer(10);
Signature.WriteMethodSpec(module, spec, methodArgs);
Metadata.MethodSpecTable.Record rec = new Metadata.MethodSpecTable.Record();
Emit.MethodBuilder mb = method as Emit.MethodBuilder;
if (mb != null && mb.ModuleBuilder == module && !declaringType.IsGenericType)
{
rec.Method = mb.MetadataToken;
}
else
{
rec.Method = module.ImportMember(GetGenericMethodDefinition());
}
rec.Instantiation = module.Blobs.Add(spec);
return 0x2B000000 | module.MethodSpec.FindOrAddRecord(rec);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="255" endline="261">
}
internal override MethodBase BindTypeParameters(Type type)
{
System.Diagnostics.Debug.Assert(methodArgs == null);
return new GenericMethodInstance(declaringType.BindTypeParameters(type), method, null);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="33" endline="42">
}
public abstract FieldAttributes Attributes { get; }
public abstract void __GetDataFromRVA(byte[] data, int offset, int length);
public abstract Object GetRawConstantValue();
internal abstract FieldSignature FieldSignature { get; }
public Type FieldType
{
get { return this.FieldSignature.FieldType; }
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
}
internal abstract int ImportTo(Emit.ModuleBuilder module);
internal virtual FieldInfo BindTypeParameters(Type type)
{
return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
}
sealed class GenericParameterInfoImpl
{
private readonly GenericMethodInstance method;
private readonly ParameterInfo parameterInfo;
internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
{
this.method = method;
this.parameterInfo = parameterInfo;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="376" endline="383">
}
public override Type[] GetOptionalCustomModifiers()
{
Type[] modifiers = parameterInfo.GetOptionalCustomModifiers();
Type.InplaceBindTypeParameters(method, modifiers);
return modifiers;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="384" endline="390">
public override Type[] GetRequiredCustomModifiers()
{
Type[] modifiers = parameterInfo.GetRequiredCustomModifiers();
Type.InplaceBindTypeParameters(method, modifiers);
return modifiers;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertyInfo.cs" startline="33" endline="116">
}
public abstract PropertyAttributes Attributes { get; }
public abstract bool CanRead { get; }
public abstract bool CanWrite { get; }
public abstract MethodInfo GetGetMethod(bool nonPublic);
public abstract MethodInfo GetSetMethod(bool nonPublic);
public abstract MethodInfo[] GetAccessors(bool nonPublic);
public abstract object GetRawConstantValue();
internal abstract bool IsPublic { get; }
internal abstract bool IsStatic { get; }
internal abstract PropertySignature PropertySignature { get; }
private sealed class ParameterInfoImpl
{
private readonly PropertyInfo property;
private readonly int parameter;
internal ParameterInfoImpl(PropertyInfo property, int parameter)
{
this.property = property;
this.parameter = parameter;
}
public override string Name
{
get { return null; }
}
public override Type ParameterType
{
get { return property.PropertySignature.GetParameter(parameter); }
}
public override ParameterAttributes Attributes
{
get { return ParameterAttributes.None; }
}
public override int Position
{
get { return parameter; }
}
public override object RawDefaultValue
{
get { throw new InvalidOperationException(); }
}
public override Type[] GetOptionalCustomModifiers()
{
return property.PropertySignature.GetOptionalCustomModifiers(parameter);
}
public override Type[] GetRequiredCustomModifiers()
{
return property.PropertySignature.GetRequiredCustomModifiers(parameter);
}
public override MemberInfo Member
{
get { return property; }
}
public override int MetadataToken
{
get { return 0x08000000; }
}
internal override Module Module
{
get { return property.Module; }
}
}
public ParameterInfo[] GetIndexParameters()
{
ParameterInfo[] parameters = new ParameterInfo[this.PropertySignature.ParameterCount];
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new ParameterInfoImpl(this, i);
}
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new ParameterInfoImpl(this, i);
}
return parameters;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="443" endline="452">
}
private MethodInfo Wrap(MethodInfo method)
{
if (method == null)
{
return null;
}
return new GenericMethodInstance(typeInstance, method, null);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="463" endline="472">
public override MethodInfo[] GetAccessors(bool nonPublic)
{
MethodInfo[] accessors = property.GetAccessors(nonPublic);
for (int i = 0; i < accessors.Length; i++)
{
accessors[i] = Wrap(accessors[i]);
}
for (int i = 0; i < accessors.Length; i++)
{
accessors[i] = Wrap(accessors[i]);
}
return accessors;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="523" endline="534">
}
sealed class GenericEventInfo
{
private readonly Type typeInstance;
private readonly EventInfo eventInfo;
internal GenericEventInfo(Type typeInstance, EventInfo eventInfo)
{
this.typeInstance = typeInstance;
this.eventInfo = eventInfo;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="550" endline="559">
}
private MethodInfo Wrap(MethodInfo method)
{
if (method == null)
{
return null;
}
return new GenericMethodInstance(typeInstance, method, null);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="575" endline="584">
public override MethodInfo[] GetOtherMethods(bool nonPublic)
{
MethodInfo[] others = eventInfo.GetOtherMethods(nonPublic);
for (int i = 0; i < others.Length; i++)
{
others[i] = Wrap(others[i]);
}
for (int i = 0; i < others.Length; i++)
{
others[i] = Wrap(others[i]);
}
return others;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="45" endline="88">
internal void AddIcon(byte[] iconFile)
{
BinaryReader br = new BinaryReader(new MemoryStream(iconFile));
ushort idReserved = br.ReadUInt16();
ushort idType = br.ReadUInt16();
ushort idCount = br.ReadUInt16();
if (idReserved != 0 || idType != 1)
{
throw new ArgumentException("The supplied byte array is not a valid .ico file.");
}
ByteBuffer group = new ByteBuffer(6 + 14 * idCount);
group.Write(idReserved);
group.Write(idType);
group.Write(idCount);
for (int i = 0; i < idCount; i++)
{
byte bWidth = br.ReadByte();
byte bHeight = br.ReadByte();
byte bColorCount = br.ReadByte();
byte bReserved = br.ReadByte();
ushort wPlanes = br.ReadUInt16();
ushort wBitCount = br.ReadUInt16();
uint dwBytesInRes = br.ReadUInt32();
uint dwImageOffset = br.ReadUInt32();
ushort id = (ushort)(2 + i);
group.Write(bWidth);
group.Write(bHeight);
group.Write(bColorCount);
group.Write(bReserved);
group.Write(wPlanes);
group.Write(wBitCount);
group.Write(dwBytesInRes);
group.Write(id);
byte[] icon = new byte[dwBytesInRes];
Buffer.BlockCopy(iconFile, (int)dwImageOffset, icon, 0, icon.Length);
root[new OrdinalOrName(RT_ICON)][new OrdinalOrName(id)][new OrdinalOrName(0)].Data = ByteBuffer.Wrap(icon);
}
for (int i = 0; i < idCount; i++)
{
byte bWidth = br.ReadByte();
byte bHeight = br.ReadByte();
byte bColorCount = br.ReadByte();
byte bReserved = br.ReadByte();
ushort wPlanes = br.ReadUInt16();
ushort wBitCount = br.ReadUInt16();
uint dwBytesInRes = br.ReadUInt32();
uint dwImageOffset = br.ReadUInt32();
ushort id = (ushort)(2 + i);
group.Write(bWidth);
group.Write(bHeight);
group.Write(bColorCount);
group.Write(bReserved);
group.Write(wPlanes);
group.Write(wBitCount);
group.Write(dwBytesInRes);
group.Write(id);
byte[] icon = new byte[dwBytesInRes];
Buffer.BlockCopy(iconFile, (int)dwImageOffset, icon, 0, icon.Length);
root[new OrdinalOrName(RT_ICON)][new OrdinalOrName(id)][new OrdinalOrName(0)].Data = ByteBuffer.Wrap(icon);
}
root[new OrdinalOrName(RT_GROUP_ICON)][new OrdinalOrName(32512)][new OrdinalOrName(0)].Data = group;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="89" endline="102">
internal void ExtractResources(byte[] buf)
{
ByteReader br = new ByteReader(buf, 0, buf.Length);
while (br.Length >= 32)
{
br.Align(4);
RESOURCEHEADER hdr = new RESOURCEHEADER(br);
if (hdr.DataSize != 0)
{
root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
}
}
while (br.Length >= 32)
{
br.Align(4);
RESOURCEHEADER hdr = new RESOURCEHEADER(br);
if (hdr.DataSize != 0)
{
root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="103" endline="114">
internal void Finish()
{
if (bb != null)
{
throw new InvalidOperationException();
}
bb = new ByteBuffer(1024);
linkOffsets = new List<int>();
root.Write(bb, linkOffsets);
root = null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="119" endline="129">
}
internal void Write(MetadataWriter mw, uint rva)
{
foreach (int offset in linkOffsets)
{
bb.Position = offset;
bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
}
foreach (int offset in linkOffsets)
{
bb.Position = offset;
bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
}
mw.Write(bb);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="38" endline="142">
private ByteBuffer bb;
private List<int> linkOffsets;
internal void AddVersionInfo(ByteBuffer versionInfo)
{
root[new OrdinalOrName(RT_VERSION)][new OrdinalOrName(1)][new OrdinalOrName(0)].Data = versionInfo;
}
internal void AddIcon(byte[] iconFile)
{
BinaryReader br = new BinaryReader(new MemoryStream(iconFile));
ushort idReserved = br.ReadUInt16();
ushort idType = br.ReadUInt16();
ushort idCount = br.ReadUInt16();
if (idReserved != 0 || idType != 1)
{
throw new ArgumentException("The supplied byte array is not a valid .ico file.");
}
ByteBuffer group = new ByteBuffer(6 + 14 * idCount);
group.Write(idReserved);
group.Write(idType);
group.Write(idCount);
for (int i = 0; i < idCount; i++)
{
byte bWidth = br.ReadByte();
byte bHeight = br.ReadByte();
byte bColorCount = br.ReadByte();
byte bReserved = br.ReadByte();
ushort wPlanes = br.ReadUInt16();
ushort wBitCount = br.ReadUInt16();
uint dwBytesInRes = br.ReadUInt32();
uint dwImageOffset = br.ReadUInt32();
ushort id = (ushort)(2 + i);
group.Write(bWidth);
group.Write(bHeight);
group.Write(bColorCount);
group.Write(bReserved);
group.Write(wPlanes);
group.Write(wBitCount);
group.Write(dwBytesInRes);
group.Write(id);
byte[] icon = new byte[dwBytesInRes];
Buffer.BlockCopy(iconFile, (int)dwImageOffset, icon, 0, icon.Length);
root[new OrdinalOrName(RT_ICON)][new OrdinalOrName(id)][new OrdinalOrName(0)].Data = ByteBuffer.Wrap(icon);
}
root[new OrdinalOrName(RT_GROUP_ICON)][new OrdinalOrName(32512)][new OrdinalOrName(0)].Data = group;
}
internal void ExtractResources(byte[] buf)
{
ByteReader br = new ByteReader(buf, 0, buf.Length);
while (br.Length >= 32)
{
br.Align(4);
RESOURCEHEADER hdr = new RESOURCEHEADER(br);
if (hdr.DataSize != 0)
{
root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
}
}
}
internal void Finish()
{
if (bb != null)
{
throw new InvalidOperationException();
}
bb = new ByteBuffer(1024);
linkOffsets = new List<int>();
root.Write(bb, linkOffsets);
root = null;
}
internal int Length
{
get { return bb.Length; }
}
internal void Write(MetadataWriter mw, uint rva)
{
foreach (int offset in linkOffsets)
{
bb.Position = offset;
bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
}
mw.Write(bb);
}
}
sealed class ResourceDirectoryEntry
{
internal readonly OrdinalOrName OrdinalOrName;
internal ByteBuffer Data;
private int namedEntries;
private readonly List<ResourceDirectoryEntry> entries = new List<ResourceDirectoryEntry>();
internal ResourceDirectoryEntry(OrdinalOrName id)
{
this.OrdinalOrName = id;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="143" endline="165">
internal ResourceDirectoryEntry this[OrdinalOrName id]
{
get
{
foreach (ResourceDirectoryEntry entry in entries)
{
if (entry.OrdinalOrName.Ordinal == id.Ordinal && entry.OrdinalOrName.Name == id.Name)
{
return entry;
}
}
foreach (ResourceDirectoryEntry entry in entries)
{
if (entry.OrdinalOrName.Ordinal == id.Ordinal && entry.OrdinalOrName.Name == id.Name)
{
return entry;
}
}
ResourceDirectoryEntry newEntry = new ResourceDirectoryEntry(id);
if (id.Name == null)
{
entries.Add(newEntry);
}
else
{
entries.Insert(namedEntries++, newEntry);
}
return newEntry;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="166" endline="185">
}
private int DirectoryLength
{
get
{
if (Data != null)
{
return 16;
}
else
{
int length = 16 + entries.Count * 8;
foreach (ResourceDirectoryEntry entry in entries)
{
length += entry.DirectoryLength;
}
foreach (ResourceDirectoryEntry entry in entries)
{
length += entry.DirectoryLength;
}
return length;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="186" endline="208">
}
internal void Write(ByteBuffer bb, List<int> linkOffsets)
{
if (entries.Count != 0)
{
int stringTableOffset = this.DirectoryLength;
Dictionary<string, int> strings = new Dictionary<string, int>();
ByteBuffer stringTable = new ByteBuffer(16);
int offset = 16 + entries.Count * 8;
for (int pass = 0; pass < 3; pass++)
{
Write(bb, pass, 0, ref offset, strings, ref stringTableOffset, stringTable);
}
for (int pass = 0; pass < 3; pass++)
{
Write(bb, pass, 0, ref offset, strings, ref stringTableOffset, stringTable);
}
stringTable.Align(4);
offset += stringTable.Length;
WriteResourceDataEntries(bb, linkOffsets, ref offset);
bb.Write(stringTable);
WriteData(bb);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="209" endline="228">
private void WriteResourceDataEntries(ByteBuffer bb, List<int> linkOffsets, ref int offset)
{
foreach (ResourceDirectoryEntry entry in entries)
{
if (entry.Data != null)
{
linkOffsets.Add(bb.Position);
bb.Write(offset);
bb.Write(entry.Data.Length);
bb.Write(0);	// code page
bb.Write(0);	// reserved
offset += (entry.Data.Length + 3) & ~3;
}
else
{
entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
}
}
foreach (ResourceDirectoryEntry entry in entries)
{
if (entry.Data != null)
{
linkOffsets.Add(bb.Position);
bb.Write(offset);
bb.Write(entry.Data.Length);
bb.Write(0);	// code page
bb.Write(0);	// reserved
offset += (entry.Data.Length + 3) & ~3;
}
else
{
entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="229" endline="244">
private void WriteData(ByteBuffer bb)
{
foreach (ResourceDirectoryEntry entry in entries)
{
if (entry.Data != null)
{
bb.Write(entry.Data);
bb.Align(4);
}
else
{
entry.WriteData(bb);
}
}
foreach (ResourceDirectoryEntry entry in entries)
{
if (entry.Data != null)
{
bb.Write(entry.Data);
bb.Align(4);
}
else
{
entry.WriteData(bb);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="245" endline="268">
private void Write(ByteBuffer bb, int writeDepth, int currentDepth, ref int offset, Dictionary<string, int> strings, ref int stringTableOffset, ByteBuffer stringTable)
{
if (currentDepth == writeDepth)
{
bb.Write(0);	// Characteristics
bb.Write(0);	// Time/Date Stamp
bb.Write(0);	// Version (Major / Minor)
bb.Write((ushort)namedEntries);
bb.Write((ushort)(entries.Count - namedEntries));
}
foreach (ResourceDirectoryEntry entry in entries)
{
if (currentDepth == writeDepth)
{
entry.WriteEntry(bb, ref offset, strings, ref stringTableOffset, stringTable);
}
else
{
entry.Write(bb, writeDepth, currentDepth + 1, ref offset, strings, ref stringTableOffset, stringTable);
}
}
foreach (ResourceDirectoryEntry entry in entries)
{
if (currentDepth == writeDepth)
{
entry.WriteEntry(bb, ref offset, strings, ref stringTableOffset, stringTable);
}
else
{
entry.Write(bb, writeDepth, currentDepth + 1, ref offset, strings, ref stringTableOffset, stringTable);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="269" endline="282">
private void WriteEntry(ByteBuffer bb, ref int offset, Dictionary<string, int> strings, ref int stringTableOffset, ByteBuffer stringTable)
{
WriteNameOrOrdinal(bb, OrdinalOrName, strings, ref stringTableOffset, stringTable);
if (Data == null)
{
bb.Write(0x80000000U | (uint)offset);
}
else
{
bb.Write(offset);
}
offset += 16 + entries.Count * 8;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="283" endline="306">
private static void WriteNameOrOrdinal(ByteBuffer bb, OrdinalOrName id, Dictionary<string, int> strings, ref int stringTableOffset, ByteBuffer stringTable)
{
if (id.Name == null)
{
bb.Write((int)id.Ordinal);
}
else
{
int stringOffset;
if (!strings.TryGetValue(id.Name, out stringOffset))
{
stringOffset = stringTableOffset;
strings.Add(id.Name, stringOffset);
stringTableOffset += id.Name.Length * 2 + 2;
stringTable.Write((ushort)id.Name.Length);
foreach (char c in id.Name)
{
stringTable.Write((short)c);
}
foreach (char c in id.Name)
{
stringTable.Write((short)c);
}
}
bb.Write(0x80000000U | (uint)stringOffset);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="307" endline="318">
}
struct OrdinalOrName
{
internal readonly ushort Ordinal;
internal readonly string Name;
internal OrdinalOrName(ushort value)
{
Ordinal = value;
Name = null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="325" endline="351">
}
struct RESOURCEHEADER
{
internal int DataSize;
internal int HeaderSize;
internal OrdinalOrName TYPE;
internal OrdinalOrName NAME;
internal int DataVersion;
internal ushort MemoryFlags;
internal ushort LanguageId;
internal int Version;
internal int Characteristics;
internal RESOURCEHEADER(ByteReader br)
{
DataSize = br.ReadInt32();
HeaderSize = br.ReadInt32();
TYPE = ReadOrdinalOrName(br);
NAME = ReadOrdinalOrName(br);
br.Align(4);
DataVersion = br.ReadInt32();
MemoryFlags = br.ReadUInt16();
LanguageId = br.ReadUInt16();
Version = br.ReadInt32();
Characteristics = br.ReadInt32();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="352" endline="370">
private static OrdinalOrName ReadOrdinalOrName(ByteReader br)
{
char c = br.ReadChar();
if (c == 0xFFFF)
{
return new OrdinalOrName(br.ReadUInt16());
}
else
{
StringBuilder sb = new StringBuilder();
while (c != 0)
{
sb.Append(c);
c = br.ReadChar();
}
while (c != 0)
{
sb.Append(c);
c = br.ReadChar();
}
return new OrdinalOrName(sb.ToString());
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="41" endline="48">
private MethodSignature(Type returnType, Type[] parameterTypes, Type[][][] modifiers, CallingConventions callingConvention, int genericParamCount)
{
this.returnType = returnType;
this.parameterTypes = parameterTypes;
this.modifiers = modifiers;
this.callingConvention = callingConvention;
this.genericParamCount = genericParamCount;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="49" endline="59">
public override bool Equals(object obj)
{
MethodSignature other = obj as MethodSignature;
return other != null
&& other.callingConvention == callingConvention
&& other.genericParamCount == genericParamCount
&& other.returnType.Equals(returnType)
&& Util.ArrayEquals(other.parameterTypes, parameterTypes)
&& Util.ArrayEquals(other.modifiers, modifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="60" endline="67">
public override int GetHashCode()
{
return genericParamCount ^ 77 * (int)callingConvention
^ 3 * returnType.GetHashCode()
^ Util.GetHashCode(parameterTypes) * 5
^ Util.GetHashCode(modifiers) * 55;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="68" endline="147">
private sealed class UnboundGenericMethodContext
{
private readonly IGenericContext original;
internal UnboundGenericMethodContext(IGenericContext original)
{
this.original = original;
}
public Type GetGenericTypeArgument(int index)
{
return original.GetGenericTypeArgument(index);
}
public Type GetGenericMethodArgument(int index)
{
return UnboundGenericMethodParameter.Make(index);
}
}
internal static MethodSignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
{
CallingConventions callingConvention;
int genericParamCount;
Type returnType;
Type[] parameterTypes;
byte flags = br.ReadByte();
switch (flags & 7)
{
case DEFAULT
callingConvention = CallingConventions.Standard;
break;
case VARARG
callingConvention = CallingConventions.VarArgs;
break;
default
throw new BadImageFormatException();
}
if ((flags & HASTHIS) != 0)
{
callingConvention |= CallingConventions.HasThis;
}
if ((flags & EXPLICITTHIS) != 0)
{
callingConvention |= CallingConventions.ExplicitThis;
}
genericParamCount = 0;
if ((flags & GENERIC) != 0)
{
genericParamCount = br.ReadCompressedInt();
context = new UnboundGenericMethodContext(context);
}
int paramCount = br.ReadCompressedInt();
Type[][][] modifiers = null;
Type[] optionalCustomModifiers;
Type[] requiredCustomModifiers;
ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
returnType = ReadRetType(module, br, context);
parameterTypes = new Type[paramCount];
PackedCustomModifiers.SetModifiers(ref modifiers, 0, 0, optionalCustomModifiers, paramCount + 1);
PackedCustomModifiers.SetModifiers(ref modifiers, 0, 1, requiredCustomModifiers, paramCount + 1);
for (int i = 0; i < parameterTypes.Length; i++)
{
if ((callingConvention & CallingConventions.VarArgs) != 0 && br.PeekByte() == SENTINEL)
{
Array.Resize(ref parameterTypes, i);
if (modifiers != null)
{
Array.Resize(ref modifiers, i + 1);
}
break;
}
ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 0, optionalCustomModifiers, paramCount + 1);
PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 1, requiredCustomModifiers, paramCount + 1);
parameterTypes[i] = ReadParam(module, br, context);
}
for (int i = 0; i < parameterTypes.Length; i++)
{
if ((callingConvention & CallingConventions.VarArgs) != 0 && br.PeekByte() == SENTINEL)
{
Array.Resize(ref parameterTypes, i);
if (modifiers != null)
{
Array.Resize(ref modifiers, i + 1);
}
break;
}
ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 0, optionalCustomModifiers, paramCount + 1);
PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 1, requiredCustomModifiers, paramCount + 1);
parameterTypes[i] = ReadParam(module, br, context);
}
return new MethodSignature(returnType, parameterTypes, modifiers, callingConvention, genericParamCount);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="148" endline="213">
internal static __StandAloneMethodSig ReadStandAloneMethodSig(ModuleReader module, ByteReader br, IGenericContext context)
{
CallingConventions callingConvention = 0;
System.Runtime.InteropServices.CallingConvention unmanagedCallingConvention = 0;
bool unmanaged;
byte flags = br.ReadByte();
switch (flags & 7)
{
case DEFAULT
callingConvention = CallingConventions.Standard;
unmanaged = false;
break;
case 0x01
unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
unmanaged = true;
break;
case 0x02
unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
unmanaged = true;
break;
case 0x03
unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
unmanaged = true;
break;
case 0x04
unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
unmanaged = true;
break;
case VARARG
callingConvention = CallingConventions.VarArgs;
unmanaged = false;
break;
default
throw new BadImageFormatException();
}
if ((flags & HASTHIS) != 0)
{
callingConvention |= CallingConventions.HasThis;
}
if ((flags & EXPLICITTHIS) != 0)
{
callingConvention |= CallingConventions.ExplicitThis;
}
if ((flags & GENERIC) != 0)
{
throw new BadImageFormatException();
}
int paramCount = br.ReadCompressedInt();
SkipCustomModifiers(br);
Type returnType = ReadRetType(module, br, context);
List<Type> parameterTypes = new List<Type>();
List<Type> optionalParameterTypes = new List<Type>();
List<Type> curr = parameterTypes;
for (int i = 0; i < paramCount; i++)
{
if (br.PeekByte() == SENTINEL)
{
br.ReadByte();
curr = optionalParameterTypes;
}
SkipCustomModifiers(br);
curr.Add(ReadParam(module, br, context));
}
for (int i = 0; i < paramCount; i++)
{
if (br.PeekByte() == SENTINEL)
{
br.ReadByte();
curr = optionalParameterTypes;
}
SkipCustomModifiers(br);
curr.Add(ReadParam(module, br, context));
}
return new __StandAloneMethodSig(unmanaged, unmanagedCallingConvention, callingConvention, returnType, parameterTypes.ToArray(), optionalParameterTypes.ToArray());
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="258" endline="293">
}
private sealed class Binder
{
private readonly Type declaringType;
private readonly Type[] methodArgs;
internal Binder(Type declaringType, Type[] methodArgs)
{
this.declaringType = declaringType;
this.methodArgs = methodArgs;
}
public Type BindTypeParameter(Type type)
{
return declaringType.GetGenericTypeArgument(type.GenericParameterPosition);
}
public Type BindMethodParameter(Type type)
{
if (methodArgs == null)
{
return type;
}
return methodArgs[type.GenericParameterPosition];
}
}
internal MethodSignature Bind(Type type, Type[] methodArgs)
{
Binder binder = new Binder(type, methodArgs);
return new MethodSignature(returnType.BindTypeParameters(binder),
BindTypeParameters(binder, parameterTypes),
BindTypeParameters(binder, modifiers),
callingConvention, genericParamCount);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="294" endline="323">
private sealed class Unbinder
{
internal static readonly Unbinder Instance = new Unbinder();
private Unbinder()
{
}
public Type BindTypeParameter(Type type)
{
return type;
}
public Type BindMethodParameter(Type type)
{
return UnboundGenericMethodParameter.Make(type.GenericParameterPosition);
}
}
internal static MethodSignature MakeFromBuilder(Type returnType, Type[] parameterTypes, Type[][][] modifiers, CallingConventions callingConvention, int genericParamCount)
{
if (genericParamCount > 0)
{
returnType = returnType.BindTypeParameters(Unbinder.Instance);
parameterTypes = BindTypeParameters(Unbinder.Instance, parameterTypes);
modifiers = BindTypeParameters(Unbinder.Instance, modifiers);
}
return new MethodSignature(returnType, parameterTypes, modifiers, callingConvention, genericParamCount);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="324" endline="351">
internal bool MatchParameterTypes(Type[] types)
{
if (types == parameterTypes)
{
return true;
}
if (types == null)
{
return parameterTypes.Length == 0;
}
if (parameterTypes == null)
{
return types.Length == 0;
}
if (types.Length == parameterTypes.Length)
{
for (int i = 0; i < types.Length; i++)
{
if (!Util.TypeEquals(types[i], parameterTypes[i]))
{
return false;
}
}
for (int i = 0; i < types.Length; i++)
{
if (!Util.TypeEquals(types[i], parameterTypes[i]))
{
return false;
}
}
return true;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="357" endline="369">
internal void WriteMethodRefSig(ModuleBuilder module, ByteBuffer bb, Type[] optionalParameterTypes)
{
WriteSigImpl(module, bb, parameterTypes.Length + optionalParameterTypes.Length);
if (optionalParameterTypes.Length > 0)
{
bb.Write(SENTINEL);
foreach (Type type in optionalParameterTypes)
{
WriteType(module, bb, type);
}
foreach (Type type in optionalParameterTypes)
{
WriteType(module, bb, type);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="370" endline="418">
private void WriteSigImpl(ModuleBuilder module, ByteBuffer bb, int parameterCount)
{
byte first;
if ((callingConvention & CallingConventions.Any) == CallingConventions.VarArgs)
{
Debug.Assert(genericParamCount == 0);
first = VARARG;
}
else if (genericParamCount > 0)
{
first = GENERIC;
}
else
{
first = DEFAULT;
}
if ((callingConvention & CallingConventions.HasThis) != 0)
{
first |= HASTHIS;
}
if ((callingConvention & CallingConventions.ExplicitThis) != 0)
{
first |= EXPLICITTHIS;
}
bb.Write(first);
if (genericParamCount > 0)
{
bb.WriteCompressedInt(genericParamCount);
}
bb.WriteCompressedInt(parameterCount);
if (modifiers != null && modifiers[0] != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[0][0]);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[0][1]);
}
WriteType(module, bb, returnType);
for (int i = 0; i < parameterTypes.Length; i++)
{
if (modifiers != null && modifiers[i + 1] != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
}
WriteType(module, bb, parameterTypes[i]);
}
for (int i = 0; i < parameterTypes.Length; i++)
{
if (modifiers != null && modifiers[i + 1] != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
}
WriteType(module, bb, parameterTypes[i]);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="419" endline="446">
}
static class PackedCustomModifiers
{
internal static void SetModifiers(ref Type[][][] modifiers, int index, int optOrReq, Type[] add, int count)
{
if (add != null)
{
if (modifiers == null)
{
modifiers = new Type[count][][];
}
if (modifiers[index] == null)
{
modifiers[index] = new Type[2][];
}
modifiers[index][optOrReq] = add;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="447" endline="460">
internal static Type[][][] CreateFromExternal(Type[] returnOptional, Type[] returnRequired, Type[][] parameterOptional, Type[][] parameterRequired, int parameterCount)
{
Type[][][] modifiers = null;
SetModifiers(ref modifiers, 0, 0, NormalizeAndCopy(returnOptional), parameterCount + 1);
SetModifiers(ref modifiers, 0, 1, NormalizeAndCopy(returnRequired), parameterCount + 1);
for (int i = 0; i < parameterCount; i++)
{
SetModifiers(ref modifiers, i + 1, 0, NormalizeAndCopy(parameterOptional, i), parameterCount + 1);
SetModifiers(ref modifiers, i + 1, 1, NormalizeAndCopy(parameterRequired, i), parameterCount + 1);
}
for (int i = 0; i < parameterCount; i++)
{
SetModifiers(ref modifiers, i + 1, 0, NormalizeAndCopy(parameterOptional, i), parameterCount + 1);
SetModifiers(ref modifiers, i + 1, 1, NormalizeAndCopy(parameterRequired, i), parameterCount + 1);
}
return modifiers;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="461" endline="481">
private static Type[] NormalizeAndCopy(Type[] array)
{
if (array == null || array.Length == 0)
{
return null;
}
Type[] copy = null;
for (int i = 0; i < array.Length; i++)
{
if (array[i] != null)
{
if (copy == null)
{
copy = new Type[array.Length];
}
copy[i] = array[i];
}
}
for (int i = 0; i < array.Length; i++)
{
if (array[i] != null)
{
if (copy == null)
{
copy = new Type[array.Length];
}
copy[i] = array[i];
}
}
return copy;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="482" endline="490">
private static Type[] NormalizeAndCopy(Type[][] array, int index)
{
if (array == null || array.Length == 0)
{
return null;
}
return NormalizeAndCopy(array[index]);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="57" endline="66">
static private byte [] GetBytesLE (int val)
{
return new byte [] {
(byte) (val & 0xff),
(byte) ((val >> 8) & 0xff),
(byte) ((val >> 16) & 0xff),
(byte) ((val >> 24) & 0xff)
};
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="67" endline="78">
static private byte[] Trim (byte[] array)
{
for (int i=0; i < array.Length; i++) {
if (array [i] != 0x00) {
byte[] result = new byte [array.Length - i];
Buffer.BlockCopy (array, i, result, 0, result.Length);
return result;
}
}
for (int i=0; i < array.Length; i++) {
if (array [i] != 0x00) {
byte[] result = new byte [array.Length - i];
Buffer.BlockCopy (array, i, result, 0, result.Length);
return result;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="87" endline="195">
static public RSA FromCapiPrivateKeyBlob (byte[] blob, int offset)
{
if (blob == null)
throw new ArgumentNullException ("blob");
if (offset >= blob.Length)
throw new ArgumentException ("blob is too small.");
RSAParameters rsap = new RSAParameters ();
try {
if ((blob [offset]   != 0x07) ||				// PRIVATEKEYBLOB (0x07)
(blob [offset+1] != 0x02) ||				// Version (0x02)
(blob [offset+2] != 0x00) ||				// Reserved (word)
(blob [offset+3] != 0x00) ||
(ToUInt32LE (blob, offset+8) != 0x32415352))	// DWORD magic = RSA2
throw new CryptographicException ("Invalid blob header");
int bitLen = ToInt32LE (blob, offset+12);
byte[] exp = new byte [4];
Buffer.BlockCopy (blob, offset+16, exp, 0, 4);
Array.Reverse (exp);
rsap.Exponent = Trim (exp);
int pos = offset+20;
int byteLen = (bitLen >> 3);
rsap.Modulus = new byte [byteLen];
Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
Array.Reverse (rsap.Modulus);
pos += byteLen;
int byteHalfLen = (byteLen >> 1);
rsap.P = new byte [byteHalfLen];
Buffer.BlockCopy (blob, pos, rsap.P, 0, byteHalfLen);
Array.Reverse (rsap.P);
pos += byteHalfLen;
rsap.Q = new byte [byteHalfLen];
Buffer.BlockCopy (blob, pos, rsap.Q, 0, byteHalfLen);
Array.Reverse (rsap.Q);
pos += byteHalfLen;
rsap.DP = new byte [byteHalfLen];
Buffer.BlockCopy (blob, pos, rsap.DP, 0, byteHalfLen);
Array.Reverse (rsap.DP);
pos += byteHalfLen;
rsap.DQ = new byte [byteHalfLen];
Buffer.BlockCopy (blob, pos, rsap.DQ, 0, byteHalfLen);
Array.Reverse (rsap.DQ);
pos += byteHalfLen;
rsap.InverseQ = new byte [byteHalfLen];
Buffer.BlockCopy (blob, pos, rsap.InverseQ, 0, byteHalfLen);
Array.Reverse (rsap.InverseQ);
pos += byteHalfLen;
rsap.D = new byte [byteLen]; // must be allocated
if (pos + byteLen + offset <= blob.Length) {
Buffer.BlockCopy (blob, pos, rsap.D, 0, byteLen);
Array.Reverse (rsap.D);
}
}
catch (Exception e) {
throw new CryptographicException ("Invalid blob.", e);
}
#if NET_2_1
RSA rsa = RSA.Create ();
rsa.ImportParameters (rsap);
#else
RSA rsa = null;
try {
rsa = RSA.Create ();
rsa.ImportParameters (rsap);
}
catch (CryptographicException ce) {
try {
CspParameters csp = new CspParameters ();
csp.Flags = CspProviderFlags.UseMachineKeyStore;
rsa = new RSACryptoServiceProvider (csp);
rsa.ImportParameters (rsap);
}
catch {
throw ce;
}
}
#endif
return rsa;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="201" endline="280">
static public DSA FromCapiPrivateKeyBlobDSA (byte[] blob, int offset)
{
if (blob == null)
throw new ArgumentNullException ("blob");
if (offset >= blob.Length)
throw new ArgumentException ("blob is too small.");
DSAParameters dsap = new DSAParameters ();
try {
if ((blob [offset] != 0x07) ||				// PRIVATEKEYBLOB (0x07)
(blob [offset + 1] != 0x02) ||			// Version (0x02)
(blob [offset + 2] != 0x00) ||			// Reserved (word)
(blob [offset + 3] != 0x00) ||
(ToUInt32LE (blob, offset + 8) != 0x32535344))	// DWORD magic
throw new CryptographicException ("Invalid blob header");
int bitlen = ToInt32LE (blob, offset + 12);
int bytelen = bitlen >> 3;
int pos = offset + 16;
dsap.P = new byte [bytelen];
Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
Array.Reverse (dsap.P);
pos += bytelen;
dsap.Q = new byte [20];
Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
Array.Reverse (dsap.Q);
pos += 20;
dsap.G = new byte [bytelen];
Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
Array.Reverse (dsap.G);
pos += bytelen;
dsap.X = new byte [20];
Buffer.BlockCopy (blob, pos, dsap.X, 0, 20);
Array.Reverse (dsap.X);
pos += 20;
dsap.Counter = ToInt32LE (blob, pos);
pos += 4;
dsap.Seed = new byte [20];
Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
Array.Reverse (dsap.Seed);
pos += 20;
}
catch (Exception e) {
throw new CryptographicException ("Invalid blob.", e);
}
#if NET_2_1
DSA dsa = (DSA)DSA.Create ();
dsa.ImportParameters (dsap);
#else
DSA dsa = null;
try {
dsa = (DSA)DSA.Create ();
dsa.ImportParameters (dsap);
}
catch (CryptographicException ce) {
try {
CspParameters csp = new CspParameters ();
csp.Flags = CspProviderFlags.UseMachineKeyStore;
dsa = new DSACryptoServiceProvider (csp);
dsa.ImportParameters (dsap);
}
catch {
throw ce;
}
}
#endif
return dsa;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="281" endline="352">
static public byte[] ToCapiPrivateKeyBlob (RSA rsa)
{
RSAParameters p = rsa.ExportParameters (true);
int keyLength = p.Modulus.Length; // in bytes
byte[] blob = new byte [20 + (keyLength << 2) + (keyLength >> 1)];
blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
blob [8] = 0x52;	// Magic - RSA2 (ASCII in hex)
blob [9] = 0x53;
blob [10] = 0x41;
blob [11] = 0x32;
byte[] bitlen = GetBytesLE (keyLength << 3);
blob [12] = bitlen [0];	// bitlen
blob [13] = bitlen [1];
blob [14] = bitlen [2];
blob [15] = bitlen [3];
int pos = 16;
int n = p.Exponent.Length;
while (n > 0)
blob [pos++] = p.Exponent [--n];
while (n > 0)
blob [pos++] = p.Exponent [--n];
pos = 20;
byte[] part = p.Modulus;
int len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
pos += len;
part = p.P;
len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
pos += len;
part = p.Q;
len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
pos += len;
part = p.DP;
len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
pos += len;
part = p.DQ;
len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
pos += len;
part = p.InverseQ;
len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
pos += len;
part = p.D;
len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
return blob;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="353" endline="406">
static public byte[] ToCapiPrivateKeyBlob (DSA dsa)
{
DSAParameters p = dsa.ExportParameters (true);
int keyLength = p.P.Length; // in bytes
byte[] blob = new byte [16 + keyLength + 20 + keyLength + 20 + 4 + 20];
blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
blob [5] = 0x22;	// ALGID
blob [8] = 0x44;	// Magic
blob [9] = 0x53;
blob [10] = 0x53;
blob [11] = 0x32;
byte[] bitlen = GetBytesLE (keyLength << 3);
blob [12] = bitlen [0];
blob [13] = bitlen [1];
blob [14] = bitlen [2];
blob [15] = bitlen [3];
int pos = 16;
byte[] part = p.P;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, keyLength);
pos += keyLength;
part = p.Q;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, 20);
pos += 20;
part = p.G;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, keyLength);
pos += keyLength;
part = p.X;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, 20);
pos += 20;
Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
pos += 4;
part = p.Seed;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, 20);
return blob;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="412" endline="471">
static public RSA FromCapiPublicKeyBlob (byte[] blob, int offset)
{
if (blob == null)
throw new ArgumentNullException ("blob");
if (offset >= blob.Length)
throw new ArgumentException ("blob is too small.");
try {
if ((blob [offset]   != 0x06) ||				// PUBLICKEYBLOB (0x06)
(blob [offset+1] != 0x02) ||				// Version (0x02)
(blob [offset+2] != 0x00) ||				// Reserved (word)
(blob [offset+3] != 0x00) ||
(ToUInt32LE (blob, offset+8) != 0x31415352))	// DWORD magic = RSA1
throw new CryptographicException ("Invalid blob header");
int bitLen = ToInt32LE (blob, offset+12);
RSAParameters rsap = new RSAParameters ();
rsap.Exponent = new byte [3];
rsap.Exponent [0] = blob [offset+18];
rsap.Exponent [1] = blob [offset+17];
rsap.Exponent [2] = blob [offset+16];
int pos = offset+20;
int byteLen = (bitLen >> 3);
rsap.Modulus = new byte [byteLen];
Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
Array.Reverse (rsap.Modulus);
#if NET_2_1
RSA rsa = RSA.Create ();
rsa.ImportParameters (rsap);
#else
RSA rsa = null;
try {
rsa = RSA.Create ();
rsa.ImportParameters (rsap);
}
catch (CryptographicException) {
CspParameters csp = new CspParameters ();
csp.Flags = CspProviderFlags.UseMachineKeyStore;
rsa = new RSACryptoServiceProvider (csp);
rsa.ImportParameters (rsap);
}
#endif
return rsa;
}
catch (Exception e) {
throw new CryptographicException ("Invalid blob.", e);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="477" endline="533">
static public DSA FromCapiPublicKeyBlobDSA (byte[] blob, int offset)
{
if (blob == null)
throw new ArgumentNullException ("blob");
if (offset >= blob.Length)
throw new ArgumentException ("blob is too small.");
try {
if ((blob [offset] != 0x06) ||				// PUBLICKEYBLOB (0x06)
(blob [offset + 1] != 0x02) ||			// Version (0x02)
(blob [offset + 2] != 0x00) ||			// Reserved (word)
(blob [offset + 3] != 0x00) ||
(ToUInt32LE (blob, offset + 8) != 0x31535344))	// DWORD magic
throw new CryptographicException ("Invalid blob header");
int bitlen = ToInt32LE (blob, offset + 12);
DSAParameters dsap = new DSAParameters ();
int bytelen = bitlen >> 3;
int pos = offset + 16;
dsap.P = new byte [bytelen];
Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
Array.Reverse (dsap.P);
pos += bytelen;
dsap.Q = new byte [20];
Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
Array.Reverse (dsap.Q);
pos += 20;
dsap.G = new byte [bytelen];
Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
Array.Reverse (dsap.G);
pos += bytelen;
dsap.Y = new byte [bytelen];
Buffer.BlockCopy (blob, pos, dsap.Y, 0, bytelen);
Array.Reverse (dsap.Y);
pos += bytelen;
dsap.Counter = ToInt32LE (blob, pos);
pos += 4;
dsap.Seed = new byte [20];
Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
Array.Reverse (dsap.Seed);
pos += 20;
DSA dsa = (DSA)DSA.Create ();
dsa.ImportParameters (dsap);
return dsa;
}
catch (Exception e) {
throw new CryptographicException ("Invalid blob.", e);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="534" endline="569">
static public byte[] ToCapiPublicKeyBlob (RSA rsa)
{
RSAParameters p = rsa.ExportParameters (false);
int keyLength = p.Modulus.Length; // in bytes
byte[] blob = new byte [20 + keyLength];
blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
blob [8] = 0x52;	// Magic - RSA1 (ASCII in hex)
blob [9] = 0x53;
blob [10] = 0x41;
blob [11] = 0x31;
byte[] bitlen = GetBytesLE (keyLength << 3);
blob [12] = bitlen [0];	// bitlen
blob [13] = bitlen [1];
blob [14] = bitlen [2];
blob [15] = bitlen [3];
int pos = 16;
int n = p.Exponent.Length;
while (n > 0)
blob [pos++] = p.Exponent [--n];
while (n > 0)
blob [pos++] = p.Exponent [--n];
pos = 20;
byte[] part = p.Modulus;
int len = part.Length;
Array.Reverse (part, 0, len);
Buffer.BlockCopy (part, 0, blob, pos, len);
pos += len;
return blob;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="570" endline="625">
static public byte[] ToCapiPublicKeyBlob (DSA dsa)
{
DSAParameters p = dsa.ExportParameters (false);
int keyLength = p.P.Length; // in bytes
byte[] blob = new byte [16 + keyLength + 20 + keyLength + keyLength + 4 + 20];
blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
blob [5] = 0x22;	// ALGID
blob [8] = 0x44;	// Magic
blob [9] = 0x53;
blob [10] = 0x53;
blob [11] = 0x31;
byte[] bitlen = GetBytesLE (keyLength << 3);
blob [12] = bitlen [0];
blob [13] = bitlen [1];
blob [14] = bitlen [2];
blob [15] = bitlen [3];
int pos = 16;
byte[] part;
part = p.P;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, keyLength);
pos += keyLength;
part = p.Q;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, 20);
pos += 20;
part = p.G;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, keyLength);
pos += keyLength;
part = p.Y;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, keyLength);
pos += keyLength;
Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
pos += 4;
part = p.Seed;
Array.Reverse (part);
Buffer.BlockCopy (part, 0, blob, pos, 20);
return blob;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="633" endline="655">
static public RSA FromCapiKeyBlob (byte[] blob, int offset)
{
if (blob == null)
throw new ArgumentNullException ("blob");
if (offset >= blob.Length)
throw new ArgumentException ("blob is too small.");
switch (blob [offset]) {
case 0x00
if (blob [offset + 12] == 0x06) {
return FromCapiPublicKeyBlob (blob, offset + 12);
}
break;
case 0x06
return FromCapiPublicKeyBlob (blob, offset);
case 0x07
return FromCapiPrivateKeyBlob (blob, offset);
}
throw new CryptographicException ("Unknown blob format.");
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="661" endline="676">
static public DSA FromCapiKeyBlobDSA (byte[] blob, int offset)
{
if (blob == null)
throw new ArgumentNullException ("blob");
if (offset >= blob.Length)
throw new ArgumentException ("blob is too small.");
switch (blob [offset]) {
case 0x06
return FromCapiPublicKeyBlobDSA (blob, offset);
case 0x07
return FromCapiPrivateKeyBlobDSA (blob, offset);
}
throw new CryptographicException ("Unknown blob format.");
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="677" endline="690">
static public byte[] ToCapiKeyBlob (AsymmetricAlgorithm keypair, bool includePrivateKey)
{
if (keypair == null)
throw new ArgumentNullException ("keypair");
if (keypair is RSA)
return ToCapiKeyBlob ((RSA)keypair, includePrivateKey);
else if (keypair is DSA)
return ToCapiKeyBlob ((DSA)keypair, includePrivateKey);
else
return null;	// TODO
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="691" endline="701">
static public byte[] ToCapiKeyBlob (RSA rsa, bool includePrivateKey)
{
if (rsa == null)
throw new ArgumentNullException ("rsa");
if (includePrivateKey)
return ToCapiPrivateKeyBlob (rsa);
else
return ToCapiPublicKeyBlob (rsa);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="702" endline="712">
static public byte[] ToCapiKeyBlob (DSA dsa, bool includePrivateKey)
{
if (dsa == null)
throw new ArgumentNullException ("dsa");
if (includePrivateKey)
return ToCapiPrivateKeyBlob (dsa);
else
return ToCapiPublicKeyBlob (dsa);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="713" endline="724">
static public string ToHex (byte[] input)
{
if (input == null)
return null;
StringBuilder sb = new StringBuilder (input.Length * 2);
foreach (byte b in input) {
sb.Append (b.ToString ("X2", CultureInfo.InvariantCulture));
}
foreach (byte b in input) {
sb.Append (b.ToString ("X2", CultureInfo.InvariantCulture));
}
return sb.ToString ();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="725" endline="735">
static private byte FromHexChar (char c)
{
if ((c >= 'a') && (c <= 'f'))
return (byte) (c - 'a' + 10);
if ((c >= 'A') && (c <= 'F'))
return (byte) (c - 'A' + 10);
if ((c >= '0') && (c <= '9'))
return (byte) (c - '0');
throw new ArgumentException ("invalid hex char");
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="736" endline="752">
static public byte[] FromHex (string hex)
{
if (hex == null)
return null;
if ((hex.Length & 0x1) == 0x1)
throw new ArgumentException ("Length must be a multiple of 2");
byte[] result = new byte [hex.Length >> 1];
int n = 0;
int i = 0;
while (n < result.Length) {
result [n] = (byte) (FromHexChar (hex [i++]) << 4);
result [n++] += FromHexChar (hex [i++]);
}
while (n < result.Length) {
result [n] = (byte) (FromHexChar (hex [i++]) << 4);
result [n++] += FromHexChar (hex [i++]);
}
return result;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="36" endline="42">
private readonly IMAGE_NT_HEADERS hdr = new IMAGE_NT_HEADERS();
internal PEWriter(Stream stream)
{
bw = new BinaryWriter(stream);
WriteMSDOSHeader();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="47" endline="59">
}
public uint HeaderSize
{
get
{
return (uint)
((8 * 16) +	// MSDOS header
4 +				// signature
20 +			// IMAGE_FILE_HEADER
hdr.FileHeader.SizeOfOptionalHeader +
hdr.FileHeader.NumberOfSections * 40);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="60" endline="82">
}
private void WriteMSDOSHeader()
{
bw.Write(new byte[] {
0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
0xB8, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00,
0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72,
0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E,
0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
});
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="83" endline="99">
internal void WritePEHeaders()
{
bw.Write(hdr.Signature);
bw.Write(hdr.FileHeader.Machine);
bw.Write(hdr.FileHeader.NumberOfSections);
bw.Write(hdr.FileHeader.TimeDateStamp);
bw.Write(hdr.FileHeader.PointerToSymbolTable);
bw.Write(hdr.FileHeader.NumberOfSymbols);
bw.Write(hdr.FileHeader.SizeOfOptionalHeader);
bw.Write(hdr.FileHeader.Characteristics);
hdr.OptionalHeader.Write(bw);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="100" endline="115">
internal void WriteSectionHeader(SectionHeader sectionHeader)
{
byte[] name = new byte[8];
System.Text.Encoding.UTF8.GetBytes(sectionHeader.Name, 0, sectionHeader.Name.Length, name, 0);
bw.Write(name);
bw.Write(sectionHeader.VirtualSize);
bw.Write(sectionHeader.VirtualAddress);
bw.Write(sectionHeader.SizeOfRawData);
bw.Write(sectionHeader.PointerToRawData);
bw.Write(sectionHeader.PointerToRelocations);
bw.Write(sectionHeader.PointerToLinenumbers);
bw.Write(sectionHeader.NumberOfRelocations);
bw.Write(sectionHeader.NumberOfLinenumbers);
bw.Write(sectionHeader.Characteristics);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="126" endline="132">
}
sealed class IMAGE_NT_HEADERS
{
public DWORD Signature = 0x00004550;	// "PE\0\0"
public IMAGE_FILE_HEADER FileHeader = new IMAGE_FILE_HEADER();
public IMAGE_OPTIONAL_HEADER OptionalHeader = new IMAGE_OPTIONAL_HEADER();
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="133" endline="152">
}
sealed class IMAGE_FILE_HEADER
{
public const WORD IMAGE_FILE_MACHINE_I386 = 0x014c;
public const WORD IMAGE_FILE_MACHINE_IA64 = 0x0200;
public const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;
public const WORD IMAGE_FILE_32BIT_MACHINE = 0x0100;
public const WORD IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
public const WORD IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
public const WORD IMAGE_FILE_DLL = 0x2000;
public WORD Machine;
public WORD NumberOfSections;
public DWORD TimeDateStamp = (uint)(DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;
public DWORD PointerToSymbolTable = 0;
public DWORD NumberOfSymbols = 0;
public WORD SizeOfOptionalHeader = 0xE0;
public WORD Characteristics = IMAGE_FILE_EXECUTABLE_IMAGE;
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="153" endline="272">
}
sealed class IMAGE_OPTIONAL_HEADER
{
public const WORD IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
public const WORD IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
public const WORD IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
public const WORD IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
public const WORD IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040;
public const WORD IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100;
public const WORD IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400;
public const WORD IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000;
public WORD Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
public BYTE MajorLinkerVersion = 8;
public BYTE MinorLinkerVersion = 0;
public DWORD SizeOfCode;
public DWORD SizeOfInitializedData;
public DWORD SizeOfUninitializedData;
public DWORD AddressOfEntryPoint;
public DWORD BaseOfCode;
public DWORD BaseOfData;
public ULONGLONG ImageBase;
public DWORD SectionAlignment = 0x2000;
public DWORD FileAlignment = 0x200;
public WORD MajorOperatingSystemVersion = 4;
public WORD MinorOperatingSystemVersion = 0;
public WORD MajorImageVersion = 0;
public WORD MinorImageVersion = 0;
public WORD MajorSubsystemVersion = 4;
public WORD MinorSubsystemVersion = 0;
public DWORD Win32VersionValue = 0;
public DWORD SizeOfImage;
public DWORD SizeOfHeaders;
public DWORD CheckSum = 0;
public WORD Subsystem;
public WORD DllCharacteristics;
public ULONGLONG SizeOfStackReserve = 0x100000;
public ULONGLONG SizeOfStackCommit = 0x1000;
public ULONGLONG SizeOfHeapReserve = 0x100000;
public ULONGLONG SizeOfHeapCommit = 0x1000;
public DWORD LoaderFlags = 0;
public DWORD NumberOfRvaAndSizes = 16;
public IMAGE_DATA_DIRECTORY[] DataDirectory = new IMAGE_DATA_DIRECTORY[16];
internal void Write(BinaryWriter bw)
{
bw.Write(Magic);
bw.Write(MajorLinkerVersion);
bw.Write(MinorLinkerVersion);
bw.Write(SizeOfCode);
bw.Write(SizeOfInitializedData);
bw.Write(SizeOfUninitializedData);
bw.Write(AddressOfEntryPoint);
bw.Write(BaseOfCode);
if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
{
bw.Write(BaseOfData);
bw.Write((DWORD)ImageBase);
}
else
{
bw.Write(ImageBase);
}
bw.Write(SectionAlignment);
bw.Write(FileAlignment);
bw.Write(MajorOperatingSystemVersion);
bw.Write(MinorOperatingSystemVersion);
bw.Write(MajorImageVersion);
bw.Write(MinorImageVersion);
bw.Write(MajorSubsystemVersion);
bw.Write(MinorSubsystemVersion);
bw.Write(Win32VersionValue);
bw.Write(SizeOfImage);
bw.Write(SizeOfHeaders);
bw.Write(CheckSum);
bw.Write(Subsystem);
bw.Write(DllCharacteristics);
if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
{
bw.Write((DWORD)SizeOfStackReserve);
}
else
{
bw.Write(SizeOfStackReserve);
}
if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
{
bw.Write((DWORD)SizeOfStackCommit);
}
else
{
bw.Write(SizeOfStackCommit);
}
if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
{
bw.Write((DWORD)SizeOfHeapReserve);
}
else
{
bw.Write(SizeOfHeapReserve);
}
if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
{
bw.Write((DWORD)SizeOfHeapCommit);
}
else
{
bw.Write(SizeOfHeapCommit);
}
bw.Write(LoaderFlags);
bw.Write(NumberOfRvaAndSizes);
for (int i = 0; i < DataDirectory.Length; i++)
{
bw.Write(DataDirectory[i].VirtualAddress);
bw.Write(DataDirectory[i].Size);
}
for (int i = 0; i < DataDirectory.Length; i++)
{
bw.Write(DataDirectory[i].VirtualAddress);
bw.Write(DataDirectory[i].Size);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="168" endline="198">
public WORD Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
public BYTE MajorLinkerVersion = 8;
public BYTE MinorLinkerVersion = 0;
public DWORD SizeOfCode;
public DWORD SizeOfInitializedData;
public DWORD SizeOfUninitializedData;
public DWORD AddressOfEntryPoint;
public DWORD BaseOfCode;
public DWORD BaseOfData;
public ULONGLONG ImageBase;
public DWORD SectionAlignment = 0x2000;
public DWORD FileAlignment = 0x200;
public WORD MajorOperatingSystemVersion = 4;
public WORD MinorOperatingSystemVersion = 0;
public WORD MajorImageVersion = 0;
public WORD MinorImageVersion = 0;
public WORD MajorSubsystemVersion = 4;
public WORD MinorSubsystemVersion = 0;
public DWORD Win32VersionValue = 0;
public DWORD SizeOfImage;
public DWORD SizeOfHeaders;
public DWORD CheckSum = 0;
public WORD Subsystem;
public WORD DllCharacteristics;
public ULONGLONG SizeOfStackReserve = 0x100000;
public ULONGLONG SizeOfStackCommit = 0x1000;
public ULONGLONG SizeOfHeapReserve = 0x100000;
public ULONGLONG SizeOfHeapCommit = 0x1000;
public DWORD LoaderFlags = 0;
public DWORD NumberOfRvaAndSizes = 16;
public IMAGE_DATA_DIRECTORY[] DataDirectory = new IMAGE_DATA_DIRECTORY[16];
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EnumBuilder.cs" startline="59" endline="66">
}
public FieldBuilder DefineLiteral(string literalName, object literalValue)
{
FieldBuilder fb = typeBuilder.DefineField(literalName, typeBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
fb.SetConstant(literalValue);
return fb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\StandAloneMethodSig.cs" startline="39" endline="47">
internal __StandAloneMethodSig(bool unmanaged, CallingConvention unmanagedCallingConvention, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
{
this.unmanaged = unmanaged;
this.unmanagedCallingConvention = unmanagedCallingConvention;
this.callingConvention = callingConvention;
this.returnType = returnType;
this.parameterTypes = parameterTypes;
this.optionalParameterTypes = optionalParameterTypes;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="55" endline="71">
private bool initLocals = true;
internal MethodBuilder(TypeBuilder typeBuilder, string name, MethodAttributes attributes, CallingConventions callingConvention)
{
this.typeBuilder = typeBuilder;
this.name = name;
this.pseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
this.nameIndex = typeBuilder.ModuleBuilder.Strings.Add(name);
this.attributes = attributes;
if ((attributes & MethodAttributes.Static) == 0)
{
callingConvention |= CallingConventions.HasThis;
}
this.callingConvention = callingConvention;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="77" endline="85">
public ILGenerator GetILGenerator(int streamSize)
{
if (ilgen == null)
{
ilgen = new ILGenerator(typeBuilder.ModuleBuilder, streamSize);
}
return ilgen;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="91" endline="105">
private void SetDllImportPseudoCustomAttribute(CustomAttributeBuilder customBuilder)
{
CallingConvention? callingConvention = customBuilder.GetFieldValue<CallingConvention>("CallingConvention");
CharSet? charSet = customBuilder.GetFieldValue<CharSet>("CharSet");
SetDllImportPseudoCustomAttribute((string)customBuilder.GetConstructorArgument(0),
(string)customBuilder.GetFieldValue("EntryPoint"),
callingConvention,
charSet,
(bool?)customBuilder.GetFieldValue("BestFitMapping"),
(bool?)customBuilder.GetFieldValue("ThrowOnUnmappableChar"),
(bool?)customBuilder.GetFieldValue("SetLastError"),
(bool?)customBuilder.GetFieldValue("PreserveSig"),
(bool?)customBuilder.GetFieldValue("ExactSpelling"));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="106" endline="199">
internal void SetDllImportPseudoCustomAttribute(string dllName, string entryName, CallingConvention? nativeCallConv, CharSet? nativeCharSet,
bool? bestFitMapping, bool? throwOnUnmappableChar, bool? setLastError, bool? preserveSig, bool? exactSpelling)
{
const short NoMangle = 0x0001;
const short CharSetMask = 0x0006;
const short CharSetNotSpec = 0x0000;
const short CharSetAnsi = 0x0002;
const short CharSetUnicode = 0x0004;
const short CharSetAuto = 0x0006;
const short SupportsLastError = 0x0040;
const short CallConvMask = 0x0700;
const short CallConvWinapi = 0x0100;
const short CallConvCdecl = 0x0200;
const short CallConvStdcall = 0x0300;
const short CallConvThiscall = 0x0400;
const short CallConvFastcall = 0x0500;
const short BestFitOn = 0x0010;
const short BestFitOff = 0x0020;
const short CharMapErrorOn = 0x1000;
const short CharMapErrorOff = 0x2000;
int name = this.nameIndex;
short flags = CharSetNotSpec | CallConvWinapi;
if (bestFitMapping.HasValue)
{
flags |= bestFitMapping.Value ? BestFitOn
}
if (throwOnUnmappableChar.HasValue)
{
flags |= throwOnUnmappableChar.Value ? CharMapErrorOn
}
if (nativeCallConv.HasValue)
{
flags &= ~CallConvMask;
switch (nativeCallConv.Value)
{
case System.Runtime.InteropServices.CallingConvention.Cdecl
flags |= CallConvCdecl;
break;
case System.Runtime.InteropServices.CallingConvention.FastCall
flags |= CallConvFastcall;
break;
case System.Runtime.InteropServices.CallingConvention.StdCall
flags |= CallConvStdcall;
break;
case System.Runtime.InteropServices.CallingConvention.ThisCall
flags |= CallConvThiscall;
break;
case System.Runtime.InteropServices.CallingConvention.Winapi
flags |= CallConvWinapi;
break;
}
}
if (nativeCharSet.HasValue)
{
flags &= ~CharSetMask;
switch (nativeCharSet.Value)
{
case CharSet.Ansi
case CharSet.None
flags |= CharSetAnsi;
break;
case CharSet.Auto
flags |= CharSetAuto;
break;
case CharSet.Unicode
flags |= CharSetUnicode;
break;
}
}
if (entryName != null)
{
name = this.ModuleBuilder.Strings.Add(entryName);
}
if (exactSpelling.HasValue && exactSpelling.Value)
{
flags |= NoMangle;
}
if (!preserveSig.HasValue || preserveSig.Value)
{
implFlags |= MethodImplAttributes.PreserveSig;
}
if (setLastError.HasValue && setLastError.Value)
{
flags |= SupportsLastError;
}
ImplMapTable.Record rec = new ImplMapTable.Record();
rec.MappingFlags = flags;
rec.MemberForwarded = pseudoToken;
rec.ImportName = name;
rec.ImportScope = this.ModuleBuilder.ModuleRef.FindOrAddRecord(dllName == null ? 0
this.ModuleBuilder.ImplMap.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="200" endline="235">
private void SetMethodImplAttribute(CustomAttributeBuilder customBuilder)
{
MethodImplOptions opt;
switch (customBuilder.Constructor.ParameterCount)
{
case 0
opt = 0;
break;
case 1
{
object val = customBuilder.GetConstructorArgument(0);
if (val is short)
{
opt = (MethodImplOptions)(short)val;
}
else if (val is int)
{
opt = (MethodImplOptions)(int)val;
}
else
{
opt = (MethodImplOptions)val;
}
break;
}
default
throw new NotSupportedException();
}
MethodCodeType? type = customBuilder.GetFieldValue<MethodCodeType>("MethodCodeType");
implFlags = (MethodImplAttributes)opt;
if (type.HasValue)
{
implFlags |= (MethodImplAttributes)type;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="236" endline="266">
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
{
Universe u = this.ModuleBuilder.universe;
Type type = customBuilder.Constructor.DeclaringType;
if (type == u.System_Runtime_InteropServices_DllImportAttribute)
{
attributes |= MethodAttributes.PinvokeImpl;
SetDllImportPseudoCustomAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
}
else if (type == u.System_Runtime_CompilerServices_MethodImplAttribute)
{
SetMethodImplAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
}
else if (type == u.System_Runtime_InteropServices_PreserveSigAttribute)
{
implFlags |= MethodImplAttributes.PreserveSig;
}
else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
{
attributes |= MethodAttributes.SpecialName;
}
else
{
if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
{
attributes |= MethodAttributes.HasSecurity;
}
this.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="267" endline="276">
public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
{
attributes |= MethodAttributes.HasSecurity;
if (declarativeSecurity == null)
{
declarativeSecurity = new List<CustomAttributeBuilder>();
}
declarativeSecurity.Add(customBuilder);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="288" endline="315">
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName)
{
int sequence = position--;
if (parameters == null)
{
parameters = new List<ParameterBuilder>();
}
this.ModuleBuilder.Param.AddVirtualRecord();
ParameterBuilder pb = new ParameterBuilder(this.ModuleBuilder, sequence, attributes, strParamName);
if (parameters.Count == 0 || position > parameters[parameters.Count - 1].Position)
{
parameters.Add(pb);
}
else
{
for (int i = 0; i < parameters.Count; i++)
{
if (parameters[i].Position > position)
{
parameters.Insert(i, pb);
break;
}
}
for (int i = 0; i < parameters.Count; i++)
{
if (parameters[i].Position > position)
{
parameters.Insert(i, pb);
break;
}
}
}
return pb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="326" endline="333">
public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
{
this.returnType = returnType ?? this.Module.universe.System_Void;
this.parameterTypes = Util.Copy(parameterTypes);
this.modifiers = PackedCustomModifiers.CreateFromExternal(returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
parameterTypeOptionalCustomModifiers, parameterTypeRequiredCustomModifiers, this.parameterTypes.Length);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="334" endline="343">
public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
{
gtpb = new GenericTypeParameterBuilder[names.Length];
for (int i = 0; i < names.Length; i++)
{
gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
}
for (int i = 0; i < names.Length; i++)
{
gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
}
return (GenericTypeParameterBuilder[])gtpb.Clone();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="349" endline="357">
public override MethodInfo GetGenericMethodDefinition()
{
if (gtpb == null)
{
throw new InvalidOperationException();
}
return this;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="398" endline="520">
private sealed class ParameterInfoImpl
{
private readonly MethodBuilder method;
private readonly int parameter;
internal ParameterInfoImpl(MethodBuilder method, int parameter)
{
this.method = method;
this.parameter = parameter;
}
private ParameterBuilder ParameterBuilder
{
get
{
if (method.parameters != null)
{
foreach (ParameterBuilder pb in method.parameters)
{
if (pb.Position == parameter)
{
return pb;
}
}
}
return null;
}
}
public override string Name
{
get
{
ParameterBuilder pb = this.ParameterBuilder;
return pb != null ? pb.Name
}
}
public override Type ParameterType
{
get { return parameter == -1 ? method.returnType
}
public override ParameterAttributes Attributes
{
get
{
ParameterBuilder pb = this.ParameterBuilder;
return pb != null ? (ParameterAttributes)pb.Attributes
}
}
public override int Position
{
get { return parameter; }
}
public override object RawDefaultValue
{
get
{
ParameterBuilder pb = this.ParameterBuilder;
if (pb != null && (pb.Attributes & (int)ParameterAttributes.HasDefault) != 0)
{
return method.ModuleBuilder.Constant.GetRawConstantValue(method.ModuleBuilder, pb.PseudoToken);
}
if (pb != null && (pb.Attributes & (int)ParameterAttributes.Optional) != 0)
{
return Missing.Value;
}
return null;
}
}
private Type[] GetCustomModifiers(int optOrReq)
{
if (method.modifiers == null || method.modifiers[parameter + 1] == null)
{
return Type.EmptyTypes;
}
return Util.Copy(method.modifiers[parameter + 1][optOrReq]);
}
public override Type[] GetOptionalCustomModifiers()
{
return GetCustomModifiers(0);
}
public override Type[] GetRequiredCustomModifiers()
{
return GetCustomModifiers(1);
}
public override MemberInfo Member
{
get { return method; }
}
public override int MetadataToken
{
get
{
ParameterBuilder pb = this.ParameterBuilder;
return pb != null ? pb.PseudoToken
}
}
internal override Module Module
{
get { return method.Module; }
}
}
public override ParameterInfo[] GetParameters()
{
ParameterInfo[] parameters = new ParameterInfo[parameterTypes.Length];
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new ParameterInfoImpl(this, i);
}
for (int i = 0; i < parameters.Length; i++)
{
parameters[i] = new ParameterInfoImpl(this, i);
}
return parameters;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="581" endline="609">
}
internal void Bake()
{
this.signature = this.ModuleBuilder.GetSignatureBlobIndex(this.MethodSignature);
if (ilgen != null)
{
if (this.ModuleBuilder.symbolWriter != null)
{
this.ModuleBuilder.symbolWriter.OpenMethod(new SymbolToken(-pseudoToken | 0x06000000));
}
rva = ilgen.WriteBody(initLocals);
if (this.ModuleBuilder.symbolWriter != null)
{
this.ModuleBuilder.symbolWriter.CloseMethod();
}
ilgen = null;
}
else
{
rva = -1;
}
if (declarativeSecurity != null)
{
this.ModuleBuilder.AddDeclarativeSecurity(pseudoToken, declarativeSecurity);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="614" endline="635">
}
internal void WriteMethodDefRecord(int baseRVA, MetadataWriter mw, ref int paramList)
{
if (rva != -1)
{
mw.Write(rva + baseRVA);
}
else
{
mw.Write(0);
}
mw.Write((short)implFlags);
mw.Write((short)attributes);
mw.WriteStringIndex(nameIndex);
mw.WriteBlobIndex(signature);
mw.WriteParam(paramList);
if (parameters != null)
{
paramList += parameters.Count;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="636" endline="646">
internal void WriteParamRecords(MetadataWriter mw)
{
if (parameters != null)
{
foreach (ParameterBuilder pb in parameters)
{
pb.WriteParamRecord(mw);
}
foreach (ParameterBuilder pb in parameters)
{
pb.WriteParamRecord(mw);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="647" endline="658">
internal void FixupToken(int token, ref int parameterToken)
{
typeBuilder.ModuleBuilder.RegisterTokenFixup(this.pseudoToken, token);
if (parameters != null)
{
foreach (ParameterBuilder pb in parameters)
{
pb.FixupToken(parameterToken++);
}
foreach (ParameterBuilder pb in parameters)
{
pb.FixupToken(parameterToken++);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="659" endline="669">
internal override MethodSignature MethodSignature
{
get
{
if (methodSignature == null)
{
methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, modifiers, callingConvention, gtpb == null ? 0
}
return methodSignature;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="670" endline="686">
}
internal override int ImportTo(ModuleBuilder other)
{
if (typeBuilder.IsGenericTypeDefinition)
{
return other.ImportMember(TypeBuilder.GetMethod(typeBuilder, this));
}
else if (other == typeBuilder.ModuleBuilder)
{
return pseudoToken;
}
else
{
return other.ImportMethodOrField(typeBuilder, name, this.MethodSignature);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="43" endline="66">
{
if (name == null)
{
return null;
}
StringBuilder sb = null;
for (int pos = 0; pos < name.Length; pos++)
{
char c = name[pos];
if (SpecialChars.IndexOf(c) != -1)
{
if (sb == null)
{
sb = new StringBuilder(name, 0, pos, name.Length + 3);
}
sb.Append('\\').Append(c);
}
else if (sb != null)
{
sb.Append(c);
}
}
for (int pos = 0; pos < name.Length; pos++)
{
char c = name[pos];
if (SpecialChars.IndexOf(c) != -1)
{
if (sb == null)
{
sb = new StringBuilder(name, 0, pos, name.Length + 3);
}
sb.Append('\\').Append(c);
}
else if (sb != null)
{
sb.Append(c);
}
}
return sb != null ? sb.ToString()
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="67" endline="86">
internal static string Unescape(string name)
{
int pos = name.IndexOf('\\');
if (pos == -1)
{
return name;
}
StringBuilder sb = new StringBuilder(name, 0, pos, name.Length - 1);
for (; pos < name.Length; pos++)
{
char c = name[pos];
if (c == '\\')
{
c = name[++pos];
}
sb.Append(c);
}
for (; pos < name.Length; pos++)
{
char c = name[pos];
if (c == '\\')
{
c = name[++pos];
}
sb.Append(c);
}
return sb.ToString();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="87" endline="107">
internal static TypeNameParser Parse(string typeName, bool throwOnError)
{
if (throwOnError)
{
Parser parser = new Parser(typeName);
return new TypeNameParser(ref parser, true);
}
else
{
try
{
Parser parser = new Parser(typeName);
return new TypeNameParser(ref parser, true);
}
catch (ArgumentException)
{
return new TypeNameParser();
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="108" endline="124">
private TypeNameParser(ref Parser parser, bool withAssemblyName)
{
bool genericParameter = parser.pos != 0;
name = parser.NextNamePart();
nested = null;
parser.ParseNested(ref nested);
genericParameters = null;
parser.ParseGenericParameters(ref genericParameters);
modifiers = null;
parser.ParseModifiers(ref modifiers);
assemblyName = null;
if (withAssemblyName)
{
parser.ParseAssemblyName(genericParameter, ref assemblyName);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="139" endline="394">
}
private struct Parser
{
private readonly string typeName;
internal int pos;
internal Parser(string typeName)
{
this.typeName = typeName;
this.pos = 0;
}
private void Check(bool condition)
{
if (!condition)
{
throw new ArgumentException("Invalid type name '" + typeName + "'");
}
}
private void Consume(char c)
{
Check(pos < typeName.Length && typeName[pos++] == c);
}
private bool TryConsume(char c)
{
if (pos < typeName.Length && typeName[pos] == c)
{
pos++;
return true;
}
else
{
return false;
}
}
internal string NextNamePart()
{
SkipWhiteSpace();
int start = pos;
for (; pos < typeName.Length; pos++)
{
char c = typeName[pos];
if (c == '\\')
{
pos++;
Check(pos < typeName.Length && SpecialChars.IndexOf(typeName[pos]) != -1);
}
else if (SpecialChars.IndexOf(c) != -1)
{
break;
}
}
Check(pos - start != 0);
if (start == 0 && pos == typeName.Length)
{
return typeName;
}
else
{
return typeName.Substring(start, pos - start);
}
}
internal void ParseNested(ref string[] nested)
{
while (TryConsume('+'))
{
Add(ref nested, NextNamePart());
}
}
internal void ParseGenericParameters(ref TypeNameParser[] genericParameters)
{
int saved = pos;
if (TryConsume('['))
{
SkipWhiteSpace();
if (TryConsume(']') || TryConsume('*') || TryConsume(','))
{
pos = saved;
return;
}
do
{
SkipWhiteSpace();
if (TryConsume('['))
{
Add(ref genericParameters, new TypeNameParser(ref this, true));
Consume(']');
}
else
{
Add(ref genericParameters, new TypeNameParser(ref this, false));
}
}
while (TryConsume(','));
Consume(']');
SkipWhiteSpace();
}
}
internal void ParseModifiers(ref short[] modifiers)
{
while (pos < typeName.Length)
{
switch (typeName[pos])
{
case '*'
pos++;
Add(ref modifiers, POINTER);
break;
case '&'
pos++;
Add(ref modifiers, BYREF);
break;
case '['
pos++;
Add(ref modifiers, ParseArray());
Consume(']');
break;
default
return;
}
SkipWhiteSpace();
}
}
internal void ParseAssemblyName(bool genericParameter, ref string assemblyName)
{
if (pos < typeName.Length)
{
if (typeName[pos] == ']' && genericParameter)
{
}
else
{
Consume(',');
SkipWhiteSpace();
if (genericParameter)
{
int start = pos;
while (pos < typeName.Length)
{
char c = typeName[pos];
if (c == '\\')
{
pos++;
Check(pos < typeName.Length && typeName[pos++] == ']');
}
else if (c == ']')
{
break;
}
else
{
pos++;
}
}
Check(pos < typeName.Length && typeName[pos] == ']');
assemblyName = typeName.Substring(start, pos - start).Replace("\\]", "]");
}
else
{
assemblyName = typeName.Substring(pos);
}
Check(assemblyName.Length != 0);
}
}
else
{
Check(!genericParameter);
}
}
private short ParseArray()
{
SkipWhiteSpace();
Check(pos < typeName.Length);
char c = typeName[pos];
if (c == ']')
{
return SZARRAY;
}
else if (c == '*')
{
pos++;
SkipWhiteSpace();
return 1;
}
else
{
short rank = 1;
while (TryConsume(','))
{
Check(rank < short.MaxValue);
rank++;
SkipWhiteSpace();
}
return rank;
}
}
private void SkipWhiteSpace()
{
while (pos < typeName.Length && Char.IsWhiteSpace(typeName[pos]))
{
pos++;
}
}
private static void Add<T>(ref T[] array, T elem)
{
if (array == null)
{
array = new T[] { elem };
return;
}
Array.Resize(ref array, array.Length + 1);
array[array.Length - 1] = elem;
}
}
internal Type GetType(Universe universe, Assembly context, bool throwOnError, string originalName)
{
Type type;
if (assemblyName != null)
{
Assembly asm = universe.Load(assemblyName, context, throwOnError);
if (asm == null)
{
return null;
}
type = asm.GetTypeImpl(name);
}
else if (context == null)
{
type = universe.Mscorlib.GetTypeImpl(name);
}
else
{
type = context.GetTypeImpl(name);
if (type == null && context != universe.Mscorlib)
{
type = universe.Mscorlib.GetTypeImpl(name);
}
}
return Expand(type, context, throwOnError, originalName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="395" endline="456">
internal Type Expand(Type type, Assembly context, bool throwOnError, string originalName)
{
if (type == null)
{
if (throwOnError)
{
throw new TypeLoadException(originalName);
}
return null;
}
if (nested != null)
{
foreach (string nest in nested)
{
type = type.GetNestedType(nest, BindingFlags.Public | BindingFlags.NonPublic);
if (type == null)
{
if (throwOnError)
{
throw new TypeLoadException(originalName);
}
return null;
}
}
foreach (string nest in nested)
{
type = type.GetNestedType(nest, BindingFlags.Public | BindingFlags.NonPublic);
if (type == null)
{
if (throwOnError)
{
throw new TypeLoadException(originalName);
}
return null;
}
}
}
if (genericParameters != null)
{
Type[] typeArgs = new Type[genericParameters.Length];
for (int i = 0; i < typeArgs.Length; i++)
{
typeArgs[i] = genericParameters[i].GetType(type.Assembly.universe, context, throwOnError, originalName);
if (typeArgs[i] == null)
{
return null;
}
}
for (int i = 0; i < typeArgs.Length; i++)
{
typeArgs[i] = genericParameters[i].GetType(type.Assembly.universe, context, throwOnError, originalName);
if (typeArgs[i] == null)
{
return null;
}
}
type = type.MakeGenericType(typeArgs);
}
if (modifiers != null)
{
foreach (short modifier in modifiers)
{
switch (modifier)
{
case SZARRAY
type = type.MakeArrayType();
break;
case BYREF
type = type.MakeByRefType();
break;
case POINTER
type = type.MakePointerType();
break;
default
type = type.MakeArrayType(modifier);
break;
}
}
foreach (short modifier in modifiers)
{
switch (modifier)
{
case SZARRAY
type = type.MakeArrayType();
break;
case BYREF
type = type.MakeByRefType();
break;
case POINTER
type = type.MakePointerType();
break;
default
type = type.MakeArrayType(modifier);
break;
}
}
}
return type;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="39" endline="52">
{
Offset = br.ReadUInt32();
Size = br.ReadUInt32();
byte[] buf = new byte[32];
byte b;
int len = 0;
while ((b = br.ReadByte()) != 0)
{
buf[len++] = b;
}
while ((b = br.ReadByte()) != 0)
{
buf[len++] = b;
}
Name = Encoding.UTF8.GetString(buf, 0, len); ;
int padding = -1 + ((len + 4) & ~3) - len;
br.BaseStream.Seek(padding, SeekOrigin.Current);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="105" endline="143">
internal readonly ModuleTable ModuleTable = new ModuleTable();
internal readonly TypeRefTable TypeRef = new TypeRefTable();
internal readonly TypeDefTable TypeDef = new TypeDefTable();
internal readonly FieldTable Field = new FieldTable();
internal readonly MemberRefTable MemberRef = new MemberRefTable();
internal readonly ConstantTable Constant = new ConstantTable();
internal readonly CustomAttributeTable CustomAttribute = new CustomAttributeTable();
internal readonly FieldMarshalTable FieldMarshal = new FieldMarshalTable();
internal readonly DeclSecurityTable DeclSecurity = new DeclSecurityTable();
internal readonly ClassLayoutTable ClassLayout = new ClassLayoutTable();
internal readonly FieldLayoutTable FieldLayout = new FieldLayoutTable();
internal readonly ParamTable Param = new ParamTable();
internal readonly InterfaceImplTable InterfaceImpl = new InterfaceImplTable();
internal readonly StandAloneSigTable StandAloneSig = new StandAloneSigTable();
internal readonly EventMapTable EventMap = new EventMapTable();
internal readonly EventTable Event = new EventTable();
internal readonly PropertyMapTable PropertyMap = new PropertyMapTable();
internal readonly PropertyTable Property = new PropertyTable();
internal readonly MethodSemanticsTable MethodSemantics = new MethodSemanticsTable();
internal readonly MethodImplTable MethodImpl = new MethodImplTable();
internal readonly ModuleRefTable ModuleRef = new ModuleRefTable();
internal readonly TypeSpecTable TypeSpec = new TypeSpecTable();
internal readonly ImplMapTable ImplMap = new ImplMapTable();
internal readonly FieldRVATable FieldRVA = new FieldRVATable();
internal readonly AssemblyTable AssemblyTable = new AssemblyTable();
internal readonly AssemblyRefTable AssemblyRef = new AssemblyRefTable();
internal readonly MethodDefTable MethodDef = new MethodDefTable();
internal readonly NestedClassTable NestedClass = new NestedClassTable();
internal readonly FileTable File = new FileTable();
internal readonly ExportedTypeTable ExportedType = new ExportedTypeTable();
internal readonly ManifestResourceTable ManifestResource = new ManifestResourceTable();
internal readonly GenericParamTable GenericParam = new GenericParamTable();
internal readonly MethodSpecTable MethodSpec = new MethodSpecTable();
internal readonly GenericParamConstraintTable GenericParamConstraint = new GenericParamConstraintTable();
internal Module(Universe universe)
{
this.universe = universe;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="144" endline="183">
internal Table[] GetTables()
{
Table[] tables = new Table[64];
tables[ModuleTable.Index] = ModuleTable;
tables[TypeRefTable.Index] = TypeRef;
tables[TypeDefTable.Index] = TypeDef;
tables[FieldTable.Index] = Field;
tables[MemberRefTable.Index] = MemberRef;
tables[ConstantTable.Index] = Constant;
tables[CustomAttributeTable.Index] = CustomAttribute;
tables[FieldMarshalTable.Index] = FieldMarshal;
tables[DeclSecurityTable.Index] = DeclSecurity;
tables[ClassLayoutTable.Index] = ClassLayout;
tables[FieldLayoutTable.Index] = FieldLayout;
tables[ParamTable.Index] = Param;
tables[InterfaceImplTable.Index] = InterfaceImpl;
tables[StandAloneSigTable.Index] = StandAloneSig;
tables[EventMapTable.Index] = EventMap;
tables[EventTable.Index] = Event;
tables[PropertyMapTable.Index] = PropertyMap;
tables[PropertyTable.Index] = Property;
tables[MethodSemanticsTable.Index] = MethodSemantics;
tables[MethodImplTable.Index] = MethodImpl;
tables[ModuleRefTable.Index] = ModuleRef;
tables[TypeSpecTable.Index] = TypeSpec;
tables[ImplMapTable.Index] = ImplMap;
tables[FieldRVATable.Index] = FieldRVA;
tables[AssemblyTable.Index] = AssemblyTable;
tables[AssemblyRefTable.Index] = AssemblyRef;
tables[MethodDefTable.Index] = MethodDef;
tables[NestedClassTable.Index] = NestedClass;
tables[FileTable.Index] = File;
tables[ExportedTypeTable.Index] = ExportedType;
tables[ManifestResourceTable.Index] = ManifestResource;
tables[GenericParamTable.Index] = GenericParam;
tables[MethodSpecTable.Index] = MethodSpec;
tables[GenericParamConstraintTable.Index] = GenericParamConstraint;
return tables;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="253" endline="264">
}
public byte[] ResolveSignature(int metadataToken)
{
ModuleReader rdr = this as ModuleReader;
if (rdr != null)
{
ByteReader br = rdr.ResolveSignature(metadataToken);
return br.ReadBytes(br.Length);
}
throw new NotSupportedException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="274" endline="296">
}
public abstract int MDStreamVersion { get ;}
public abstract Assembly Assembly { get; }
public abstract string FullyQualifiedName { get; }
public abstract string Name { get; }
public abstract Guid ModuleVersionId { get; }
public abstract Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
public abstract MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
public abstract FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
public abstract MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
public abstract string ResolveString(int metadataToken);
public abstract Type[] __ResolveOptionalParameterTypes(int metadataToken);
public abstract string ScopeName { get; }
internal abstract Type GetTypeImpl(string typeName);
internal abstract void GetTypesImpl(List<Type> list);
public Type GetType(string className)
{
return GetType(className, false, false);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="302" endline="326">
public Type GetType(string className, bool throwOnError, bool ignoreCase)
{
if (ignoreCase)
{
throw new NotImplementedException();
}
TypeNameParser parser = TypeNameParser.Parse(className, throwOnError);
if (parser.Error)
{
return null;
}
if (parser.AssemblyName != null)
{
if (throwOnError)
{
throw new ArgumentException("Type names passed to Module.GetType() must not specify an assembly.");
}
else
{
return null;
}
}
return parser.Expand(GetTypeImpl(parser.FirstNamePart), this.Assembly, throwOnError, className);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="327" endline="333">
public Type[] GetTypes()
{
List<Type> list = new List<Type>();
GetTypesImpl(list);
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="334" endline="346">
public Type[] FindTypes(TypeFilter filter, object filterCriteria)
{
List<Type> list = new List<Type>();
foreach (Type type in GetTypes())
{
if (filter(type, filterCriteria))
{
list.Add(type);
}
}
foreach (Type type in GetTypes())
{
if (filter(type, filterCriteria))
{
list.Add(type);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="387" endline="399">
public abstract AssemblyName[] __GetReferencedAssemblies();
internal Type CanonicalizeType(Type type)
{
Type canon;
if (!universe.canonicalizedTypes.TryGetValue(type, out canon))
{
canon = type;
universe.canonicalizedTypes.Add(canon, canon);
}
return canon;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="400" endline="408">
internal abstract Type GetModuleType();
internal abstract ByteReader GetBlob(int blobIndex);
internal IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
{
return GetCustomAttributes(0x00000001, attributeType);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="409" endline="433">
internal List<CustomAttributeData> GetCustomAttributes(int metadataToken, Type attributeType)
{
List<CustomAttributeData> list = new List<CustomAttributeData>();
for (int i = 0; i < CustomAttribute.records.Length; i++)
{
if (CustomAttribute.records[i].Parent == metadataToken)
{
if (attributeType == null)
{
list.Add(new CustomAttributeData(this, i));
}
else
{
ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
if (attributeType.IsAssignableFrom(constructor.DeclaringType))
{
list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
}
}
}
}
for (int i = 0; i < CustomAttribute.records.Length; i++)
{
if (CustomAttribute.records[i].Parent == metadataToken)
{
if (attributeType == null)
{
list.Add(new CustomAttributeData(this, i));
}
else
{
ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
if (attributeType.IsAssignableFrom(constructor.DeclaringType))
{
list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
}
}
}
}
return list;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="434" endline="449">
internal IList<CustomAttributeData> GetDeclarativeSecurity(int metadataToken)
{
List<CustomAttributeData> list = new List<CustomAttributeData>();
for (int i = 0; i < DeclSecurity.records.Length; i++)
{
if (DeclSecurity.records[i].Parent == metadataToken)
{
int action = DeclSecurity.records[i].Action;
int permissionSet = DeclSecurity.records[i].PermissionSet;
CustomAttributeData.ReadDeclarativeSecurity(this.Assembly, list, action, GetBlob(permissionSet));
}
}
for (int i = 0; i < DeclSecurity.records.Length; i++)
{
if (DeclSecurity.records[i].Parent == metadataToken)
{
int action = DeclSecurity.records[i].Action;
int permissionSet = DeclSecurity.records[i].PermissionSet;
CustomAttributeData.ReadDeclarativeSecurity(this.Assembly, list, action, GetBlob(permissionSet));
}
}
return list;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="60" endline="112">
private readonly PEReader peFile = new PEReader();
private readonly CliHeader cliHeader = new CliHeader();
private string imageRuntimeVersion;
private int metadataStreamVersion;
private byte[] stringHeap;
private byte[] blobHeap;
private byte[] userStringHeap;
private byte[] guidHeap;
private TypeDefImpl[] typeDefs;
private TypeDefImpl moduleType;
private Assembly[] assemblyRefs;
private Type[] typeRefs;
private Type[] typeSpecs;
private FieldInfo[] fields;
private MethodBase[] methods;
private MemberInfo[] memberRefs;
private Dictionary<int, string> strings = new Dictionary<int, string>();
private Dictionary<string, Type> types = new Dictionary<string, Type>();
private Dictionary<string, LazyForwardedType> forwardedTypes = new Dictionary<string, LazyForwardedType>();
private sealed class LazyForwardedType
{
private readonly int assemblyRef;
private Type type;
internal LazyForwardedType(int assemblyRef)
{
this.assemblyRef = assemblyRef;
}
internal Type GetType(ModuleReader module, string typeName)
{
if (type == null)
{
Assembly asm = module.ResolveAssemblyRef(assemblyRef);
type = asm.GetType(typeName, true);
}
return type;
}
}
internal ModuleReader(AssemblyReader assembly, Universe universe, Stream stream, string location)
{
this.stream = stream;
this.location = location;
Read();
if (assembly == null && AssemblyTable.records.Length != 0)
{
assembly = new AssemblyReader(location, this);
}
this.assembly = assembly;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="113" endline="145">
private void Read()
{
BinaryReader br = new BinaryReader(stream);
peFile.Read(br);
stream.Seek(peFile.RvaToFileOffset(peFile.GetComDescriptorVirtualAddress()), SeekOrigin.Begin);
cliHeader.Read(br);
stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA), SeekOrigin.Begin);
foreach (StreamHeader sh in ReadStreamHeaders(br, out imageRuntimeVersion))
{
switch (sh.Name)
{
case "#Strings"
stringHeap = ReadHeap(stream, sh);
break;
case "#Blob"
blobHeap = ReadHeap(stream, sh);
break;
case "#US"
userStringHeap = ReadHeap(stream, sh);
break;
case "#GUID"
guidHeap = ReadHeap(stream, sh);
break;
case "#~"
stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
ReadTables(br);
break;
default
throw new BadImageFormatException("Unsupported stream
}
}
foreach (StreamHeader sh in ReadStreamHeaders(br, out imageRuntimeVersion))
{
switch (sh.Name)
{
case "#Strings"
stringHeap = ReadHeap(stream, sh);
break;
case "#Blob"
blobHeap = ReadHeap(stream, sh);
break;
case "#US"
userStringHeap = ReadHeap(stream, sh);
break;
case "#GUID"
guidHeap = ReadHeap(stream, sh);
break;
case "#~"
stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
ReadTables(br);
break;
default
throw new BadImageFormatException("Unsupported stream
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="151" endline="174">
private static StreamHeader[] ReadStreamHeaders(BinaryReader br, out string Version)
{
uint Signature = br.ReadUInt32();
if (Signature != 0x424A5342)
{
throw new BadImageFormatException("Invalid metadata signature");
}
ushort MajorVersion = br.ReadUInt16();
ushort MinorVersion = br.ReadUInt16();
uint Reserved = br.ReadUInt32();
uint Length = br.ReadUInt32();
byte[] buf = br.ReadBytes((int)Length);
Version = Encoding.UTF8.GetString(buf).TrimEnd('\u0000');
ushort Flags = br.ReadUInt16();
ushort Streams = br.ReadUInt16();
StreamHeader[] streamHeaders = new StreamHeader[Streams];
for (int i = 0; i < streamHeaders.Length; i++)
{
streamHeaders[i] = new StreamHeader();
streamHeaders[i].Read(br);
}
for (int i = 0; i < streamHeaders.Length; i++)
{
streamHeaders[i] = new StreamHeader();
streamHeaders[i].Read(br);
}
return streamHeaders;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="175" endline="206">
private void ReadTables(BinaryReader br)
{
Table[] tables = GetTables();
uint Reserved0 = br.ReadUInt32();
byte MajorVersion = br.ReadByte();
byte MinorVersion = br.ReadByte();
metadataStreamVersion = MajorVersion << 16 | MinorVersion;
byte HeapSizes = br.ReadByte();
byte Reserved7 = br.ReadByte();
ulong Valid = br.ReadUInt64();
ulong Sorted = br.ReadUInt64();
for (int i = 0; i < 64; i++)
{
if ((Valid & (1UL << i)) != 0)
{
tables[i].RowCount = br.ReadInt32();
}
else if (tables[i] != null)
{
tables[i].RowCount = 0;
}
}
for (int i = 0; i < 64; i++)
{
if ((Valid & (1UL << i)) != 0)
{
tables[i].RowCount = br.ReadInt32();
}
else if (tables[i] != null)
{
tables[i].RowCount = 0;
}
}
MetadataReader mr = new MetadataReader(this, br, HeapSizes);
for (int i = 0; i < 64; i++)
{
if ((Valid & (1UL << i)) != 0)
{
tables[i].Read(mr);
}
}
for (int i = 0; i < 64; i++)
{
if ((Valid & (1UL << i)) != 0)
{
tables[i].Read(mr);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="207" endline="222">
private byte[] ReadHeap(Stream stream, StreamHeader sh)
{
byte[] buf = new byte[sh.Size];
stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
for (int pos = 0; pos < buf.Length; )
{
int read = stream.Read(buf, pos, buf.Length - pos);
if (read == 0)
{
throw new BadImageFormatException();
}
pos += read;
}
for (int pos = 0; pos < buf.Length; )
{
int read = stream.Read(buf, pos, buf.Length - pos);
if (read == 0)
{
throw new BadImageFormatException();
}
pos += read;
}
return buf;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="228" endline="239">
internal override void GetTypesImpl(List<Type> list)
{
PopulateTypeDef();
foreach (TypeDefImpl type in typeDefs)
{
if (type != moduleType)
{
list.Add(type);
}
}
foreach (TypeDefImpl type in typeDefs)
{
if (type != moduleType)
{
list.Add(type);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="240" endline="270">
private void PopulateTypeDef()
{
if (typeDefs == null)
{
typeDefs = new TypeDefImpl[TypeDef.records.Length];
for (int i = 0; i < typeDefs.Length; i++)
{
TypeDefImpl type = new TypeDefImpl(this, i);
typeDefs[i] = type;
if (type.IsModulePseudoType)
{
moduleType = type;
}
else
{
types.Add(type.FullName, type);
}
}
for (int i = 0; i < typeDefs.Length; i++)
{
TypeDefImpl type = new TypeDefImpl(this, i);
typeDefs[i] = type;
if (type.IsModulePseudoType)
{
moduleType = type;
}
else
{
types.Add(type.FullName, type);
}
}
for (int i = 0; i < ExportedType.records.Length; i++)
{
int implementation = ExportedType.records[i].Implementation;
if (implementation >> 24 == AssemblyRefTable.Index)
{
string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
}
}
for (int i = 0; i < ExportedType.records.Length; i++)
{
int implementation = ExportedType.records[i].Implementation;
if (implementation >> 24 == AssemblyRefTable.Index)
{
string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
}
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="271" endline="290">
internal string GetString(int index)
{
if (index == 0)
{
return null;
}
string str;
if (!strings.TryGetValue(index, out str))
{
int len = 0;
while (stringHeap[index + len] != 0)
{
len++;
}
while (stringHeap[index + len] != 0)
{
len++;
}
str = Encoding.UTF8.GetString(stringHeap, index, len);
strings.Add(index, str);
}
return str;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="291" endline="311">
private static int ReadCompressedInt(byte[] buffer, ref int offset)
{
byte b1 = buffer[offset++];
if (b1 <= 0x7F)
{
return b1;
}
else if ((b1 & 0xC0) == 0x80)
{
byte b2 = buffer[offset++];
return ((b1 & 0x3F) << 8) | b2;
}
else
{
byte b2 = buffer[offset++];
byte b3 = buffer[offset++];
byte b4 = buffer[offset++];
return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="312" endline="319">
internal byte[] GetBlobCopy(int blobIndex)
{
int len = ReadCompressedInt(blobHeap, ref blobIndex);
byte[] buf = new byte[len];
Buffer.BlockCopy(blobHeap, blobIndex, buf, 0, len);
return buf;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="325" endline="341">
public override string ResolveString(int metadataToken)
{
string str;
if (!strings.TryGetValue(metadataToken, out str))
{
if ((metadataToken >> 24) != 0x70)
{
throw new ArgumentOutOfRangeException();
}
int index = metadataToken & 0xFFFFFF;
int len = ReadCompressedInt(userStringHeap, ref index) & ~1;
str = Encoding.Unicode.GetString(userStringHeap, index, len);
strings.Add(metadataToken, str);
}
return str;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="342" endline="427">
internal Type ResolveType(int metadataToken, IGenericContext context)
{
switch (metadataToken >> 24)
{
case TypeDefTable.Index
PopulateTypeDef();
return typeDefs[(metadataToken & 0xFFFFFF) - 1];
case TypeRefTable.Index
{
if (typeRefs == null)
{
typeRefs = new Type[TypeRef.records.Length];
}
int index = (metadataToken & 0xFFFFFF) - 1;
if (typeRefs[index] == null)
{
int scope = TypeRef.records[index].ResolutionScope;
switch (scope >> 24)
{
case AssemblyRefTable.Index
{
Assembly assembly = ResolveAssemblyRef((scope & 0xFFFFFF) - 1);
string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
Type type = assembly.GetType(typeName);
if (type == null)
{
throw new TypeLoadException(String.Format("Type '{0}' not found in assembly '{1}'", typeName, assembly.FullName));
}
typeRefs[index] = type;
break;
}
case TypeRefTable.Index
{
Type outer = ResolveType(scope, null);
typeRefs[index] = outer.GetNestedType(GetString(TypeRef.records[index].TypeName), BindingFlags.Public | BindingFlags.NonPublic);
break;
}
case ModuleTable.Index
if (scope != 0 && scope != 1)
{
throw new NotImplementedException("self reference scope?");
}
typeRefs[index] = GetType(GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName));
break;
case ModuleRefTable.Index
{
Module module = ResolveModuleRef(ModuleRef.records[(scope & 0xFFFFFF) - 1]);
string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
Type type = assembly.GetType(typeName);
if (type == null)
{
throw new TypeLoadException(String.Format("Type '{0}' not found in module '{1}'", typeName, module.Name));
}
typeRefs[index] = type;
break;
}
default
throw new NotImplementedException("ResolutionScope = " + scope.ToString("X"));
}
}
return typeRefs[index];
}
case TypeSpecTable.Index
{
if (typeSpecs == null)
{
typeSpecs = new Type[TypeSpec.records.Length];
}
int index = (metadataToken & 0xFFFFFF) - 1;
Type type = typeSpecs[index];
if (type == null)
{
TrackingGenericContext tc = context == null ? null
type = Signature.ReadTypeSpec(this, ByteReader.FromBlob(blobHeap, TypeSpec.records[index]), tc);
if (tc == null || !tc.IsUsed)
{
typeSpecs[index] = type;
}
}
return type;
}
default
throw new NotImplementedException(String.Format("0x{0
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
private Module ResolveModuleRef(int moduleNameIndex)
{
string moduleName = GetString(moduleNameIndex);
Module module = assembly.GetModule(moduleName);
if (module == null)
{
throw new FileNotFoundException(moduleName);
}
return module;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="439" endline="478">
private sealed class TrackingGenericContext
{
private readonly IGenericContext context;
private bool used;
internal TrackingGenericContext(IGenericContext context)
{
this.context = context;
}
internal bool IsUsed
{
get { return used; }
}
public Type GetGenericTypeArgument(int index)
{
used = true;
return context.GetGenericTypeArgument(index);
}
public Type GetGenericMethodArgument(int index)
{
used = true;
return context.GetGenericMethodArgument(index);
}
}
public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
if ((metadataToken >> 24) == TypeSpecTable.Index)
{
return ResolveType(metadataToken, new GenericContext(genericTypeArguments, genericMethodArguments));
}
else
{
return ResolveType(metadataToken, null);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="479" endline="490">
private string GetTypeName(int typeNamespace, int typeName)
{
if (typeNamespace == 0)
{
return GetString(typeName);
}
else
{
return GetString(typeNamespace) + "." + GetString(typeName);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="491" endline="503">
private Assembly ResolveAssemblyRef(int index)
{
if (assemblyRefs == null)
{
assemblyRefs = new Assembly[AssemblyRef.RowCount];
}
if (assemblyRefs[index] == null)
{
assemblyRefs[index] = ResolveAssemblyRefImpl(ref AssemblyRef.records[index]);
}
return assemblyRefs[index];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="504" endline="518">
private Assembly ResolveAssemblyRefImpl(ref AssemblyRefTable.Record rec)
{
const int PublicKey = 0x0001;
string name = String.Format("{0}, Version={1}.{2}.{3}.{4}, Culture={5}, {6}={7}",
GetString(rec.Name),
rec.MajorVersion,
rec.MinorVersion,
rec.BuildNumber,
rec.RevisionNumber,
rec.Culture == 0 ? "neutral"
(rec.Flags & PublicKey) == 0 ? "PublicKeyToken"
PublicKeyOrTokenToString(rec.PublicKeyOrToken));
return universe.Load(name, this.Assembly, true);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="519" endline="537">
private string PublicKeyOrTokenToString(int publicKeyOrToken)
{
if (publicKeyOrToken == 0)
{
return "null";
}
ByteReader br = GetBlob(publicKeyOrToken);
if (br.Length == 0)
{
return "null";
}
StringBuilder sb = new StringBuilder(br.Length * 2);
while (br.Length > 0)
{
sb.AppendFormat("{0
}
while (br.Length > 0)
{
sb.AppendFormat("{0
}
return sb.ToString();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="538" endline="546">
public override Guid ModuleVersionId
{
get
{
byte[] buf = new byte[16];
Buffer.BlockCopy(guidHeap, 16 * (ModuleTable.records[0].Mvid - 1), buf, 0, 16);
return new Guid(buf);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="562" endline="577">
}
internal override Type GetTypeImpl(string typeName)
{
PopulateTypeDef();
Type type;
if (!types.TryGetValue(typeName, out type))
{
LazyForwardedType fw;
if (forwardedTypes.TryGetValue(typeName, out fw))
{
return fw.GetType(this, typeName);
}
}
return type;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="578" endline="592">
public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
switch (metadataToken >> 24)
{
case FieldTable.Index
return ResolveField(metadataToken, genericTypeArguments, genericMethodArguments);
case MemberRefTable.Index
return GetMemberRef((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments);
case MethodDefTable.Index
case MethodSpecTable.Index
return ResolveMethod(metadataToken, genericTypeArguments, genericMethodArguments);
}
throw new ArgumentOutOfRangeException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="593" endline="605">
internal FieldInfo GetFieldAt(TypeDefImpl owner, int index)
{
if (fields == null)
{
fields = new FieldInfo[Field.records.Length];
}
if (fields[index] == null)
{
fields[index] = new FieldDefImpl(this, owner ?? FindFieldOwner(index), index);
}
return fields[index];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="606" endline="623">
public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
if ((metadataToken >> 24) == FieldTable.Index)
{
int index = (metadataToken & 0xFFFFFF) - 1;
return GetFieldAt(null, index);
}
else if ((metadataToken >> 24) == MemberRefTable.Index)
{
FieldInfo field = GetMemberRef((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments) as FieldInfo;
if (field != null)
{
return field;
}
}
throw new ArgumentOutOfRangeException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="624" endline="639">
private TypeDefImpl FindFieldOwner(int fieldIndex)
{
for (int i = 0; i < TypeDef.records.Length; i++)
{
int field = TypeDef.records[i].FieldList - 1;
int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1
if (field <= fieldIndex && fieldIndex < end)
{
PopulateTypeDef();
return typeDefs[i];
}
}
for (int i = 0; i < TypeDef.records.Length; i++)
{
int field = TypeDef.records[i].FieldList - 1;
int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1
if (field <= fieldIndex && fieldIndex < end)
{
PopulateTypeDef();
return typeDefs[i];
}
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="640" endline="653">
internal MethodBase GetMethodAt(TypeDefImpl owner, int index)
{
if (methods == null)
{
methods = new MethodBase[MethodDef.records.Length];
}
if (methods[index] == null)
{
MethodDefImpl method = new MethodDefImpl(this, owner ?? FindMethodOwner(index), index);
methods[index] = method.IsConstructor ? new ConstructorInfoImpl(method)
}
return methods[index];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="654" endline="701">
private sealed class GenericContext
{
private readonly Type[] genericTypeArguments;
private readonly Type[] genericMethodArguments;
internal GenericContext(Type[] genericTypeArguments, Type[] genericMethodArguments)
{
this.genericTypeArguments = genericTypeArguments;
this.genericMethodArguments = genericMethodArguments;
}
public Type GetGenericTypeArgument(int index)
{
return genericTypeArguments[index];
}
public Type GetGenericMethodArgument(int index)
{
return genericMethodArguments[index];
}
}
public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
if ((metadataToken >> 24) == MethodDefTable.Index)
{
int index = (metadataToken & 0xFFFFFF) - 1;
return GetMethodAt(null, index);
}
else if ((metadataToken >> 24) == MemberRefTable.Index)
{
int index = (metadataToken & 0xFFFFFF) - 1;
MethodBase method = GetMemberRef(index, genericTypeArguments, genericMethodArguments) as MethodBase;
if (method != null)
{
return method;
}
}
else if ((metadataToken >> 24) == MethodSpecTable.Index)
{
int index = (metadataToken & 0xFFFFFF) - 1;
MethodInfo method = (MethodInfo)ResolveMethod(MethodSpec.records[index].Method, genericTypeArguments, genericMethodArguments);
ByteReader instantiation = ByteReader.FromBlob(blobHeap, MethodSpec.records[index].Instantiation);
return method.MakeGenericMethod(Signature.ReadMethodSpec(this, instantiation, new GenericContext(genericTypeArguments, genericMethodArguments)));
}
throw new ArgumentOutOfRangeException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="702" endline="719">
public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
{
if ((metadataToken >> 24) == MemberRefTable.Index)
{
int index = (metadataToken & 0xFFFFFF) - 1;
int sig = MemberRef.records[index].Signature;
return Signature.ReadOptionalParameterTypes(this, GetBlob(sig));
}
else if ((metadataToken >> 24) == MethodDefTable.Index)
{
return Type.EmptyTypes;
}
throw new ArgumentOutOfRangeException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="724" endline="740">
}
private TypeDefImpl FindMethodOwner(int methodIndex)
{
for (int i = 0; i < TypeDef.records.Length; i++)
{
int method = TypeDef.records[i].MethodList - 1;
int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1
if (method <= methodIndex && methodIndex < end)
{
PopulateTypeDef();
return typeDefs[i];
}
}
for (int i = 0; i < TypeDef.records.Length; i++)
{
int method = TypeDef.records[i].MethodList - 1;
int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1
if (method <= methodIndex && methodIndex < end)
{
PopulateTypeDef();
return typeDefs[i];
}
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="741" endline="771">
private MemberInfo GetMemberRef(int index, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
if (memberRefs == null)
{
memberRefs = new MemberInfo[MemberRef.records.Length];
}
if (memberRefs[index] == null)
{
int owner = MemberRef.records[index].Class;
int sig = MemberRef.records[index].Signature;
string name = GetString(MemberRef.records[index].Name);
switch (owner >> 24)
{
case MethodDefTable.Index
return GetMethodAt(null, (owner & 0xFFFFFF) - 1);
case ModuleRefTable.Index
memberRefs[index] = ResolveTypeMemberRef(ResolveModuleType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
break;
case TypeDefTable.Index
case TypeRefTable.Index
memberRefs[index] = ResolveTypeMemberRef(ResolveType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
break;
case TypeSpecTable.Index
return ResolveTypeMemberRef(ResolveType(owner, genericTypeArguments, genericMethodArguments), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
default
throw new BadImageFormatException();
}
}
return memberRefs[index];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="772" endline="783">
private Type ResolveModuleType(int token)
{
int index = (token & 0xFFFFFF) - 1;
string name = GetString(ModuleRef.records[index]);
Module module = assembly.GetModule(name);
if (module == null || module.IsResource())
{
throw new BadImageFormatException();
}
return module.GetModuleType();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="784" endline="826">
private MemberInfo ResolveTypeMemberRef(Type type, string name, ByteReader sig, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
IGenericContext context;
if ((genericTypeArguments == null && genericMethodArguments == null) || type.IsGenericType)
{
context = type;
}
else
{
context = new GenericContext(genericTypeArguments, genericMethodArguments);
}
if (sig.PeekByte() == Signature.FIELD)
{
Type org = type;
FieldSignature fieldSig = FieldSignature.ReadSig(this, sig, context);
do
{
FieldInfo field = type.FindField(name, fieldSig);
if (field != null)
{
return field;
}
type = type.BaseType;
} while (type != null);
throw new MissingFieldException(org.ToString(), name);
}
else
{
Type org = type;
MethodSignature methodSig = MethodSignature.ReadSig(this, sig, context);
do
{
MethodBase method = type.FindMethod(name, methodSig);
if (method != null)
{
return method;
}
type = type.BaseType;
} while (type != null);
throw new MissingMethodException(org.ToString(), name);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="827" endline="836">
internal new ByteReader ResolveSignature(int metadataToken)
{
if ((metadataToken >> 24) == StandAloneSigTable.Index)
{
int index = (metadataToken & 0xFFFFFF) - 1;
return ByteReader.FromBlob(blobHeap, StandAloneSig.records[index]);
}
throw new ArgumentOutOfRangeException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="842" endline="850">
internal MethodInfo GetEntryPoint()
{
if (cliHeader.EntryPointToken != 0 && (cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) == 0)
{
return (MethodInfo)ResolveMethod((int)cliHeader.EntryPointToken);
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="851" endline="860">
internal string[] GetManifestResourceNames()
{
string[] names = new string[ManifestResource.records.Length];
for (int i = 0; i < ManifestResource.records.Length; i++)
{
names[i] = GetString(ManifestResource.records[i].Name);
}
for (int i = 0; i < ManifestResource.records.Length; i++)
{
names[i] = GetString(ManifestResource.records[i].Name);
}
return names;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="861" endline="872">
internal ManifestResourceInfo GetManifestResourceInfo(string resourceName)
{
for (int i = 0; i < ManifestResource.records.Length; i++)
{
if (resourceName == GetString(ManifestResource.records[i].Name))
{
return new ManifestResourceInfo(this, i);
}
}
for (int i = 0; i < ManifestResource.records.Length; i++)
{
if (resourceName == GetString(ManifestResource.records[i].Name))
{
return new ManifestResourceInfo(this, i);
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="873" endline="891">
internal Stream GetManifestResourceStream(string resourceName)
{
for (int i = 0; i < ManifestResource.records.Length; i++)
{
if (resourceName == GetString(ManifestResource.records[i].Name))
{
if (ManifestResource.records[i].Implementation != 0x26000000)
{
throw new NotImplementedException();
}
SeekRVA((int)cliHeader.ResourcesRVA + ManifestResource.records[i].Offset);
BinaryReader br = new BinaryReader(stream);
int length = br.ReadInt32();
return new MemoryStream(br.ReadBytes(length));
}
}
for (int i = 0; i < ManifestResource.records.Length; i++)
{
if (resourceName == GetString(ManifestResource.records[i].Name))
{
if (ManifestResource.records[i].Implementation != 0x26000000)
{
throw new NotImplementedException();
}
SeekRVA((int)cliHeader.ResourcesRVA + ManifestResource.records[i].Offset);
BinaryReader br = new BinaryReader(stream);
int length = br.ReadInt32();
return new MemoryStream(br.ReadBytes(length));
}
}
throw new FileNotFoundException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="892" endline="930">
public override AssemblyName[] __GetReferencedAssemblies()
{
List<AssemblyName> list = new List<AssemblyName>();
for (int i = 0; i < AssemblyRef.records.Length; i++)
{
AssemblyName name = new AssemblyName();
name.Name = GetString(AssemblyRef.records[i].Name);
name.Version = new Version(
AssemblyRef.records[i].MajorVersion,
AssemblyRef.records[i].MinorVersion,
AssemblyRef.records[i].BuildNumber,
AssemblyRef.records[i].RevisionNumber);
if (AssemblyRef.records[i].PublicKeyOrToken != 0)
{
byte[] keyOrToken = GetBlobCopy(AssemblyRef.records[i].PublicKeyOrToken);
const int PublicKey = 0x0001;
if ((AssemblyRef.records[i].Flags & PublicKey) != 0)
{
name.SetPublicKey(keyOrToken);
}
else
{
name.SetPublicKeyToken(keyOrToken);
}
}
if (AssemblyRef.records[i].Culture != 0)
{
name.CultureInfo = new System.Globalization.CultureInfo(GetString(AssemblyRef.records[i].Culture));
}
else
{
name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
}
name.Flags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
list.Add(name);
}
for (int i = 0; i < AssemblyRef.records.Length; i++)
{
AssemblyName name = new AssemblyName();
name.Name = GetString(AssemblyRef.records[i].Name);
name.Version = new Version(
AssemblyRef.records[i].MajorVersion,
AssemblyRef.records[i].MinorVersion,
AssemblyRef.records[i].BuildNumber,
AssemblyRef.records[i].RevisionNumber);
if (AssemblyRef.records[i].PublicKeyOrToken != 0)
{
byte[] keyOrToken = GetBlobCopy(AssemblyRef.records[i].PublicKeyOrToken);
const int PublicKey = 0x0001;
if ((AssemblyRef.records[i].Flags & PublicKey) != 0)
{
name.SetPublicKey(keyOrToken);
}
else
{
name.SetPublicKeyToken(keyOrToken);
}
}
if (AssemblyRef.records[i].Culture != 0)
{
name.CultureInfo = new System.Globalization.CultureInfo(GetString(AssemblyRef.records[i].Culture));
}
else
{
name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
}
name.Flags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
list.Add(name);
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="957" endline="975">
public override void GetPEKind(out PortableExecutableKinds peKind, out ImageFileMachine machine)
{
peKind = 0;
if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_ILONLY) != 0)
{
peKind |= PortableExecutableKinds.ILOnly;
}
if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_32BITREQUIRED) != 0)
{
peKind |= PortableExecutableKinds.Required32Bit;
}
if (peFile.OptionalHeader.Magic == IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC)
{
peKind |= PortableExecutableKinds.PE32Plus;
}
machine = (ImageFileMachine)peFile.FileHeader.Machine;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="980" endline="1015">
}
public override IList<CustomAttributeData> __GetPlaceholderAssemblyCustomAttributes(bool multiple, bool security)
{
string typeName;
switch ((multiple ? 1
{
case 0
typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHere";
break;
case 1
typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereM";
break;
case 2
typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereS";
break;
case 3
default
typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereSM";
break;
}
List<CustomAttributeData> list = new List<CustomAttributeData>();
for (int i = 0; i < CustomAttribute.records.Length; i++)
{
if ((CustomAttribute.records[i].Parent >> 24) == TypeRefTable.Index)
{
int index = (CustomAttribute.records[i].Parent & 0xFFFFFF) - 1;
if (typeName == GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName))
{
ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
}
}
}
for (int i = 0; i < CustomAttribute.records.Length; i++)
{
if ((CustomAttribute.records[i].Parent >> 24) == TypeRefTable.Index)
{
int index = (CustomAttribute.records[i].Parent & 0xFFFFFF) - 1;
if (typeName == GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName))
{
ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
}
}
}
return list;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="44" endline="51">
internal PropertyBuilder(TypeBuilder typeBuilder, string name, PropertyAttributes attributes, PropertySignature sig, bool patchCallingConvention)
{
this.typeBuilder = typeBuilder;
this.name = name;
this.attributes = attributes;
this.sig = sig;
this.patchCallingConvention = patchCallingConvention;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="56" endline="64">
}
private void PatchCallingConvention(MethodBuilder mdBuilder)
{
if (patchCallingConvention && !mdBuilder.IsStatic)
{
sig.HasThis = true;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="77" endline="86">
public void AddOtherMethod(MethodBuilder mdBuilder)
{
PatchCallingConvention(mdBuilder);
if (otherMethods == null)
{
otherMethods = new List<MethodBuilder>();
}
otherMethods.Add(mdBuilder);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="92" endline="108">
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
{
Universe u = typeBuilder.ModuleBuilder.universe;
if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
{
attributes |= PropertyAttributes.SpecialName;
}
else
{
if (lazyPseudoToken == 0)
{
lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
}
typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
public override object GetRawConstantValue()
{
if (lazyPseudoToken != 0)
{
return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="143" endline="157">
public override MethodInfo[] GetAccessors(bool nonPublic)
{
List<MethodInfo> list = new List<MethodInfo>();
AddAccessor(list, nonPublic, getter);
AddAccessor(list, nonPublic, setter);
if (otherMethods != null)
{
foreach (MethodInfo method in otherMethods)
{
AddAccessor(list, nonPublic, method);
}
foreach (MethodInfo method in otherMethods)
{
AddAccessor(list, nonPublic, method);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="158" endline="165">
private static void AddAccessor(List<MethodInfo> list, bool nonPublic, MethodInfo method)
{
if (method != null && (nonPublic || method.IsPublic))
{
list.Add(method);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="180" endline="190">
}
public void SetConstant(object defaultValue)
{
if (lazyPseudoToken == 0)
{
lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
}
attributes |= PropertyAttributes.HasDefault;
typeBuilder.ModuleBuilder.AddConstant(lazyPseudoToken, defaultValue);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="191" endline="220">
internal void Bake()
{
PropertyTable.Record rec = new PropertyTable.Record();
rec.Flags = (short)attributes;
rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
rec.Type = typeBuilder.ModuleBuilder.GetSignatureBlobIndex(sig);
int token = 0x17000000 | typeBuilder.ModuleBuilder.Property.AddRecord(rec);
if (lazyPseudoToken != 0)
{
typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
}
if (getter != null)
{
AddMethodSemantics(MethodSemanticsTable.Getter, getter.MetadataToken, token);
}
if (setter != null)
{
AddMethodSemantics(MethodSemanticsTable.Setter, setter.MetadataToken, token);
}
if (otherMethods != null)
{
foreach (MethodBuilder method in otherMethods)
{
AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
}
foreach (MethodBuilder method in otherMethods)
{
AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="221" endline="229">
private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
{
MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
rec.Semantics = semantics;
rec.Method = methodToken;
rec.Association = propertyToken;
typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="230" endline="250">
internal override bool IsPublic
{
get
{
if ((getter != null && getter.IsPublic) || (setter != null && setter.IsPublic))
{
return true;
}
if (otherMethods != null)
{
foreach (MethodBuilder method in otherMethods)
{
if (method.IsPublic)
{
return true;
}
}
foreach (MethodBuilder method in otherMethods)
{
if (method.IsPublic)
{
return true;
}
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="251" endline="272">
}
internal override bool IsStatic
{
get
{
if ((getter != null && getter.IsStatic) || (setter != null && setter.IsStatic))
{
return true;
}
if (otherMethods != null)
{
foreach (MethodBuilder method in otherMethods)
{
if (method.IsStatic)
{
return true;
}
}
foreach (MethodBuilder method in otherMethods)
{
if (method.IsStatic)
{
return true;
}
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" startline="40" endline="63">
public ResourceLocation ResourceLocation
{
get
{
int implementation = module.ManifestResource.records[index].Implementation;
if ((implementation >> 24) == AssemblyRefTable.Index)
{
throw new NotImplementedException();
}
else if ((implementation >> 24) == FileTable.Index)
{
if ((implementation & 0xFFFFFF) == 0)
{
return ResourceLocation.ContainedInManifestFile | ResourceLocation.Embedded;
}
return 0;
}
else
{
throw new BadImageFormatException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" startline="69" endline="88">
}
public string FileName
{
get
{
int implementation = module.ManifestResource.records[index].Implementation;
if ((implementation >> 24) == FileTable.Index)
{
if ((implementation & 0xFFFFFF) == 0)
{
return null;
}
else
{
return module.GetString(module.File.records[(implementation & 0xFFFFFF) - 1].Name);
}
}
throw new NotImplementedException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="53" endline="94">
internal void SetAttribute(CustomAttributeBuilder cab)
{
Universe u = cab.Constructor.Module.universe;
Type type = cab.Constructor.DeclaringType;
if (copyright == null && type == u.System_Reflection_AssemblyCopyrightAttribute)
{
copyright = (string)cab.GetConstructorArgument(0);
}
else if (trademark == null && type == u.System_Reflection_AssemblyTrademarkAttribute)
{
trademark = (string)cab.GetConstructorArgument(0);
}
else if (product == null && type == u.System_Reflection_AssemblyProductAttribute)
{
product = (string)cab.GetConstructorArgument(0);
}
else if (company == null && type == u.System_Reflection_AssemblyCompanyAttribute)
{
company = (string)cab.GetConstructorArgument(0);
}
else if (description == null && type == u.System_Reflection_AssemblyDescriptionAttribute)
{
description = (string)cab.GetConstructorArgument(0);
}
else if (title == null && type == u.System_Reflection_AssemblyTitleAttribute)
{
title = (string)cab.GetConstructorArgument(0);
}
else if (informationalVersion == null && type == u.System_Reflection_AssemblyInformationalVersionAttribute)
{
informationalVersion = (string)cab.GetConstructorArgument(0);
}
else if (culture == null && type == u.System_Reflection_AssemblyCultureAttribute)
{
culture  = (string)cab.GetConstructorArgument(0);
}
else if (fileVersion == null && type == u.System_Reflection_AssemblyFileVersionAttribute)
{
fileVersion = (string)cab.GetConstructorArgument(0);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="95" endline="217">
internal void Write(ByteBuffer bb)
{
if (fileVersion == null)
{
if (name.Version != null)
{
fileVersion = name.Version.ToString();
}
else
{
fileVersion = "0.0.0.0";
}
}
int codepage = 1200;	// Unicode codepage
int lcid = 0x7f;
if (name.CultureInfo != null)
{
lcid = name.CultureInfo.LCID;
}
if (culture != null)
{
lcid = new CultureInfo(culture).LCID;
}
Version filever = ParseVersionRobust(fileVersion);
int fileVersionMajor = filever.Major;
int fileVersionMinor = filever.Minor;
int fileVersionBuild = filever.Build;
int fileVersionRevision = filever.Revision;
int productVersionMajor = fileVersionMajor;
int productVersionMinor = fileVersionMinor;
int productVersionBuild = fileVersionBuild;
int productVersionRevision = fileVersionRevision;
if (informationalVersion != null)
{
Version productver = ParseVersionRobust(informationalVersion);
productVersionMajor = productver.Major;
productVersionMinor = productver.Minor;
productVersionBuild = productver.Build;
productVersionRevision = productver.Revision;
}
ByteBuffer stringTable = new ByteBuffer(512);
stringTable.Write((short)0);	// wLength (placeholder)
stringTable.Write((short)0);	// wValueLength
stringTable.Write((short)1);	// wType
WriteUTF16Z(stringTable, string.Format("{0
stringTable.Align(4);
WriteString(stringTable, "Comments", description);
WriteString(stringTable, "CompanyName", company);
WriteString(stringTable, "FileDescription", title);
WriteString(stringTable, "FileVersion", fileVersion);
WriteString(stringTable, "InternalName", name.Name);
WriteString(stringTable, "LegalCopyright", copyright);
WriteString(stringTable, "LegalTrademarks", trademark);
WriteString(stringTable, "OriginalFilename", fileName);
WriteString(stringTable, "ProductName", product);
WriteString(stringTable, "ProductVersion", informationalVersion);
stringTable.Position = 0;
stringTable.Write((short)stringTable.Length);
ByteBuffer stringFileInfo = new ByteBuffer(512);
stringFileInfo.Write((short)0);	// wLength (placeholder)
stringFileInfo.Write((short)0);	// wValueLength
stringFileInfo.Write((short)1);	// wType
WriteUTF16Z(stringFileInfo, "StringFileInfo");
stringFileInfo.Align(4);
stringFileInfo.Write(stringTable);
stringFileInfo.Position = 0;
stringFileInfo.Write((short)stringFileInfo.Length);
byte[] preamble1 = new byte[] {
0x34, 0x00,				// wValueLength
0x00, 0x00,				// wType
0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00, 0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00, 0x46, 0x00, 0x4F, 0x00, 0x00, 0x00,  // "VS_VERSION_INFO\0"
0x00, 0x00,				// Padding1 (32 bit alignment)
0xBD, 0x04, 0xEF, 0xFE,	// dwSignature (0xFEEF04BD)
0x00, 0x00, 0x01, 0x00,	// dwStrucVersion
};
byte[] preamble2 = new byte[] {
0x3F, 0x00, 0x00, 0x00,	// dwFileFlagsMask (??)
0x00, 0x00, 0x00, 0x00,	// dwFileFlags (??)
0x04, 0x00, 0x00, 0x00,	// dwFileOS
0x02, 0x00, 0x00, 0x00,	// dwFileType
0x00, 0x00, 0x00, 0x00,	// dwFileSubtype
0x00, 0x00, 0x00, 0x00,	// dwFileDateMS
0x00, 0x00, 0x00, 0x00,	// dwFileDateLS
0x44, 0x00,				// wLength
0x00, 0x00,				// wValueLength
0x01, 0x00,				// wType
0x56, 0x00, 0x61, 0x00, 0x72, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00,	// "VarFileInfo\0"
0x00, 0x00,				// Padding
0x24, 0x00,				// wLength
0x04, 0x00,				// wValueLength
0x00, 0x00,				// wType
0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00,	// "Translation\0"
0x00, 0x00,				// Padding (32 bit alignment)
};
bb.Write((short)(2 + preamble1.Length + 8 + 8 + preamble2.Length + 4 + stringFileInfo.Length));
bb.Write(preamble1);
bb.Write((short)fileVersionMinor);
bb.Write((short)fileVersionMajor);
bb.Write((short)fileVersionRevision);
bb.Write((short)fileVersionBuild);
bb.Write((short)productVersionMinor);
bb.Write((short)productVersionMajor);
bb.Write((short)productVersionRevision);
bb.Write((short)productVersionBuild);
bb.Write(preamble2);
bb.Write((short)lcid);
bb.Write((short)codepage);
bb.Write(stringFileInfo);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="218" endline="226">
private static void WriteUTF16Z(ByteBuffer bb, string str)
{
foreach (char c in str)
{
bb.Write((short)c);
}
foreach (char c in str)
{
bb.Write((short)c);
}
bb.Write((short)0);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="227" endline="243">
private static void WriteString(ByteBuffer bb, string name, string value)
{
value = value ?? " ";
int pos = bb.Position;
bb.Write((short)0);					// wLength (placeholder)
bb.Write((short)(value.Length + 1));// wValueLength
bb.Write((short)1);					// wType
WriteUTF16Z(bb, name);
bb.Align(4);
WriteUTF16Z(bb, value);
bb.Align(4);
int savedPos = bb.Position;
bb.Position = pos;
bb.Write((short)(savedPos - pos));
bb.Position = savedPos;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="244" endline="253">
private static Version ParseVersionRobust(string ver)
{
int index = 0;
ushort major = ParseVersionPart(ver, ref index);
ushort minor = ParseVersionPart(ver, ref index);
ushort build = ParseVersionPart(ver, ref index);
ushort revision = ParseVersionPart(ver, ref index);
return new Version(major, minor, build, revision);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="254" endline="278">
private static ushort ParseVersionPart(string str, ref int pos)
{
ushort value = 0;
while (pos < str.Length)
{
char c = str[pos];
if (c == '.')
{
pos++;
break;
}
else if (c >= '0' && c <= '9')
{
value *= 10;
value += (ushort)(c - '0');
pos++;
}
else
{
break;
}
}
while (pos < str.Length)
{
char c = str[pos];
if (c == '.')
{
pos++;
break;
}
else if (c >= '0' && c <= '9')
{
value *= 10;
value += (ushort)(c - '0');
pos++;
}
else
{
break;
}
}
return value;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ResourceModule.cs" startline="35" endline="41">
internal ResourceModule(Assembly assembly, string scopeName, string location)
{
this.assembly = assembly;
this.scopeName = scopeName;
this.location = location;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="36" endline="53">
private readonly List<Type> args = new List<Type>();
private readonly List<LocalBuilder> locals = new List<LocalBuilder>();
private readonly List<Type[]> requiredCustomModifiers = new List<Type[]>();
private readonly List<Type[]> optionalCustomModifiers = new List<Type[]>();
private readonly List<Type> optionalArgs = new List<Type>();
private Type returnType;
private Type[] returnTypeRequiredCustomModifiers;
private Type[] returnTypeOptionalCustomModifiers;
private CallingConventions callingConvention;
private CallingConvention unmanagedCallConv;
private bool unmanaged;
private bool optional;
private SignatureHelper(ModuleBuilder module, byte type)
{
this.module = module;
this.type = type;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="84" endline="96">
public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes)
{
SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, Signature.PROPERTY);
sig.returnType = returnType;
sig.returnTypeOptionalCustomModifiers = Type.EmptyTypes;
sig.returnTypeRequiredCustomModifiers = Type.EmptyTypes;
foreach (Type type in parameterTypes)
{
sig.AddArgument(type);
}
foreach (Type type in parameterTypes)
{
sig.AddArgument(type);
}
return sig;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="102" endline="112">
public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
{
SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, Signature.PROPERTY);
sig.callingConvention = callingConvention;
sig.returnType = returnType;
sig.returnTypeOptionalCustomModifiers = requiredReturnTypeCustomModifiers;
sig.returnTypeRequiredCustomModifiers = optionalReturnTypeCustomModifiers;
sig.AddArguments(parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers);
return sig;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="123" endline="131">
public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType)
{
SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
sig.returnType = returnType;
sig.unmanaged = true;
sig.unmanagedCallConv = unmanagedCallConv;
return sig;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
{
SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
sig.returnType = returnType;
sig.callingConvention = callingConvention;
return sig;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="140" endline="151">
public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes)
{
SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
sig.returnType = returnType;
sig.callingConvention = CallingConventions.Standard;
foreach (Type type in parameterTypes)
{
sig.AddArgument(type);
}
foreach (Type type in parameterTypes)
{
sig.AddArgument(type);
}
return sig;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="152" endline="160">
public byte[] GetSignature()
{
if (module == null)
{
throw new NotSupportedException();
}
return GetSignature(module).ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
internal ByteBuffer GetSignature(ModuleBuilder module)
{
ByteBuffer bb = new ByteBuffer(16);
switch (type)
{
case 0
if (unmanaged)
{
Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
}
else
{
Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
}
break;
case Signature.FIELD
FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
break;
case Signature.PROPERTY
Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
break;
case Signature.LOCAL_SIG
Signature.WriteLocalVarSig(module, bb, locals);
break;
default
throw new InvalidOperationException();
}
return bb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="212" endline="229">
private void AddArgument(Type argument, bool pinned, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
{
if (type == Signature.LOCAL_SIG)
{
locals.Add(new LocalBuilder(argument, 0, pinned));
}
else if (optional)
{
this.optionalArgs.Add(argument);
}
else
{
this.args.Add(argument);
this.requiredCustomModifiers.Add(requiredCustomModifiers);
this.optionalCustomModifiers.Add(optionalCustomModifiers);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="230" endline="237">
public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
{
for (int i = 0; i < arguments.Length; i++)
{
AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
}
for (int i = 0; i < arguments.Length; i++)
{
AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1547" endline="1552">
protected ElementHolderType(Type elementType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
{
this.elementType = elementType;
this.requiredCustomModifiers = requiredCustomModifiers;
this.optionalCustomModifiers = optionalCustomModifiers;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1553" endline="1560">
protected bool EqualsHelper(ElementHolderType other)
{
return other != null
&& other.elementType.Equals(elementType)
&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers)
&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1600" endline="1609">
}
internal sealed override int GetModuleBuilderToken()
{
if (token == 0)
{
token = ((ModuleBuilder)elementType.Module).ImportType(this);
}
return token;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1610" endline="1621">
public sealed override bool ContainsGenericParameters
{
get
{
Type type = elementType;
while (type.HasElementType)
{
type = type.GetElementType();
}
while (type.HasElementType)
{
type = type.GetElementType();
}
return type.ContainsGenericParameters;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1622" endline="1636">
}
internal sealed override Type BindTypeParameters(IGenericBinder binder)
{
Type type = elementType.BindTypeParameters(binder);
Type[] req = BindArray(requiredCustomModifiers, binder);
Type[] opt = BindArray(optionalCustomModifiers, binder);
if (ReferenceEquals(type, elementType)
&& ReferenceEquals(req, requiredCustomModifiers)
&& ReferenceEquals(opt, optionalCustomModifiers))
{
return this;
}
return Wrap(type, req, opt);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1642" endline="1663">
private static Type[] BindArray(Type[] array, IGenericBinder binder)
{
if (array ==null || array.Length == 0)
{
return array;
}
Type[] result = array;
for (int i = 0; i < array.Length; i++)
{
Type type = array[i].BindTypeParameters(binder);
if (!ReferenceEquals(type, array[i]))
{
if (result == array)
{
result = (Type[])array.Clone();
}
result[i] = type;
}
}
for (int i = 0; i < array.Length; i++)
{
Type type = array[i].BindTypeParameters(binder);
if (!ReferenceEquals(type, array[i]))
{
if (result == array)
{
result = (Type[])array.Clone();
}
result[i] = type;
}
}
return result;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1669" endline="1680">
protected abstract string GetSuffix();
protected abstract Type Wrap(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
}
sealed class ArrayType
{
internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
{
return type.Module.CanonicalizeType(new ArrayType(type, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1690" endline="1699">
}
public override Type[] __GetDeclaredInterfaces()
{
return new Type[] {
this.Module.universe.Import(typeof(IList<>)).MakeGenericType(elementType),
this.Module.universe.Import(typeof(ICollection<>)).MakeGenericType(elementType),
this.Module.universe.Import(typeof(IEnumerable<>)).MakeGenericType(elementType)
};
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1700" endline="1716">
public override MethodBase[] __GetDeclaredMethods()
{
Type[] int32 = new Type[] { this.Module.universe.System_Int32 };
List<MethodBase> list = new List<MethodBase>();
list.Add(new BuiltinArrayMethod(this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, new Type[] { this.Module.universe.System_Int32, elementType }));
list.Add(new BuiltinArrayMethod(this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType(), int32));
list.Add(new BuiltinArrayMethod(this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, int32));
list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
for (Type type = elementType; type.__IsVector; type = type.GetElementType())
{
Array.Resize(ref int32, int32.Length + 1);
int32[int32.Length - 1] = int32[0];
list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
}
for (Type type = elementType; type.__IsVector; type = type.GetElementType())
{
Array.Resize(ref int32, int32.Length + 1);
int32[int32.Length - 1] = int32[0];
list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1757" endline="1766">
}
sealed class MultiArrayType
{
private readonly int rank;
internal static Type Make(Type type, int rank, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
{
return type.Module.CanonicalizeType(new MultiArrayType(type, rank, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1777" endline="1800">
}
public override MethodBase[] __GetDeclaredMethods()
{
Type int32 = this.Module.universe.System_Int32;
Type[] setArgs = new Type[rank + 1];
Type[] getArgs = new Type[rank];
Type[] ctorArgs = new Type[rank * 2];
for (int i = 0; i < rank; i++)
{
setArgs[i] = int32;
getArgs[i] = int32;
ctorArgs[i * 2 + 0] = int32;
ctorArgs[i * 2 + 1] = int32;
}
for (int i = 0; i < rank; i++)
{
setArgs[i] = int32;
getArgs[i] = int32;
ctorArgs[i * 2 + 0] = int32;
ctorArgs[i * 2 + 1] = int32;
}
setArgs[rank] = elementType;
return new MethodBase[] {
new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, getArgs)),
new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, ctorArgs)),
new BuiltinArrayMethod(this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, setArgs),
new BuiltinArrayMethod(this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType(), getArgs),
new BuiltinArrayMethod(this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, getArgs),
};
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1827" endline="1838">
protected override string GetSuffix()
{
if (rank == 1)
{
return "[*]";
}
else
{
return "[" + new String(',', rank - 1) + "]";
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1276" endline="1284">
internal ArrayMethod(Module module, Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
{
this.module = module;
this.arrayClass = arrayClass;
this.methodName = methodName;
this.callingConvention = callingConvention;
this.returnType = returnType ?? module.universe.System_Void;
this.parameterTypes = Util.Copy(parameterTypes);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1319" endline="1330">
}
internal override MethodSignature MethodSignature
{
get
{
if (methodSignature == null)
{
methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, null, callingConvention, 0);
}
return methodSignature;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1872" endline="1881">
public override ParameterInfo[] GetParameters()
{
ParameterInfo[] parameterInfos = new ParameterInfo[parameterTypes.Length];
for (int i = 0; i < parameterInfos.Length; i++)
{
parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
}
for (int i = 0; i < parameterInfos.Length; i++)
{
parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
}
return parameterInfos;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1886" endline="1958">
}
private sealed class ParameterInfoImpl
{
private readonly MethodInfo method;
private readonly Type type;
private readonly int pos;
internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
{
this.method = method;
this.type = type;
this.pos = pos;
}
public override Type ParameterType
{
get { return type; }
}
public override string Name
{
get { return null; }
}
public override ParameterAttributes Attributes
{
get { return ParameterAttributes.None; }
}
public override int Position
{
get { return pos; }
}
public override object RawDefaultValue
{
get { return null; }
}
public override Type[] GetOptionalCustomModifiers()
{
return Empty<Type>.Array;
}
public override Type[] GetRequiredCustomModifiers()
{
return Empty<Type>.Array;
}
public override MemberInfo Member
{
get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method)
}
public override int MetadataToken
{
get { return 0x8000000; }
}
internal override Module Module
{
get { return method.Module; }
}
}
}
sealed class ByRefType
{
internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
{
return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1999" endline="2006">
}
sealed class PointerType
{
internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
{
return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2047" endline="2088">
}
sealed class GenericTypeInstance
{
private readonly Type type;
private readonly Type[] args;
private readonly Type[][] requiredCustomModifiers;
private readonly Type[][] optionalCustomModifiers;
private Type baseType;
private int token;
internal static Type Make(Type type, Type[] typeArguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
{
bool identity = true;
if (type is TypeBuilder || type is BakedType)
{
identity = false;
}
else
{
for (int i = 0; i < typeArguments.Length; i++)
{
if (typeArguments[i] != type.GetGenericTypeArgument(i)
|| !IsEmpty(requiredCustomModifiers, i)
|| !IsEmpty(optionalCustomModifiers, i))
{
identity = false;
break;
}
}
for (int i = 0; i < typeArguments.Length; i++)
{
if (typeArguments[i] != type.GetGenericTypeArgument(i)
|| !IsEmpty(requiredCustomModifiers, i)
|| !IsEmpty(optionalCustomModifiers, i))
{
identity = false;
break;
}
}
}
if (identity)
{
return type;
}
else
{
return type.Module.CanonicalizeType(new GenericTypeInstance(type, typeArguments, requiredCustomModifiers, optionalCustomModifiers));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2096" endline="2103">
private GenericTypeInstance(Type type, Type[] args, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
{
this.type = type;
this.args = args;
this.requiredCustomModifiers = requiredCustomModifiers;
this.optionalCustomModifiers = optionalCustomModifiers;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2104" endline="2111">
public override bool Equals(object o)
{
GenericTypeInstance gt = o as GenericTypeInstance;
return gt != null && gt.type.Equals(type) && Util.ArrayEquals(gt.args, args)
&& Util.ArrayEquals(gt.requiredCustomModifiers, requiredCustomModifiers)
&& Util.ArrayEquals(gt.optionalCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2117" endline="2124">
public override string AssemblyQualifiedName
{
get
{
string fn = FullName;
return fn == null ? null
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2125" endline="2144">
}
public override Type BaseType
{
get
{
if (baseType == null)
{
Type rawBaseType = type.BaseType;
if (rawBaseType == null)
{
baseType = rawBaseType;
}
else
{
baseType = rawBaseType.BindTypeParameters(this);
}
}
return baseType;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2150" endline="2168">
}
public override bool IsVisible
{
get
{
if (base.IsVisible)
{
foreach (Type arg in args)
{
if (!arg.IsVisible)
{
return false;
}
}
foreach (Type arg in args)
{
if (!arg.IsVisible)
{
return false;
}
}
return true;
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2185" endline="2194">
public override FieldInfo[] __GetDeclaredFields()
{
FieldInfo[] fields = type.__GetDeclaredFields();
for (int i = 0; i < fields.Length; i++)
{
fields[i] = fields[i].BindTypeParameters(this);
}
for (int i = 0; i < fields.Length; i++)
{
fields[i] = fields[i].BindTypeParameters(this);
}
return fields;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2195" endline="2204">
public override Type[] __GetDeclaredInterfaces()
{
Type[] interfaces = type.__GetDeclaredInterfaces();
for (int i = 0; i < interfaces.Length; i++)
{
interfaces[i] = interfaces[i].BindTypeParameters(this);
}
for (int i = 0; i < interfaces.Length; i++)
{
interfaces[i] = interfaces[i].BindTypeParameters(this);
}
return interfaces;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2205" endline="2214">
public override MethodBase[] __GetDeclaredMethods()
{
MethodBase[] methods = type.__GetDeclaredMethods();
for (int i = 0; i < methods.Length; i++)
{
methods[i] = methods[i].BindTypeParameters(this);
}
for (int i = 0; i < methods.Length; i++)
{
methods[i] = methods[i].BindTypeParameters(this);
}
return methods;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2220" endline="2229">
public override EventInfo[] __GetDeclaredEvents()
{
EventInfo[] events = type.__GetDeclaredEvents();
for (int i = 0; i < events.Length; i++)
{
events[i] = events[i].BindTypeParameters(this);
}
for (int i = 0; i < events.Length; i++)
{
events[i] = events[i].BindTypeParameters(this);
}
return events;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2230" endline="2239">
public override PropertyInfo[] __GetDeclaredProperties()
{
PropertyInfo[] properties = type.__GetDeclaredProperties();
for (int i = 0; i < properties.Length; i++)
{
properties[i] = properties[i].BindTypeParameters(this);
}
for (int i = 0; i < properties.Length; i++)
{
properties[i] = properties[i].BindTypeParameters(this);
}
return properties;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2240" endline="2258">
public override __MethodImplMap __GetMethodImplMap()
{
__MethodImplMap map = type.__GetMethodImplMap();
map.TargetType = this;
for (int i = 0; i < map.MethodBodies.Length; i++)
{
map.MethodBodies[i] = (MethodInfo)map.MethodBodies[i].BindTypeParameters(this);
for (int j = 0; j < map.MethodDeclarations[i].Length; j++)
{
Type interfaceType = map.MethodDeclarations[i][j].DeclaringType;
if (interfaceType.IsGenericType)
{
map.MethodDeclarations[i][j] = (MethodInfo)map.MethodDeclarations[i][j].BindTypeParameters(this);
}
}
for (int j = 0; j < map.MethodDeclarations[i].Length; j++)
{
Type interfaceType = map.MethodDeclarations[i][j].DeclaringType;
if (interfaceType.IsGenericType)
{
map.MethodDeclarations[i][j] = (MethodInfo)map.MethodDeclarations[i][j].BindTypeParameters(this);
}
}
}
for (int i = 0; i < map.MethodBodies.Length; i++)
{
map.MethodBodies[i] = (MethodInfo)map.MethodBodies[i].BindTypeParameters(this);
for (int j = 0; j < map.MethodDeclarations[i].Length; j++)
{
Type interfaceType = map.MethodDeclarations[i][j].DeclaringType;
if (interfaceType.IsGenericType)
{
map.MethodDeclarations[i][j] = (MethodInfo)map.MethodDeclarations[i][j].BindTypeParameters(this);
}
}
}
return map;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2273" endline="2291">
}
public override string FullName
{
get
{
if (this.ContainsGenericParameters)
{
return null;
}
StringBuilder sb = new StringBuilder(base.FullName);
sb.Append('[');
foreach (Type type in args)
{
sb.Append('[').Append(type.AssemblyQualifiedName.Replace("]", "\\]")).Append(']');
}
foreach (Type type in args)
{
sb.Append('[').Append(type.AssemblyQualifiedName.Replace("]", "\\]")).Append(']');
}
sb.Append(']');
return sb.ToString();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2292" endline="2307">
}
public override string ToString()
{
StringBuilder sb = new StringBuilder(type.FullName);
sb.Append('[');
string sep = "";
foreach (Type arg in args)
{
sb.Append(sep);
sb.Append(arg);
sep = ",";
}
foreach (Type arg in args)
{
sb.Append(sep);
sb.Append(arg);
sep = ",";
}
sb.Append(']');
return sb.ToString();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
public override bool ContainsGenericParameters
{
get
{
foreach (Type type in args)
{
if (type.ContainsGenericParameters)
{
return true;
}
}
foreach (Type type in args)
{
if (type.ContainsGenericParameters)
{
return true;
}
}
return false;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2362" endline="2371">
}
internal override int GetModuleBuilderToken()
{
if (token == 0)
{
token = ((ModuleBuilder)type.Module).ImportType(this);
}
return token;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2372" endline="2391">
internal override Type BindTypeParameters(IGenericBinder binder)
{
for (int i = 0; i < args.Length; i++)
{
Type xarg = args[i].BindTypeParameters(binder);
if (!ReferenceEquals(xarg, args[i]))
{
Type[] xargs = new Type[args.Length];
Array.Copy(args, xargs, i);
xargs[i++] = xarg;
for (; i < args.Length; i++)
{
xargs[i] = args[i].BindTypeParameters(binder);
}
for (; i < args.Length; i++)
{
xargs[i] = args[i].BindTypeParameters(binder);
}
return Make(type, xargs, null, null);
}
}
for (int i = 0; i < args.Length; i++)
{
Type xarg = args[i].BindTypeParameters(binder);
if (!ReferenceEquals(xarg, args[i]))
{
Type[] xargs = new Type[args.Length];
Array.Copy(args, xargs, i);
xargs[i++] = xarg;
for (; i < args.Length; i++)
{
xargs[i] = args[i].BindTypeParameters(binder);
}
return Make(type, xargs, null, null);
}
}
return this;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="51" endline="59">
}
private void CheckManifestModule()
{
if (!IsManifestModule)
{
throw new BadImageFormatException("Module does not contain a manifest");
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="71" endline="78">
public void Dispose()
{
if (!imported)
{
module.stream.Dispose();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="79" endline="88">
internal Assembly ToAssembly()
{
if (imported)
{
throw new InvalidOperationException();
}
imported = true;
return module.Assembly;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="89" endline="99">
internal Module ToModule(Assembly assembly)
{
if (module.Assembly != null)
{
throw new InvalidOperationException();
}
imported = true;
module.SetAssembly(assembly);
return module;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ExceptionHandlingClause.cs" startline="47" endline="56">
internal ExceptionHandlingClause(ModuleReader module, int flags, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int classTokenOrfilterOffset, IGenericContext context)
{
this.flags = flags;
this.tryOffset = tryOffset;
this.tryLength = tryLength;
this.handlerOffset = handlerOffset;
this.handlerLength = handlerLength;
this.catchType = flags == (int)ExceptionHandlingClauseOptions.Clause && classTokenOrfilterOffset != 0 ? module.ResolveType(classTokenOrfilterOffset, context)
this.filterOffset = flags == (int)ExceptionHandlingClauseOptions.Filter ? classTokenOrfilterOffset
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Impl\SymbolSupport.cs" startline="59" endline="78">
#else
if (runningOnMono)
{
#if MONO
return new MdbWriter(moduleBuilder);
#else
throw new NotSupportedException("IKVM.Reflection must be compiled with MONO defined to support writing Mono debugging symbols.");
#endif
}
else
{
return new PdbWriter(moduleBuilder);
}
#endif
}
internal static byte[] GetDebugInfo(ISymbolWriterImpl writer, ref IMAGE_DEBUG_DIRECTORY idd)
{
return writer.GetDebugInfo(ref idd);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="41" endline="46">
internal PropertyInfoImpl(ModuleReader module, Type declaringType, int index)
{
this.module = module;
this.declaringType = declaringType;
this.index = index;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="58" endline="68">
internal override PropertySignature PropertySignature
{
get
{
if (sig == null)
{
sig = PropertySignature.ReadSig(module, module.GetBlob(module.Property.records[index].Type), declaringType);
}
return sig;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
}
internal override bool IsPublic
{
get
{
if (!flagsCached)
{
ComputeFlags();
}
return isPublic;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="136" endline="147">
}
internal override bool IsStatic
{
get
{
if (!flagsCached)
{
ComputeFlags();
}
return isStatic;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="148" endline="154">
}
private void ComputeFlags()
{
module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
flagsCached = true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="59" endline="147">
}
}
public enum AssemblyComparisonResult
{
Unknown = 0,
EquivalentFullMatch = 1,
EquivalentWeakNamed = 2,
EquivalentFXUnified = 3,
EquivalentUnified = 4,
NonEquivalentVersion = 5,
NonEquivalent = 6,
EquivalentPartialMatch = 7,
EquivalentPartialWeakNamed = 8,
EquivalentPartialUnified = 9,
EquivalentPartialFXUnified = 10,
NonEquivalentPartialVersion = 11,
}
public delegate Assembly ResolveEventHandler(object sender, ResolveEventArgs args);
public sealed class Universe
{
internal readonly Dictionary<Type, Type> canonicalizedTypes = new Dictionary<Type, Type>();
private readonly List<Assembly> assemblies = new List<Assembly>();
private readonly List<AssemblyBuilder> dynamicAssemblies = new List<AssemblyBuilder>();
private readonly Dictionary<string, Assembly> assembliesByName = new Dictionary<string, Assembly>();
private readonly Dictionary<System.Type, Type> importedTypes = new Dictionary<System.Type, Type>();
private Type typeof_System_Object;
private Type typeof_System_ValueType;
private Type typeof_System_Enum;
private Type typeof_System_Void;
private Type typeof_System_Boolean;
private Type typeof_System_Char;
private Type typeof_System_SByte;
private Type typeof_System_Byte;
private Type typeof_System_Int16;
private Type typeof_System_UInt16;
private Type typeof_System_Int32;
private Type typeof_System_UInt32;
private Type typeof_System_Int64;
private Type typeof_System_UInt64;
private Type typeof_System_Single;
private Type typeof_System_Double;
private Type typeof_System_String;
private Type typeof_System_IntPtr;
private Type typeof_System_UIntPtr;
private Type typeof_System_TypedReference;
private Type typeof_System_Type;
private Type typeof_System_Array;
private Type typeof_System_DateTime;
private Type typeof_System_DBNull;
private Type typeof_System_Decimal;
private Type typeof_System_NonSerializedAttribute;
private Type typeof_System_SerializableAttribute;
private Type typeof_System_AttributeUsageAttribute;
private Type typeof_System_Reflection_AssemblyCultureAttribute;
private Type typeof_System_Runtime_InteropServices_DllImportAttribute;
private Type typeof_System_Runtime_InteropServices_FieldOffsetAttribute;
private Type typeof_System_Runtime_InteropServices_InAttribute;
private Type typeof_System_Runtime_InteropServices_MarshalAsAttribute;
private Type typeof_System_Runtime_InteropServices_UnmanagedType;
private Type typeof_System_Runtime_InteropServices_VarEnum;
private Type typeof_System_Runtime_InteropServices_OutAttribute;
private Type typeof_System_Runtime_InteropServices_StructLayoutAttribute;
private Type typeof_System_Runtime_InteropServices_OptionalAttribute;
private Type typeof_System_Runtime_InteropServices_PreserveSigAttribute;
private Type typeof_System_Runtime_InteropServices_ComImportAttribute;
private Type typeof_System_Runtime_CompilerServices_DecimalConstantAttribute;
private Type typeof_System_Runtime_CompilerServices_SpecialNameAttribute;
private Type typeof_System_Runtime_CompilerServices_MethodImplAttribute;
private Type typeof_System_Security_SuppressUnmanagedCodeSecurityAttribute;
private Type typeof_System_Reflection_AssemblyCopyrightAttribute;
private Type typeof_System_Reflection_AssemblyTrademarkAttribute;
private Type typeof_System_Reflection_AssemblyProductAttribute;
private Type typeof_System_Reflection_AssemblyCompanyAttribute;
private Type typeof_System_Reflection_AssemblyDescriptionAttribute;
private Type typeof_System_Reflection_AssemblyTitleAttribute;
private Type typeof_System_Reflection_AssemblyInformationalVersionAttribute;
private Type typeof_System_Reflection_AssemblyFileVersionAttribute;
private Type typeof_System_Security_Permissions_CodeAccessSecurityAttribute;
private Type typeof_System_Security_Permissions_HostProtectionAttribute;
private Type typeof_System_Security_Permissions_PermissionSetAttribute;
private Type typeof_System_Security_Permissions_SecurityAction;
private List<ResolveEventHandler> resolvers = new List<ResolveEventHandler>();
internal Assembly Mscorlib
{
get { return Load("mscorlib"); }
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="444" endline="458">
}
public Type Import(System.Type type)
{
Type imported;
if (!importedTypes.TryGetValue(type, out imported))
{
imported = ImportImpl(type);
if (imported != null)
{
importedTypes.Add(type, imported);
}
}
return imported;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="459" endline="517">
private Type ImportImpl(System.Type type)
{
if (type.Assembly == typeof(IKVM.Reflection.Type).Assembly)
{
throw new ArgumentException("Did you really want to import " + type.FullName + "?");
}
if (type.HasElementType)
{
if (type.IsArray)
{
if (type.Name.EndsWith("[]"))
{
return Import(type.GetElementType()).MakeArrayType();
}
else
{
return Import(type.GetElementType()).MakeArrayType(type.GetArrayRank());
}
}
else if (type.IsByRef)
{
return Import(type.GetElementType()).MakeByRefType();
}
else if (type.IsPointer)
{
return Import(type.GetElementType()).MakePointerType();
}
else
{
throw new InvalidOperationException();
}
}
else if (type.IsGenericParameter)
{
if (type.DeclaringMethod != null)
{
throw new NotImplementedException();
}
else
{
return Import(type.DeclaringType).GetGenericArguments()[type.GenericParameterPosition];
}
}
else if (type.IsGenericType && !type.IsGenericTypeDefinition)
{
System.Type[] args = type.GetGenericArguments();
Type[] importedArgs = new Type[args.Length];
for (int i = 0; i < args.Length; i++)
{
importedArgs[i] = Import(args[i]);
}
for (int i = 0; i < args.Length; i++)
{
importedArgs[i] = Import(args[i]);
}
return Import(type.GetGenericTypeDefinition()).MakeGenericType(importedArgs);
}
else
{
return Import(type.Assembly).GetType(type.FullName);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="529" endline="537">
public RawModule OpenRawModule(Stream stream, string location)
{
if (!stream.CanRead || !stream.CanSeek)
{
throw new NotSupportedException();
}
return new RawModule(new ModuleReader(null, this, stream, location));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="538" endline="549">
public Assembly LoadAssembly(RawModule module)
{
string refname = module.GetAssemblyName().FullName;
Assembly asm = GetLoadedAssembly(refname);
if (asm == null)
{
asm = module.ToAssembly();
assemblies.Add(asm);
}
return asm;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="550" endline="568">
public Assembly LoadFile(string path)
{
try
{
using (RawModule module = OpenRawModule(path))
{
return LoadAssembly(module);
}
}
catch (IOException x)
{
throw new FileNotFoundException(x.Message, x);
}
catch (UnauthorizedAccessException x)
{
throw new FileNotFoundException(x.Message, x);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="569" endline="589">
private Assembly GetLoadedAssembly(string refname)
{
Assembly asm;
if (!assembliesByName.TryGetValue(refname, out asm))
{
for (int i = 0; i < assemblies.Count; i++)
{
AssemblyComparisonResult result;
if (CompareAssemblyIdentity(refname, false, assemblies[i].FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
{
asm = assemblies[i];
assembliesByName.Add(refname, asm);
break;
}
}
for (int i = 0; i < assemblies.Count; i++)
{
AssemblyComparisonResult result;
if (CompareAssemblyIdentity(refname, false, assemblies[i].FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
{
asm = assemblies[i];
assembliesByName.Add(refname, asm);
break;
}
}
}
return asm;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="590" endline="604">
private Assembly GetDynamicAssembly(string refname)
{
foreach (AssemblyBuilder asm in dynamicAssemblies)
{
AssemblyComparisonResult result;
if (CompareAssemblyIdentity(refname, false, asm.FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
{
return asm;
}
}
foreach (AssemblyBuilder asm in dynamicAssemblies)
{
AssemblyComparisonResult result;
if (CompareAssemblyIdentity(refname, false, asm.FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
{
return asm;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="610" endline="652">
internal Assembly Load(string refname, Assembly requestingAssembly, bool throwOnError)
{
Assembly asm = GetLoadedAssembly(refname);
if (asm != null)
{
return asm;
}
if (resolvers.Count == 0)
{
asm = DefaultResolver(refname, throwOnError);
}
else
{
ResolveEventArgs args = new ResolveEventArgs(refname, requestingAssembly);
foreach (ResolveEventHandler evt in resolvers)
{
asm = evt(this, args);
if (asm != null)
{
break;
}
}
foreach (ResolveEventHandler evt in resolvers)
{
asm = evt(this, args);
if (asm != null)
{
break;
}
}
if (asm == null)
{
asm = GetDynamicAssembly(refname);
}
}
if (asm != null)
{
string defname = asm.FullName;
if (refname != defname)
{
assembliesByName.Add(refname, asm);
}
return asm;
}
if (throwOnError)
{
throw new FileNotFoundException(refname);
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="653" endline="691">
private Assembly DefaultResolver(string refname, bool throwOnError)
{
Assembly asm = GetDynamicAssembly(refname);
if (asm != null)
{
return asm;
}
string fileName;
if (throwOnError)
{
try
{
fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
}
catch (System.BadImageFormatException x)
{
throw new BadImageFormatException(x.Message, x);
}
}
else
{
try
{
fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
}
catch (System.BadImageFormatException x)
{
throw new BadImageFormatException(x.Message, x);
}
catch (FileNotFoundException)
{
return null;
}
}
return LoadFile(fileName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="706" endline="717">
public Type GetType(Assembly context, string assemblyQualifiedTypeName, bool throwOnError)
{
TypeNameParser parser = TypeNameParser.Parse(assemblyQualifiedTypeName, throwOnError);
if (parser.Error)
{
return null;
}
return parser.GetType(this, context, throwOnError, assemblyQualifiedTypeName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="718" endline="728">
public Assembly[] GetAssemblies()
{
Assembly[] array = new Assembly[assemblies.Count + dynamicAssemblies.Count];
assemblies.CopyTo(array);
for (int i = 0, j = assemblies.Count; j < array.Length; i++, j++)
{
array[j] = dynamicAssemblies[i];
}
for (int i = 0, j = assemblies.Count; j < array.Length; i++, j++)
{
array[j] = dynamicAssemblies[i];
}
return array;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="745" endline="752">
#if NET_4_0
[Obsolete]
#endif
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
{
return DefineDynamicAssemblyImpl(name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="753" endline="759">
private AssemblyBuilder DefineDynamicAssemblyImpl(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
{
AssemblyBuilder asm = new AssemblyBuilder(this, name, dir, requiredPermissions, optionalPermissions, refusedPermissions);
dynamicAssemblies.Add(asm);
return asm;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="760" endline="775">
internal void RenameAssembly(Assembly assembly, AssemblyName oldName)
{
List<string> remove = new List<string>();
foreach (KeyValuePair<string, Assembly> kv in assembliesByName)
{
if (kv.Value == assembly)
{
remove.Add(kv.Key);
}
}
foreach (KeyValuePair<string, Assembly> kv in assembliesByName)
{
if (kv.Value == assembly)
{
remove.Add(kv.Key);
}
}
foreach (string key in remove)
{
assembliesByName.Remove(key);
}
foreach (string key in remove)
{
assembliesByName.Remove(key);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="776" endline="793">
public void Dispose()
{
foreach (Assembly asm in assemblies)
{
foreach (Module mod in asm.GetLoadedModules())
{
mod.Dispose();
}
foreach (Module mod in asm.GetLoadedModules())
{
mod.Dispose();
}
}
foreach (Assembly asm in assemblies)
{
foreach (Module mod in asm.GetLoadedModules())
{
mod.Dispose();
}
}
foreach (AssemblyBuilder asm in dynamicAssemblies)
{
foreach (Module mod in asm.GetLoadedModules())
{
mod.Dispose();
}
foreach (Module mod in asm.GetLoadedModules())
{
mod.Dispose();
}
}
foreach (AssemblyBuilder asm in dynamicAssemblies)
{
foreach (Module mod in asm.GetLoadedModules())
{
mod.Dispose();
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="82" endline="143">
internal readonly Dictionary<Type, Type> canonicalizedTypes = new Dictionary<Type, Type>();
private readonly List<Assembly> assemblies = new List<Assembly>();
private readonly List<AssemblyBuilder> dynamicAssemblies = new List<AssemblyBuilder>();
private readonly Dictionary<string, Assembly> assembliesByName = new Dictionary<string, Assembly>();
private readonly Dictionary<System.Type, Type> importedTypes = new Dictionary<System.Type, Type>();
private Type typeof_System_Object;
private Type typeof_System_ValueType;
private Type typeof_System_Enum;
private Type typeof_System_Void;
private Type typeof_System_Boolean;
private Type typeof_System_Char;
private Type typeof_System_SByte;
private Type typeof_System_Byte;
private Type typeof_System_Int16;
private Type typeof_System_UInt16;
private Type typeof_System_Int32;
private Type typeof_System_UInt32;
private Type typeof_System_Int64;
private Type typeof_System_UInt64;
private Type typeof_System_Single;
private Type typeof_System_Double;
private Type typeof_System_String;
private Type typeof_System_IntPtr;
private Type typeof_System_UIntPtr;
private Type typeof_System_TypedReference;
private Type typeof_System_Type;
private Type typeof_System_Array;
private Type typeof_System_DateTime;
private Type typeof_System_DBNull;
private Type typeof_System_Decimal;
private Type typeof_System_NonSerializedAttribute;
private Type typeof_System_SerializableAttribute;
private Type typeof_System_AttributeUsageAttribute;
private Type typeof_System_Reflection_AssemblyCultureAttribute;
private Type typeof_System_Runtime_InteropServices_DllImportAttribute;
private Type typeof_System_Runtime_InteropServices_FieldOffsetAttribute;
private Type typeof_System_Runtime_InteropServices_InAttribute;
private Type typeof_System_Runtime_InteropServices_MarshalAsAttribute;
private Type typeof_System_Runtime_InteropServices_UnmanagedType;
private Type typeof_System_Runtime_InteropServices_VarEnum;
private Type typeof_System_Runtime_InteropServices_OutAttribute;
private Type typeof_System_Runtime_InteropServices_StructLayoutAttribute;
private Type typeof_System_Runtime_InteropServices_OptionalAttribute;
private Type typeof_System_Runtime_InteropServices_PreserveSigAttribute;
private Type typeof_System_Runtime_InteropServices_ComImportAttribute;
private Type typeof_System_Runtime_CompilerServices_DecimalConstantAttribute;
private Type typeof_System_Runtime_CompilerServices_SpecialNameAttribute;
private Type typeof_System_Runtime_CompilerServices_MethodImplAttribute;
private Type typeof_System_Security_SuppressUnmanagedCodeSecurityAttribute;
private Type typeof_System_Reflection_AssemblyCopyrightAttribute;
private Type typeof_System_Reflection_AssemblyTrademarkAttribute;
private Type typeof_System_Reflection_AssemblyProductAttribute;
private Type typeof_System_Reflection_AssemblyCompanyAttribute;
private Type typeof_System_Reflection_AssemblyDescriptionAttribute;
private Type typeof_System_Reflection_AssemblyTitleAttribute;
private Type typeof_System_Reflection_AssemblyInformationalVersionAttribute;
private Type typeof_System_Reflection_AssemblyFileVersionAttribute;
private Type typeof_System_Security_Permissions_CodeAccessSecurityAttribute;
private Type typeof_System_Security_Permissions_HostProtectionAttribute;
private Type typeof_System_Security_Permissions_PermissionSetAttribute;
private Type typeof_System_Security_Permissions_SecurityAction;
private List<ResolveEventHandler> resolvers = new List<ResolveEventHandler>();
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="48" endline="67">
internal CustomAttributeData(ConstructorInfo constructor, object[] args, List<CustomAttributeNamedArgument> namedArguments)
{
this.lazyConstructor = constructor;
MethodSignature sig = constructor.MethodSignature;
List<CustomAttributeTypedArgument> list = new List<CustomAttributeTypedArgument>();
for (int i = 0; i < args.Length; i++)
{
list.Add(new CustomAttributeTypedArgument(sig.GetParameterType(i), args[i]));
}
for (int i = 0; i < args.Length; i++)
{
list.Add(new CustomAttributeTypedArgument(sig.GetParameterType(i), args[i]));
}
lazyConstructorArguments = list.AsReadOnly();
if (namedArguments == null)
{
this.lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
}
else
{
this.lazyNamedArguments = namedArguments.AsReadOnly();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="68" endline="87">
internal CustomAttributeData(Assembly asm, ConstructorInfo constructor, ByteReader br)
{
this.lazyConstructor = constructor;
if (br.Length == 0)
{
lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
}
else
{
if (br.ReadUInt16() != 1)
{
throw new BadImageFormatException();
}
lazyConstructorArguments = ReadConstructorArguments(asm, br, constructor);
lazyNamedArguments = ReadNamedArguments(asm, br, br.ReadUInt16(), constructor.DeclaringType);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="88" endline="113">
public override string ToString()
{
StringBuilder sb = new StringBuilder();
sb.Append('[');
sb.Append(Constructor.DeclaringType.FullName);
sb.Append('(');
string sep = "";
foreach (CustomAttributeTypedArgument arg in ConstructorArguments)
{
sb.Append(sep);
sep = ", ";
AppendValue(sb, arg);
}
foreach (CustomAttributeTypedArgument arg in ConstructorArguments)
{
sb.Append(sep);
sep = ", ";
AppendValue(sb, arg);
}
foreach (CustomAttributeNamedArgument named in NamedArguments)
{
sb.Append(sep);
sep = ", ";
sb.Append(named.MemberInfo.Name);
sb.Append(" = ");
AppendValue(sb, named.TypedValue);
}
foreach (CustomAttributeNamedArgument named in NamedArguments)
{
sb.Append(sep);
sep = ", ";
sb.Append(named.MemberInfo.Name);
sb.Append(" = ");
AppendValue(sb, named.TypedValue);
}
sb.Append(')');
sb.Append(']');
return sb.ToString();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="114" endline="131">
private static void AppendValue(StringBuilder sb, CustomAttributeTypedArgument arg)
{
if (arg.ArgumentType == arg.ArgumentType.Module.universe.System_String)
{
sb.Append('"').Append(arg.Value).Append('"');
}
else
{
if (arg.ArgumentType.IsEnum)
{
sb.Append('(');
sb.Append(arg.ArgumentType.FullName);
sb.Append(')');
}
sb.Append(arg.Value);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="132" endline="173">
internal static void ReadDeclarativeSecurity(Assembly asm, List<CustomAttributeData> list, int action, ByteReader br)
{
Universe u = asm.universe;
if (br.PeekByte() == '.')
{
br.ReadByte();
int count = br.ReadCompressedInt();
for (int j = 0; j < count; j++)
{
Type type = ReadType(asm, br);
ConstructorInfo constructor;
if (type == u.System_Security_Permissions_HostProtectionAttribute && action == (int)System.Security.Permissions.SecurityAction.LinkDemand)
{
constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
}
else
{
constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { u.System_Security_Permissions_SecurityAction }, null);
}
ByteReader slice = br.Slice(br.ReadCompressedInt());
list.Add(new CustomAttributeData(constructor, action, ReadNamedArguments(asm, slice, slice.ReadCompressedInt(), type)));
}
for (int j = 0; j < count; j++)
{
Type type = ReadType(asm, br);
ConstructorInfo constructor;
if (type == u.System_Security_Permissions_HostProtectionAttribute && action == (int)System.Security.Permissions.SecurityAction.LinkDemand)
{
constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
}
else
{
constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { u.System_Security_Permissions_SecurityAction }, null);
}
ByteReader slice = br.Slice(br.ReadCompressedInt());
list.Add(new CustomAttributeData(constructor, action, ReadNamedArguments(asm, slice, slice.ReadCompressedInt(), type)));
}
}
else
{
char[] buf = new char[br.Length / 2];
for (int i = 0; i < buf.Length; i++)
{
buf[i] = br.ReadChar();
}
for (int i = 0; i < buf.Length; i++)
{
buf[i] = br.ReadChar();
}
string xml = new String(buf);
ConstructorInfo constructor = u.System_Security_Permissions_PermissionSetAttribute.GetConstructor(new Type[] { u.System_Security_Permissions_SecurityAction });
List<CustomAttributeNamedArgument> args = new List<CustomAttributeNamedArgument>();
args.Add(new CustomAttributeNamedArgument(u.System_Security_Permissions_PermissionSetAttribute.GetProperty("XML"),
new CustomAttributeTypedArgument(u.System_String, xml)));
list.Add(new CustomAttributeData(constructor, action, args));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="174" endline="183">
private CustomAttributeData(ConstructorInfo constructor, int securityAction, IList<CustomAttributeNamedArgument> namedArguments)
{
Universe u = constructor.Module.universe;
this.lazyConstructor = constructor;
List<CustomAttributeTypedArgument> list = new List<CustomAttributeTypedArgument>();
list.Add(new CustomAttributeTypedArgument(u.System_Security_Permissions_SecurityAction, securityAction));
this.lazyConstructorArguments =  list.AsReadOnly();
this.lazyNamedArguments = namedArguments;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="184" endline="227">
private static Type ReadFieldOrPropType(Assembly asm, ByteReader br)
{
Universe u = asm.universe;
switch (br.ReadByte())
{
case Signature.ELEMENT_TYPE_BOOLEAN
return u.System_Boolean;
case Signature.ELEMENT_TYPE_CHAR
return u.System_Char;
case Signature.ELEMENT_TYPE_I1
return u.System_SByte;
case Signature.ELEMENT_TYPE_U1
return u.System_Byte;
case Signature.ELEMENT_TYPE_I2
return u.System_Int16;
case Signature.ELEMENT_TYPE_U2
return u.System_UInt16;
case Signature.ELEMENT_TYPE_I4
return u.System_Int32;
case Signature.ELEMENT_TYPE_U4
return u.System_UInt32;
case Signature.ELEMENT_TYPE_I8
return u.System_Int64;
case Signature.ELEMENT_TYPE_U8
return u.System_UInt64;
case Signature.ELEMENT_TYPE_R4
return u.System_Single;
case Signature.ELEMENT_TYPE_R8
return u.System_Double;
case Signature.ELEMENT_TYPE_STRING
return u.System_String;
case Signature.ELEMENT_TYPE_SZARRAY
return ReadFieldOrPropType(asm, br).MakeArrayType();
case 0x55
return ReadType(asm, br);
case 0x50
return u.System_Type;
case 0x51
return u.System_Object;
default
throw new InvalidOperationException();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="228" endline="295">
private static CustomAttributeTypedArgument ReadFixedArg(Assembly asm, ByteReader br, Type type)
{
Universe u = asm.universe;
if (type == u.System_String)
{
return new CustomAttributeTypedArgument(type, br.ReadString());
}
else if (type == u.System_Type)
{
return new CustomAttributeTypedArgument(type, ReadType(asm, br));
}
else if (type == u.System_Object)
{
return ReadFixedArg(asm, br, ReadFieldOrPropType(asm, br));
}
else if (type.IsArray)
{
int length = br.ReadInt32();
if (length == -1)
{
return new CustomAttributeTypedArgument(type, null);
}
Type elementType = type.GetElementType();
CustomAttributeTypedArgument[] array = new CustomAttributeTypedArgument[length];
for (int i = 0; i < length; i++)
{
array[i] = ReadFixedArg(asm, br, elementType);
}
for (int i = 0; i < length; i++)
{
array[i] = ReadFixedArg(asm, br, elementType);
}
return new CustomAttributeTypedArgument(type, array);
}
else if (type.IsEnum)
{
return new CustomAttributeTypedArgument(type, ReadFixedArg(asm, br, type.GetEnumUnderlyingTypeImpl()).Value);
}
else
{
switch (Type.GetTypeCode(type))
{
case TypeCode.Boolean
return new CustomAttributeTypedArgument(type, br.ReadByte() != 0);
case TypeCode.Char
return new CustomAttributeTypedArgument(type, br.ReadChar());
case TypeCode.Single
return new CustomAttributeTypedArgument(type, br.ReadSingle());
case TypeCode.Double
return new CustomAttributeTypedArgument(type, br.ReadDouble());
case TypeCode.SByte
return new CustomAttributeTypedArgument(type, br.ReadSByte());
case TypeCode.Int16
return new CustomAttributeTypedArgument(type, br.ReadInt16());
case TypeCode.Int32
return new CustomAttributeTypedArgument(type, br.ReadInt32());
case TypeCode.Int64
return new CustomAttributeTypedArgument(type, br.ReadInt64());
case TypeCode.Byte
return new CustomAttributeTypedArgument(type, br.ReadByte());
case TypeCode.UInt16
return new CustomAttributeTypedArgument(type, br.ReadUInt16());
case TypeCode.UInt32
return new CustomAttributeTypedArgument(type, br.ReadUInt32());
case TypeCode.UInt64
return new CustomAttributeTypedArgument(type, br.ReadUInt64());
default
throw new InvalidOperationException();
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="296" endline="310">
private static Type ReadType(Assembly asm, ByteReader br)
{
string typeName = br.ReadString();
if (typeName == null)
{
return null;
}
if (typeName.Length > 0 && typeName[typeName.Length - 1] == 0)
{
typeName = typeName.Substring(0, typeName.Length - 1);
}
return asm.universe.GetType(asm, typeName, true);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="311" endline="322">
private static IList<CustomAttributeTypedArgument> ReadConstructorArguments(Assembly asm, ByteReader br, ConstructorInfo constructor)
{
MethodSignature sig = constructor.MethodSignature;
int count = sig.GetParameterCount();
List<CustomAttributeTypedArgument> list = new List<CustomAttributeTypedArgument>(count);
for (int i = 0; i < count; i++)
{
list.Add(ReadFixedArg(asm, br, sig.GetParameterType(i)));
}
for (int i = 0; i < count; i++)
{
list.Add(ReadFixedArg(asm, br, sig.GetParameterType(i)));
}
return list.AsReadOnly();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="323" endline="352">
private static IList<CustomAttributeNamedArgument> ReadNamedArguments(Assembly asm, ByteReader br, int named, Type type)
{
List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>(named);
for (int i = 0; i < named; i++)
{
byte fieldOrProperty = br.ReadByte();
Type fieldOrPropertyType = ReadFieldOrPropType(asm, br);
string name = br.ReadString();
CustomAttributeTypedArgument value = ReadFixedArg(asm, br, fieldOrPropertyType);
MemberInfo member;
switch (fieldOrProperty)
{
case 0x53
member = GetField(type, name);
break;
case 0x54
member = GetProperty(type, name);
break;
default
throw new BadImageFormatException();
}
if (member == null)
{
throw new BadImageFormatException();
}
list.Add(new CustomAttributeNamedArgument(member, value));
}
for (int i = 0; i < named; i++)
{
byte fieldOrProperty = br.ReadByte();
Type fieldOrPropertyType = ReadFieldOrPropType(asm, br);
string name = br.ReadString();
CustomAttributeTypedArgument value = ReadFixedArg(asm, br, fieldOrPropertyType);
MemberInfo member;
switch (fieldOrProperty)
{
case 0x53
member = GetField(type, name);
break;
case 0x54
member = GetProperty(type, name);
break;
default
throw new BadImageFormatException();
}
if (member == null)
{
throw new BadImageFormatException();
}
list.Add(new CustomAttributeNamedArgument(member, value));
}
return list.AsReadOnly();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="353" endline="367">
private static FieldInfo GetField(Type type, string name)
{
for (; type != null; type = type.BaseType)
{
foreach (FieldInfo field in type.__GetDeclaredFields())
{
if (field.IsPublic && !field.IsStatic && field.Name == name)
{
return field;
}
}
foreach (FieldInfo field in type.__GetDeclaredFields())
{
if (field.IsPublic && !field.IsStatic && field.Name == name)
{
return field;
}
}
}
for (; type != null; type = type.BaseType)
{
foreach (FieldInfo field in type.__GetDeclaredFields())
{
if (field.IsPublic && !field.IsStatic && field.Name == name)
{
return field;
}
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="368" endline="382">
private static PropertyInfo GetProperty(Type type, string name)
{
for (; type != null; type = type.BaseType)
{
foreach (PropertyInfo property in type.__GetDeclaredProperties())
{
if (property.IsPublic && !property.IsStatic && property.Name == name)
{
return property;
}
}
foreach (PropertyInfo property in type.__GetDeclaredProperties())
{
if (property.IsPublic && !property.IsStatic && property.Name == name)
{
return property;
}
}
}
for (; type != null; type = type.BaseType)
{
foreach (PropertyInfo property in type.__GetDeclaredProperties())
{
if (property.IsPublic && !property.IsStatic && property.Name == name)
{
return property;
}
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="383" endline="409">
public void __ReadTypeName(out string ns, out string name)
{
if (lazyConstructor == null)
{
ModuleReader mod = module as ModuleReader;
if (mod != null)
{
int methodToken = mod.CustomAttribute.records[index].Type;
if ((methodToken >> 24) == MemberRefTable.Index)
{
int methodIndex = (methodToken & 0xFFFFFF) - 1;
int typeToken = mod.MemberRef.records[methodIndex].Class;
if ((typeToken >> 24) == TypeRefTable.Index)
{
int typeIndex = (typeToken & 0xFFFFFF) - 1;
int typeNameSpace = mod.TypeRef.records[typeIndex].TypeNameSpace;
ns = typeNameSpace == 0 ? null
name = mod.GetString(mod.TypeRef.records[typeIndex].TypeName);
return;
}
}
}
}
ns = Constructor.DeclaringType.Namespace;
name = Constructor.DeclaringType.Name;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="410" endline="420">
public ConstructorInfo Constructor
{
get
{
if (lazyConstructor == null)
{
lazyConstructor = (ConstructorInfo)module.ResolveMethod(module.CustomAttribute.records[index].Type);
}
return lazyConstructor;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="421" endline="432">
}
public IList<CustomAttributeTypedArgument> ConstructorArguments
{
get
{
if (lazyConstructorArguments == null)
{
LazyParseArguments();
}
return lazyConstructorArguments;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="433" endline="444">
}
public IList<CustomAttributeNamedArgument> NamedArguments
{
get
{
if (lazyNamedArguments == null)
{
LazyParseArguments();
}
return lazyNamedArguments;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="445" endline="465">
}
private void LazyParseArguments()
{
ByteReader br = module.GetBlob(module.CustomAttribute.records[index].Value);
if (br.Length == 0)
{
lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
}
else
{
if (br.ReadUInt16() != 1)
{
throw new BadImageFormatException();
}
lazyConstructorArguments = ReadConstructorArguments(module.Assembly, br, Constructor);
lazyNamedArguments = ReadNamedArguments(module.Assembly, br, br.ReadUInt16(), Constructor.DeclaringType);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="466" endline="492">
public CustomAttributeBuilder __ToBuilder()
{
object[] args = new object[ConstructorArguments.Count];
for (int i = 0; i < args.Length; i++)
{
args[i] = ConstructorArguments[i].Value;
}
for (int i = 0; i < args.Length; i++)
{
args[i] = ConstructorArguments[i].Value;
}
List<PropertyInfo> namedProperties = new List<PropertyInfo>();
List<object> propertyValues = new List<object>();
List<FieldInfo> namedFields = new List<FieldInfo>();
List<object> fieldValues = new List<object>();
foreach (CustomAttributeNamedArgument named in NamedArguments)
{
if (named.MemberInfo is PropertyInfo)
{
namedProperties.Add((PropertyInfo)named.MemberInfo);
propertyValues.Add(named.TypedValue.Value);
}
else
{
namedFields.Add((FieldInfo)named.MemberInfo);
fieldValues.Add(named.TypedValue.Value);
}
}
foreach (CustomAttributeNamedArgument named in NamedArguments)
{
if (named.MemberInfo is PropertyInfo)
{
namedProperties.Add((PropertyInfo)named.MemberInfo);
propertyValues.Add(named.TypedValue.Value);
}
else
{
namedFields.Add((FieldInfo)named.MemberInfo);
fieldValues.Add(named.TypedValue.Value);
}
}
return new CustomAttributeBuilder(Constructor, args, namedProperties.ToArray(), propertyValues.ToArray(), namedFields.ToArray(), fieldValues.ToArray());
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="528" endline="564">
public static IList<CustomAttributeData> __GetCustomAttributes(MemberInfo member, Type attributeType, bool inherit)
{
if (!inherit || !IsInheritableAttribute(attributeType))
{
return member.GetCustomAttributesData(attributeType);
}
List<CustomAttributeData> list = new List<CustomAttributeData>();
for (; ; )
{
list.AddRange(member.GetCustomAttributesData(attributeType));
Type type = member as Type;
if (type != null)
{
type = type.BaseType;
if (type == null)
{
return list;
}
member = type;
continue;
}
MethodInfo method = member as MethodInfo;
if (method != null)
{
MemberInfo prev = member;
method = method.GetBaseDefinition();
if (method == null || method == prev)
{
return list;
}
member = method;
continue;
}
return list;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="570" endline="581">
public static IList<CustomAttributeData> __GetDeclarativeSecurity(Type type)
{
if ((type.Attributes & TypeAttributes.HasSecurity) != 0)
{
return type.Module.GetDeclarativeSecurity(type.MetadataToken);
}
else
{
return EmptyList;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="582" endline="593">
public static IList<CustomAttributeData> __GetDeclarativeSecurity(MethodBase method)
{
if ((method.Attributes & MethodAttributes.HasSecurity) != 0)
{
return method.Module.GetDeclarativeSecurity(method.MetadataToken);
}
else
{
return EmptyList;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="594" endline="610">
private static bool IsInheritableAttribute(Type attribute)
{
Type attributeUsageAttribute = attribute.Module.universe.System_AttributeUsageAttribute;
IList<CustomAttributeData> attr = attribute.GetCustomAttributesData(attributeUsageAttribute);
if (attr.Count != 0)
{
foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
{
if (named.MemberInfo.Name == "Inherited")
{
return (bool)named.TypedValue.Value;
}
}
foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
{
if (named.MemberInfo.Name == "Inherited")
{
return (bool)named.TypedValue.Value;
}
}
}
return true;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="62" endline="71">
public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues, FieldInfo[] namedFields, object[] fieldValues)
{
this.con = con;
this.constructorArgs = constructorArgs;
this.namedProperties = namedProperties;
this.propertyValues = propertyValues;
this.namedFields = namedFields;
this.fieldValues = fieldValues;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="72" endline="368">
private sealed class BlobWriter
{
private readonly ModuleBuilder moduleBuilder;
private readonly CustomAttributeBuilder cab;
private readonly ByteBuffer bb;
internal BlobWriter(ModuleBuilder moduleBuilder, CustomAttributeBuilder cab, ByteBuffer bb)
{
this.moduleBuilder = moduleBuilder;
this.cab = cab;
this.bb = bb;
}
internal void WriteCustomAttributeBlob()
{
WriteUInt16(1);
ParameterInfo[] pi = cab.con.GetParameters();
for (int i = 0; i < pi.Length; i++)
{
WriteFixedArg(pi[i].ParameterType, cab.constructorArgs[i]);
}
WriteNamedArguments(false);
}
internal void WriteNamedArguments(bool forDeclSecurity)
{
int named = 0;
if (cab.namedFields != null)
{
named += cab.namedFields.Length;
}
if (cab.namedProperties != null)
{
named += cab.namedProperties.Length;
}
if (forDeclSecurity)
{
WritePackedLen(named);
}
else
{
WriteUInt16((ushort)named);
}
if (cab.namedFields != null)
{
for (int i = 0; i < cab.namedFields.Length; i++)
{
WriteNamedArg(0x53, cab.namedFields[i].FieldType, cab.namedFields[i].Name, cab.fieldValues[i]);
}
}
if (cab.namedProperties != null)
{
for (int i = 0; i < cab.namedProperties.Length; i++)
{
WriteNamedArg(0x54, cab.namedProperties[i].PropertyType, cab.namedProperties[i].Name, cab.propertyValues[i]);
}
}
}
private void WriteNamedArg(byte fieldOrProperty, Type type, string name, object value)
{
WriteByte(fieldOrProperty);
WriteFieldOrPropType(type);
WriteString(name);
WriteFixedArg(type, value);
}
private void WriteByte(byte value)
{
bb.Write(value);
}
private void WriteUInt16(ushort value)
{
bb.Write(value);
}
private void WriteInt32(int value)
{
bb.Write(value);
}
private void WriteFixedArg(Type type, object value)
{
Universe u = moduleBuilder.universe;
if (type == u.System_String)
{
WriteString((string)value);
}
else if (type == u.System_Type)
{
WriteTypeName((Type)value);
}
else if (type == u.System_Object)
{
if (value == null)
{
type = u.System_String;
}
else if (value is Type)
{
type = u.System_Type;
}
else
{
type = u.Import(value.GetType());
}
WriteFieldOrPropType(type);
WriteFixedArg(type, value);
}
else if (type.IsArray)
{
if (value == null)
{
WriteInt32(-1);
}
else
{
Array array = (Array)value;
Type elemType = type.GetElementType();
WriteInt32(array.Length);
foreach (object val in array)
{
WriteFixedArg(elemType, val);
}
}
}
else if (type.IsEnum)
{
WriteFixedArg(type.GetEnumUnderlyingTypeImpl(), value);
}
else
{
switch (Type.GetTypeCode(type))
{
case TypeCode.Boolean
WriteByte((bool)value ? (byte)1
break;
case TypeCode.Char
WriteUInt16((char)value);
break;
case TypeCode.SByte
WriteByte((byte)(sbyte)value);
break;
case TypeCode.Byte
WriteByte((byte)value);
break;
case TypeCode.Int16
WriteUInt16((ushort)(short)value);
break;
case TypeCode.UInt16
WriteUInt16((ushort)value);
break;
case TypeCode.Int32
WriteInt32((int)value);
break;
case TypeCode.UInt32
WriteInt32((int)(uint)value);
break;
case TypeCode.Int64
WriteInt64((long)value);
break;
case TypeCode.UInt64
WriteInt64((long)(ulong)value);
break;
case TypeCode.Single
WriteSingle((float)value);
break;
case TypeCode.Double
WriteDouble((double)value);
break;
default
throw new ArgumentException();
}
}
}
private void WriteInt64(long value)
{
bb.Write(value);
}
private void WriteSingle(float value)
{
bb.Write(value);
}
private void WriteDouble(double value)
{
bb.Write(value);
}
private void WriteTypeName(Type type)
{
string name = null;
if (type != null)
{
if (type.Assembly == moduleBuilder.Assembly)
{
name = type.FullName;
}
else
{
name = type.AssemblyQualifiedName;
}
}
WriteString(name);
}
private void WriteString(string val)
{
bb.Write(val);
}
private void WritePackedLen(int len)
{
bb.WriteCompressedInt(len);
}
private void WriteFieldOrPropType(Type type)
{
Universe u = type.Module.universe;
if (type == u.System_Type)
{
WriteByte(0x50);
}
else if (type == u.System_Object)
{
WriteByte(0x51);
}
else if (type.IsArray)
{
WriteByte(0x1D);
WriteFieldOrPropType(type.GetElementType());
}
else if (type.IsEnum)
{
WriteByte(0x55);
WriteTypeName(type);
}
else
{
switch (Type.GetTypeCode(type))
{
case TypeCode.Boolean
WriteByte(0x02);
break;
case TypeCode.Char
WriteByte(0x03);
break;
case TypeCode.SByte
WriteByte(0x04);
break;
case TypeCode.Byte
WriteByte(0x05);
break;
case TypeCode.Int16
WriteByte(0x06);
break;
case TypeCode.UInt16
WriteByte(0x07);
break;
case TypeCode.Int32
WriteByte(0x08);
break;
case TypeCode.UInt32
WriteByte(0x09);
break;
case TypeCode.Int64
WriteByte(0x0A);
break;
case TypeCode.UInt64
WriteByte(0x0B);
break;
case TypeCode.Single
WriteByte(0x0C);
break;
case TypeCode.Double
WriteByte(0x0D);
break;
case TypeCode.String
WriteByte(0x0E);
break;
default
throw new ArgumentException();
}
}
}
}
internal bool IsPseudoCustomAttribute
{
get { return con.DeclaringType.IsPseudoCustomAttribute; }
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="374" endline="389">
}
internal int WriteBlob(ModuleBuilder moduleBuilder)
{
ByteBuffer bb = new ByteBuffer(100);
if (blob != null)
{
bb.Write(blob);
}
else
{
BlobWriter bw = new BlobWriter(moduleBuilder, this, bb);
bw.WriteCustomAttributeBlob();
}
return moduleBuilder.Blobs.Add(bb);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="399" endline="425">
}
internal T? GetFieldValue<T>(string name) where T
{
object val = GetFieldValue(name);
if (val is T)
{
return (T)val;
}
else if (val != null)
{
if (typeof(T).IsEnum)
{
Debug.Assert(Enum.GetUnderlyingType(typeof(T)) == val.GetType());
return (T)Enum.ToObject(typeof(T), val);
}
else
{
Debug.Assert(Enum.GetUnderlyingType(val.GetType()) == typeof(T));
return (T)Convert.ChangeType(val, typeof(T));
}
}
else
{
return null;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="426" endline="440">
internal object GetFieldValue(string name)
{
if (namedFields != null)
{
for (int i = 0; i < namedFields.Length; i++)
{
if (namedFields[i].Name == name)
{
return fieldValues[i];
}
}
for (int i = 0; i < namedFields.Length; i++)
{
if (namedFields[i].Name == name)
{
return fieldValues[i];
}
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="447" endline="473">
internal CustomAttributeData ToData(Assembly asm)
{
if (blob != null)
{
return new CustomAttributeData(asm, con, new IKVM.Reflection.Reader.ByteReader(blob, 0, blob.Length));
}
else
{
List<CustomAttributeNamedArgument> namedArgs = new List<CustomAttributeNamedArgument>();
if (namedProperties != null)
{
for (int i = 0; i < namedProperties.Length; i++)
{
namedArgs.Add(new CustomAttributeNamedArgument(namedProperties[i], new CustomAttributeTypedArgument(namedProperties[i].PropertyType, propertyValues[i])));
}
for (int i = 0; i < namedProperties.Length; i++)
{
namedArgs.Add(new CustomAttributeNamedArgument(namedProperties[i], new CustomAttributeTypedArgument(namedProperties[i].PropertyType, propertyValues[i])));
}
}
if (namedFields != null)
{
for (int i = 0; i < namedFields.Length; i++)
{
namedArgs.Add(new CustomAttributeNamedArgument(namedFields[i], new CustomAttributeTypedArgument(namedFields[i].FieldType, fieldValues[i])));
}
for (int i = 0; i < namedFields.Length; i++)
{
namedArgs.Add(new CustomAttributeNamedArgument(namedFields[i], new CustomAttributeTypedArgument(namedFields[i].FieldType, fieldValues[i])));
}
}
return new CustomAttributeData(con, constructorArgs, namedArgs);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="478" endline="490">
}
internal CustomAttributeBuilder DecodeBlob(Assembly asm)
{
if (blob == null)
{
return this;
}
else
{
return ToData(asm).__ToBuilder();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="48" endline="58">
private PropertySignature(CallingConventions callingConvention, Type propertyType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeOptionalCustomModifiers, Type[][] parameterTypeRequiredCustomModifiers)
{
this.callingConvention = callingConvention;
this.propertyType = propertyType;
this.optionalCustomModifiers = optionalCustomModifiers;
this.requiredCustomModifiers = requiredCustomModifiers;
this.parameterTypes = parameterTypes;
this.parameterOptionalCustomModifiers = parameterTypeOptionalCustomModifiers;
this.parameterRequiredCustomModifiers = parameterTypeRequiredCustomModifiers;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="59" endline="67">
public override bool Equals(object obj)
{
PropertySignature other = obj as PropertySignature;
return other != null
&& other.propertyType.Equals(propertyType)
&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="77" endline="91">
}
internal bool HasThis
{
set
{
if (value)
{
callingConvention |= CallingConventions.HasThis;
}
else
{
callingConvention &= ~CallingConventions.HasThis;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="108" endline="119">
internal PropertySignature ExpandTypeParameters(Type declaringType)
{
return new PropertySignature(
callingConvention,
propertyType.BindTypeParameters(declaringType),
BindTypeParameters(declaringType, optionalCustomModifiers),
BindTypeParameters(declaringType, requiredCustomModifiers),
BindTypeParameters(declaringType, parameterTypes),
BindTypeParameters(declaringType, parameterOptionalCustomModifiers),
BindTypeParameters(declaringType, parameterRequiredCustomModifiers));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="120" endline="156">
internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
{
byte flags = PROPERTY;
if ((callingConvention & CallingConventions.HasThis) != 0)
{
flags |= HASTHIS;
}
if ((callingConvention & CallingConventions.ExplicitThis) != 0)
{
flags |= EXPLICITTHIS;
}
if ((callingConvention & CallingConventions.VarArgs) != 0)
{
flags |= VARARG;
}
bb.Write(flags);
bb.WriteCompressedInt(parameterTypes == null ? 0
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
WriteType(module, bb, propertyType);
if (parameterTypes != null)
{
for (int i = 0; i < parameterTypes.Length; i++)
{
if (parameterRequiredCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
}
if (parameterOptionalCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
}
WriteType(module, bb, parameterTypes[i]);
}
for (int i = 0; i < parameterTypes.Length; i++)
{
if (parameterRequiredCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
}
if (parameterOptionalCustomModifiers != null)
{
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
}
WriteType(module, bb, parameterTypes[i]);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="172" endline="216">
internal static PropertySignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
{
byte flags = br.ReadByte();
if ((flags & PROPERTY) == 0)
{
throw new BadImageFormatException();
}
CallingConventions callingConvention = CallingConventions.Standard;
if ((flags & HASTHIS) != 0)
{
callingConvention |= CallingConventions.HasThis;
}
if ((flags & EXPLICITTHIS) != 0)
{
callingConvention |= CallingConventions.ExplicitThis;
}
Type returnType;
Type[] returnTypeRequiredCustomModifiers;
Type[] returnTypeOptionalCustomModifiers;
Type[] parameterTypes;
Type[][] parameterRequiredCustomModifiers;
Type[][] parameterOptionalCustomModifiers;
int paramCount = br.ReadCompressedInt();
ReadCustomModifiers(module, br, context, out returnTypeRequiredCustomModifiers, out returnTypeOptionalCustomModifiers);
returnType = ReadRetType(module, br, context);
parameterTypes = new Type[paramCount];
parameterRequiredCustomModifiers = null;
parameterOptionalCustomModifiers = null;
for (int i = 0; i < parameterTypes.Length; i++)
{
if (IsCustomModifier(br.PeekByte()))
{
if (parameterOptionalCustomModifiers == null)
{
parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
}
ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
}
parameterTypes[i] = ReadParam(module, br, context);
}
for (int i = 0; i < parameterTypes.Length; i++)
{
if (IsCustomModifier(br.PeekByte()))
{
if (parameterOptionalCustomModifiers == null)
{
parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
}
ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
}
parameterTypes[i] = ReadParam(module, br, context);
}
return new PropertySignature(callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
parameterTypes, parameterOptionalCustomModifiers, parameterRequiredCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="41" endline="55">
}
public sealed override Type BaseType
{
get
{
foreach (Type type in GetGenericParameterConstraints())
{
if (!type.IsInterface && !type.IsGenericParameter)
{
return type;
}
}
foreach (Type type in GetGenericParameterConstraints())
{
if (!type.IsInterface && !type.IsGenericParameter)
{
return type;
}
}
return this.IsValueType ? this.Module.universe.System_ValueType
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="56" endline="69">
}
public override Type[] __GetDeclaredInterfaces()
{
List<Type> list = new List<Type>();
foreach (Type type in GetGenericParameterConstraints())
{
if (type.IsInterface)
{
list.Add(type);
}
}
foreach (Type type in GetGenericParameterConstraints())
{
if (type.IsInterface)
{
list.Add(type);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="207" endline="213">
}
}
internal static Type Make(int position)
{
return module.CanonicalizeType(new UnboundGenericMethodParameter(position));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="100" endline="291">
private readonly int position;
private sealed class DummyModule
{
internal DummyModule()
{
}
public override bool Equals(object obj)
{
throw new InvalidOperationException();
}
public override int GetHashCode()
{
throw new InvalidOperationException();
}
public override string ToString()
{
throw new InvalidOperationException();
}
public override int MDStreamVersion
{
get { throw new InvalidOperationException(); }
}
public override Assembly Assembly
{
get { throw new InvalidOperationException(); }
}
internal override Type GetTypeImpl(string typeName)
{
throw new InvalidOperationException();
}
internal override void GetTypesImpl(List<Type> list)
{
throw new InvalidOperationException();
}
public override string FullyQualifiedName
{
get { throw new InvalidOperationException(); }
}
public override string Name
{
get { throw new InvalidOperationException(); }
}
public override Guid ModuleVersionId
{
get { throw new InvalidOperationException(); }
}
public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
throw new InvalidOperationException();
}
public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
throw new InvalidOperationException();
}
public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
throw new InvalidOperationException();
}
public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
throw new InvalidOperationException();
}
public override string ResolveString(int metadataToken)
{
throw new InvalidOperationException();
}
public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
{
throw new InvalidOperationException();
}
public override string ScopeName
{
get { throw new InvalidOperationException(); }
}
public override AssemblyName[] __GetReferencedAssemblies()
{
throw new InvalidOperationException();
}
internal override Type GetModuleType()
{
throw new InvalidOperationException();
}
internal override ByteReader GetBlob(int blobIndex)
{
throw new InvalidOperationException();
}
}
internal static Type Make(int position)
{
return module.CanonicalizeType(new UnboundGenericMethodParameter(position));
}
private UnboundGenericMethodParameter(int position)
{
this.position = position;
}
public override bool Equals(object obj)
{
UnboundGenericMethodParameter other = obj as UnboundGenericMethodParameter;
return other != null && other.position == position;
}
public override int GetHashCode()
{
return position;
}
public override string Namespace
{
get { throw new InvalidOperationException(); }
}
public override string Name
{
get { throw new InvalidOperationException(); }
}
public override int MetadataToken
{
get { throw new InvalidOperationException(); }
}
public override Module Module
{
get { return module; }
}
public override int GenericParameterPosition
{
get { return position; }
}
public override Type DeclaringType
{
get { return null; }
}
public override MethodBase DeclaringMethod
{
get { throw new InvalidOperationException(); }
}
public override Type[] GetGenericParameterConstraints()
{
throw new InvalidOperationException();
}
public override GenericParameterAttributes GenericParameterAttributes
{
get { throw new InvalidOperationException(); }
}
internal override Type BindTypeParameters(IGenericBinder binder)
{
return binder.BindMethodParameter(this);
}
}
sealed class GenericTypeParameter
{
private readonly ModuleReader module;
private readonly int index;
internal GenericTypeParameter(ModuleReader module, int index)
{
this.module = module;
this.index = index;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="326" endline="334">
}
public override Type DeclaringType
{
get
{
int owner = module.GenericParam.records[index].Owner;
return (owner >> 24) == TypeDefTable.Index ? module.ResolveType(owner)
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="335" endline="343">
}
public override MethodBase DeclaringMethod
{
get
{
int owner = module.GenericParam.records[index].Owner;
return (owner >> 24) == MethodDefTable.Index ? module.ResolveMethod(owner)
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="344" endline="360">
}
public override Type[] GetGenericParameterConstraints()
{
IGenericContext context = (this.DeclaringMethod as IGenericContext) ?? this.DeclaringType;
List<Type> list = new List<Type>();
int token = this.MetadataToken;
for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
{
if (module.GenericParamConstraint.records[i].Owner == token)
{
list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
}
}
for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
{
if (module.GenericParamConstraint.records[i].Owner == token)
{
list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="365" endline="378">
}
internal override Type BindTypeParameters(IGenericBinder binder)
{
int owner = module.GenericParam.records[index].Owner;
if ((owner >> 24) == MethodDefTable.Index)
{
return binder.BindMethodParameter(this);
}
else
{
return binder.BindTypeParameter(this);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="39" endline="44">
internal FieldDefImpl(ModuleReader module, TypeDefImpl declaringType, int index)
{
this.module = module;
this.declaringType = declaringType;
this.index = index;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="80" endline="112">
public override void __GetDataFromRVA(byte[] data, int offset, int length)
{
int rid = index + 1;
for (int i = 0; i < module.FieldRVA.records.Length; i++)
{
if (module.FieldRVA.records[i].Field == rid)
{
int rva = module.FieldRVA.records[i].RVA;
if (rva == 0)
{
Array.Clear(data, offset, length);
return;
}
module.SeekRVA(rva);
while (length > 0)
{
int read = module.stream.Read(data, offset, length);
if (read == 0)
{
break;
}
offset += read;
length -= read;
}
while (length > 0)
{
int read = module.stream.Read(data, offset, length);
if (read == 0)
{
break;
}
offset += read;
length -= read;
}
return;
}
}
for (int i = 0; i < module.FieldRVA.records.Length; i++)
{
if (module.FieldRVA.records[i].Field == rid)
{
int rva = module.FieldRVA.records[i].RVA;
if (rva == 0)
{
Array.Clear(data, offset, length);
return;
}
module.SeekRVA(rva);
while (length > 0)
{
int read = module.stream.Read(data, offset, length);
if (read == 0)
{
break;
}
offset += read;
length -= read;
}
return;
}
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="113" endline="140">
internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
{
List<CustomAttributeData> list = module.GetCustomAttributes(this.MetadataToken, attributeType);
if ((this.Attributes & FieldAttributes.HasFieldMarshal) != 0
&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_MarshalAsAttribute)))
{
list.Add(MarshalSpec.GetMarshalAsAttribute(module, this.MetadataToken));
}
if (declaringType.IsExplicitLayout
&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_FieldOffsetAttribute)))
{
int rid = index + 1;
for (int i = 0; i < module.FieldLayout.records.Length; i++)
{
if (module.FieldLayout.records[i].Field == rid)
{
ConstructorInfo constructor = module.universe.System_Runtime_InteropServices_FieldOffsetAttribute.GetConstructor(new Type[] { module.universe.System_Int32 });
list.Add(new CustomAttributeData(constructor,
new object[] { module.FieldLayout.records[i].Offset },
null));
break;
}
}
for (int i = 0; i < module.FieldLayout.records.Length; i++)
{
if (module.FieldLayout.records[i].Field == rid)
{
ConstructorInfo constructor = module.universe.System_Runtime_InteropServices_FieldOffsetAttribute.GetConstructor(new Type[] { module.universe.System_Int32 });
list.Add(new CustomAttributeData(constructor,
new object[] { module.FieldLayout.records[i].Offset },
null));
break;
}
}
}
return list;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="73" endline="89">
}
public sealed class LocalBuilder
{
private readonly Type localType;
private readonly int index;
private readonly bool pinned;
internal string name;
internal int startOffset;
internal int endOffset;
internal LocalBuilder(Type localType, int index, bool pinned)
{
this.localType = localType;
this.index = index;
this.pinned = pinned;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="95" endline="101">
public void SetLocalSymInfo(string name, int startOffset, int endOffset)
{
this.name = name;
this.startOffset = startOffset;
this.endOffset = endOffset;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="124" endline="232">
private readonly List<LocalBuilder> locals = new List<LocalBuilder>();
private readonly List<int> tokenFixups = new List<int>();
private readonly List<int> labels = new List<int>();
private readonly List<int> labelStackHeight = new List<int>();
private readonly List<LabelFixup> labelFixups = new List<LabelFixup>();
private readonly List<SequencePoint> sequencePoints = new List<SequencePoint>();
private readonly List<ExceptionBlock> exceptions = new List<ExceptionBlock>();
private readonly Stack<ExceptionBlock> exceptionStack = new Stack<ExceptionBlock>();
private ushort maxStack;
private int stackHeight;
private Scope scope;
private byte exceptionBlockAssistanceMode = EBAM_COMPAT;
private const byte EBAM_COMPAT = 0;
private const byte EBAM_DISABLE = 1;
private const byte EBAM_CLEVER = 2;
private struct LabelFixup
{
internal int label;
internal int offset;
}
private sealed class ExceptionBlock
{
internal readonly int ordinal;
internal Label labelEnd;
internal int tryOffset;
internal int tryLength;
internal int handlerOffset;
internal int handlerLength;
internal Type exceptionType;	// null = finally block or handler with filter, FAULT = fault block
internal int filterOffset;
internal ExceptionBlock(int ordinal)
{
this.ordinal = ordinal;
}
int IComparer<ExceptionBlock>.Compare(ExceptionBlock x, ExceptionBlock y)
{
if (x == y)
{
return 0;
}
if (x.tryOffset >= y.handlerOffset && x.tryOffset + x.tryLength <= y.handlerOffset + y.handlerLength)
{
return -1;
}
if (y.tryOffset >= x.handlerOffset && y.tryOffset + y.tryLength <= x.handlerOffset + x.handlerLength)
{
return 1;
}
if (x.tryOffset == y.tryOffset && x.tryLength == y.tryLength)
{
return x.ordinal < y.ordinal ? -1
}
if (x.tryOffset + x.tryLength <= y.tryOffset)
{
return -1;
}
if (y.tryOffset + y.tryLength <= x.tryOffset)
{
return 1;
}
if (x.tryOffset > y.tryOffset || (x.tryOffset == y.tryOffset && x.tryLength < y.tryLength))
{
return -1;
}
else
{
return 1;
}
}
}
private struct SequencePoint
{
internal ISymbolDocumentWriter document;
internal int offset;
internal int startLine;
internal int startColumn;
internal int endLine;
internal int endColumn;
}
private sealed class Scope
{
internal readonly Scope parent;
internal readonly List<Scope> children = new List<Scope>();
internal readonly List<LocalBuilder> locals = new List<LocalBuilder>();
internal int startOffset;
internal int endOffset;
internal Scope(Scope parent)
{
this.parent = parent;
}
}
internal ILGenerator(ModuleBuilder moduleBuilder, int initialCapacity)
{
this.code = new ByteBuffer(initialCapacity);
this.moduleBuilder = moduleBuilder;
if (moduleBuilder.symbolWriter != null)
{
scope = new Scope(null);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="255" endline="291">
}
public void BeginCatchBlock(Type exceptionType)
{
ExceptionBlock block = exceptionStack.Peek();
if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
{
if (exceptionType == null)
{
Emit(OpCodes.Endfilter);
}
else
{
Emit(OpCodes.Leave, block.labelEnd);
}
}
stackHeight = 0;
UpdateStack(1);
if (block.tryLength == 0)
{
block.tryLength = code.Position - block.tryOffset;
}
else if (exceptionType != null)
{
block.handlerLength = code.Position - block.handlerOffset;
exceptionStack.Pop();
ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
newBlock.labelEnd = block.labelEnd;
newBlock.tryOffset = block.tryOffset;
newBlock.tryLength = block.tryLength;
block = newBlock;
exceptions.Add(block);
exceptionStack.Push(block);
}
block.handlerOffset = code.Position;
block.exceptionType = exceptionType;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="292" endline="302">
public Label BeginExceptionBlock()
{
ExceptionBlock block = new ExceptionBlock(exceptions.Count);
block.labelEnd = DefineLabel();
block.tryOffset = code.Position;
exceptionStack.Push(block);
exceptions.Add(block);
stackHeight = 0;
return block.labelEnd;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="303" endline="309">
public void BeginExceptFilterBlock()
{
ExceptionBlock block = BeginFinallyFilterFaultBlock();
block.filterOffset = code.Position;
UpdateStack(1);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="310" endline="316">
public void BeginFaultBlock()
{
ExceptionBlock block = BeginFinallyFilterFaultBlock();
block.handlerOffset = code.Position;
block.exceptionType = FAULT;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="323" endline="360">
private ExceptionBlock BeginFinallyFilterFaultBlock()
{
ExceptionBlock block = exceptionStack.Peek();
if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
{
Emit(OpCodes.Leave, block.labelEnd);
}
if (block.handlerOffset == 0)
{
block.tryLength = code.Position - block.tryOffset;
}
else
{
block.handlerLength = code.Position - block.handlerOffset;
Label labelEnd;
if (exceptionBlockAssistanceMode != EBAM_COMPAT)
{
labelEnd = block.labelEnd;
}
else
{
MarkLabel(block.labelEnd);
labelEnd = DefineLabel();
Emit(OpCodes.Leave, labelEnd);
}
exceptionStack.Pop();
ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
newBlock.labelEnd = labelEnd;
newBlock.tryOffset = block.tryOffset;
newBlock.tryLength = code.Position - block.tryOffset;
block = newBlock;
exceptions.Add(block);
exceptionStack.Push(block);
}
stackHeight = 0;
return block;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="361" endline="378">
public void EndExceptionBlock()
{
ExceptionBlock block = exceptionStack.Pop();
if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
{
if (block.filterOffset != 0 || (block.exceptionType != null && block.exceptionType != FAULT))
{
Emit(OpCodes.Leave, block.labelEnd);
}
else
{
Emit(OpCodes.Endfinally);
}
}
MarkLabel(block.labelEnd);
block.handlerLength = code.Position - block.handlerOffset;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="379" endline="386">
public void BeginScope()
{
Scope newScope = new Scope(scope);
scope.children.Add(newScope);
scope = newScope;
scope.startOffset = code.Position;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="387" endline="394">
public void UsingNamespace(string usingNamespace)
{
if (moduleBuilder.symbolWriter != null)
{
moduleBuilder.symbolWriter.UsingNamespace(usingNamespace);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="400" endline="410">
public LocalBuilder DeclareLocal(Type localType, bool pinned)
{
LocalBuilder local = new LocalBuilder(localType, locals.Count, pinned);
locals.Add(local);
if (scope != null)
{
scope.locals.Add(local);
}
return local;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="411" endline="418">
public Label DefineLabel()
{
Label label = new Label(labels.Count);
labels.Add(-1);
labelStackHeight.Add(-1);
return label;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="419" endline="440">
public void Emit(OpCode opc)
{
Debug.Assert(opc != OpCodes.Ret || (opc == OpCodes.Ret && stackHeight <= 1));
if (opc.Value < 0)
{
code.Write((byte)(opc.Value >> 8));
}
code.Write((byte)opc.Value);
switch (opc.FlowControl)
{
case FlowControl.Branch
case FlowControl.Break
case FlowControl.Return
case FlowControl.Throw
stackHeight = -1;
break;
default
UpdateStack(opc.StackDiff);
break;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="441" endline="453">
private void UpdateStack(int stackdiff)
{
if (stackHeight == -1)
{
stackHeight = 0;
}
Debug.Assert(stackHeight >= 0 && stackHeight <= ushort.MaxValue);
stackHeight += stackdiff;
Debug.Assert(stackHeight >= 0 && stackHeight <= ushort.MaxValue);
maxStack = Math.Max(maxStack, (ushort)stackHeight);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="490" endline="540">
public void Emit(OpCode opc, Label label)
{
int flowStackHeight = this.stackHeight;
Emit(opc);
if (opc == OpCodes.Leave || opc == OpCodes.Leave_S)
{
flowStackHeight = 0;
}
else if (opc.FlowControl != FlowControl.Branch)
{
flowStackHeight = this.stackHeight;
}
if (labels[label.Index] != -1)
{
if (labelStackHeight[label.Index] != flowStackHeight && (labelStackHeight[label.Index] != 0 || flowStackHeight != -1))
{
throw new NotSupportedException("'Backward branch constraints' violated");
}
if (opc.OperandType == OperandType.ShortInlineBrTarget)
{
WriteByteBranchOffset(labels[label.Index] - (code.Position + 1));
}
else
{
code.Write(labels[label.Index] - (code.Position + 4));
}
}
else
{
Debug.Assert(labelStackHeight[label.Index] == -1 || labelStackHeight[label.Index] == flowStackHeight || (flowStackHeight == -1 && labelStackHeight[label.Index] == 0));
labelStackHeight[label.Index] = flowStackHeight;
LabelFixup fix = new LabelFixup();
fix.label = label.Index;
fix.offset = code.Position;
labelFixups.Add(fix);
if (opc.OperandType == OperandType.ShortInlineBrTarget)
{
code.Write((byte)1);
}
else
{
code.Write(4);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="541" endline="549">
private void WriteByteBranchOffset(int offset)
{
if (offset < -128 || offset > 127)
{
throw new NotSupportedException("Branch offset of " + offset + " does not fit in one-byte branch target at position " + code.Position);
}
code.Write((byte)offset);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="550" endline="576">
public void Emit(OpCode opc, Label[] labels)
{
Emit(opc);
LabelFixup fix = new LabelFixup();
fix.label = -1;
fix.offset = code.Position;
labelFixups.Add(fix);
code.Write(labels.Length);
foreach (Label label in labels)
{
code.Write(label.Index);
if (this.labels[label.Index] != -1)
{
if (labelStackHeight[label.Index] != stackHeight)
{
throw new NotSupportedException();
}
}
else
{
Debug.Assert(labelStackHeight[label.Index] == -1 || labelStackHeight[label.Index] == stackHeight);
labelStackHeight[label.Index] = stackHeight;
}
}
foreach (Label label in labels)
{
code.Write(label.Index);
if (this.labels[label.Index] != -1)
{
if (labelStackHeight[label.Index] != stackHeight)
{
throw new NotSupportedException();
}
}
else
{
Debug.Assert(labelStackHeight[label.Index] == -1 || labelStackHeight[label.Index] == stackHeight);
labelStackHeight[label.Index] = stackHeight;
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="577" endline="645">
public void Emit(OpCode opc, LocalBuilder local)
{
if ((opc == OpCodes.Ldloc || opc == OpCodes.Ldloca || opc == OpCodes.Stloc) && local.LocalIndex < 256)
{
if (opc == OpCodes.Ldloc)
{
switch (local.LocalIndex)
{
case 0
Emit(OpCodes.Ldloc_0);
break;
case 1
Emit(OpCodes.Ldloc_1);
break;
case 2
Emit(OpCodes.Ldloc_2);
break;
case 3
Emit(OpCodes.Ldloc_3);
break;
default
Emit(OpCodes.Ldloc_S);
code.Write((byte)local.LocalIndex);
break;
}
}
else if (opc == OpCodes.Ldloca)
{
Emit(OpCodes.Ldloca_S);
code.Write((byte)local.LocalIndex);
}
else if (opc == OpCodes.Stloc)
{
switch (local.LocalIndex)
{
case 0
Emit(OpCodes.Stloc_0);
break;
case 1
Emit(OpCodes.Stloc_1);
break;
case 2
Emit(OpCodes.Stloc_2);
break;
case 3
Emit(OpCodes.Stloc_3);
break;
default
Emit(OpCodes.Stloc_S);
code.Write((byte)local.LocalIndex);
break;
}
}
}
else
{
Emit(opc);
switch (opc.OperandType)
{
case OperandType.InlineVar
code.Write((ushort)local.LocalIndex);
break;
case OperandType.ShortInlineVar
code.Write((byte)local.LocalIndex);
break;
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="646" endline="654">
private void WriteToken(FieldToken token)
{
if (token.IsPseudoToken)
{
tokenFixups.Add(code.Position);
}
code.Write(token.Token);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="655" endline="663">
private void WriteToken(MethodToken token)
{
if (token.IsPseudoToken)
{
tokenFixups.Add(code.Position);
}
code.Write(token.Token);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="664" endline="688">
private void UpdateStack(OpCode opc, bool hasthis, Type returnType, int parameterCount)
{
if (opc == OpCodes.Jmp)
{
stackHeight = -1;
}
else if (opc.FlowControl == FlowControl.Call)
{
int stackdiff = 0;
if ((hasthis && opc != OpCodes.Newobj) || opc == OpCodes.Calli)
{
stackdiff--;
}
stackdiff -= parameterCount;
if (returnType != moduleBuilder.universe.System_Void)
{
stackdiff++;
}
UpdateStack(stackdiff);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="689" endline="695">
public void Emit(OpCode opc, MethodInfo method)
{
Emit(opc);
WriteToken(moduleBuilder.GetMethodTokenForIL(method));
UpdateStack(opc, method.HasThis, method.ReturnType, method.ParameterCount);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="719" endline="731">
public void Emit(OpCode opc, Type type)
{
Emit(opc);
if (opc == OpCodes.Ldtoken)
{
code.Write(moduleBuilder.GetTypeToken(type).Token);
}
else
{
code.Write(moduleBuilder.GetTypeTokenForMemberRef(type));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="732" endline="738">
public void Emit(OpCode opcode, SignatureHelper signature)
{
Emit(opcode);
UpdateStack(opcode, signature.HasThis, signature.ReturnType, signature.ParameterCount);
code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(signature.GetSignature(moduleBuilder))));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="739" endline="765">
public void EmitCall(OpCode opc, MethodInfo method, Type[] optionalParameterTypes)
{
if (optionalParameterTypes == null || optionalParameterTypes.Length == 0)
{
Emit(opc, method);
}
else
{
Emit(opc);
UpdateStack(opc, method.HasThis, method.ReturnType, method.ParameterCount + optionalParameterTypes.Length);
ByteBuffer sig = new ByteBuffer(16);
method.MethodSignature.WriteMethodRefSig(moduleBuilder, sig, optionalParameterTypes);
MemberRefTable.Record record = new MemberRefTable.Record();
if (method.Module == moduleBuilder)
{
record.Class = method.MetadataToken;
}
else
{
record.Class = moduleBuilder.GetTypeTokenForMemberRef(method.DeclaringType ?? method.Module.GetModuleType());
}
record.Name = moduleBuilder.Strings.Add(method.Name);
record.Signature = moduleBuilder.Blobs.Add(sig);
code.Write(0x0A000000 | moduleBuilder.MemberRef.FindOrAddRecord(record));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="771" endline="780">
public void EmitCalli(OpCode opc, CallingConvention callingConvention, Type returnType, Type[] parameterTypes)
{
returnType = returnType ?? moduleBuilder.universe.System_Void;
Emit(opc);
UpdateStack(opc, false, returnType, parameterTypes.Length);
ByteBuffer sig = new ByteBuffer(16);
Signature.WriteStandAloneMethodSig(moduleBuilder, sig, callingConvention, returnType, parameterTypes);
code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(sig)));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="781" endline="791">
public void EmitCalli(OpCode opc, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
{
returnType = returnType ?? moduleBuilder.universe.System_Void;
optionalParameterTypes = optionalParameterTypes ?? Type.EmptyTypes;
Emit(opc);
UpdateStack(opc, (callingConvention & CallingConventions.HasThis | CallingConventions.ExplicitThis) == CallingConventions.HasThis, returnType, parameterTypes.Length + optionalParameterTypes.Length);
ByteBuffer sig = new ByteBuffer(16);
Signature.WriteStandAloneMethodSig(moduleBuilder, sig, callingConvention, returnType, parameterTypes, optionalParameterTypes);
code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(sig)));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="792" endline="798">
public void EmitWriteLine(string text)
{
Universe u = moduleBuilder.universe;
Emit(OpCodes.Ldstr, text);
Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("WriteLine", new Type[] { u.System_String }));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="799" endline="814">
public void EmitWriteLine(FieldInfo field)
{
Universe u = moduleBuilder.universe;
Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("get_Out"));
if (field.IsStatic)
{
Emit(OpCodes.Ldsfld, field);
}
else
{
Emit(OpCodes.Ldarg_0);
Emit(OpCodes.Ldfld, field);
}
Emit(OpCodes.Callvirt, u.Import(typeof(System.IO.TextWriter)).GetMethod("WriteLine", new Type[] { field.FieldType }));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="815" endline="822">
public void EmitWriteLine(LocalBuilder local)
{
Universe u = moduleBuilder.universe;
Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("get_Out"));
Emit(OpCodes.Ldloc, local);
Emit(OpCodes.Callvirt, u.Import(typeof(System.IO.TextWriter)).GetMethod("WriteLine", new Type[] { local.LocalType }));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="829" endline="854">
public void MarkLabel(Label loc)
{
Debug.Assert(stackHeight == -1 || labelStackHeight[loc.Index] == -1 || stackHeight == labelStackHeight[loc.Index]);
labels[loc.Index] = code.Position;
if (labelStackHeight[loc.Index] == -1)
{
if (stackHeight == -1)
{
labelStackHeight[loc.Index] = 0;
}
else
{
labelStackHeight[loc.Index] = stackHeight;
}
}
else
{
Debug.Assert(stackHeight == -1 || stackHeight == labelStackHeight[loc.Index]);
stackHeight = labelStackHeight[loc.Index];
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="855" endline="866">
public void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn)
{
SequencePoint sp = new SequencePoint();
sp.document = document;
sp.offset = code.Position;
sp.startLine = startLine;
sp.startColumn = startColumn;
sp.endLine = endLine;
sp.endColumn = endColumn;
sequencePoints.Add(sp);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="873" endline="926">
internal int WriteBody(bool initLocals)
{
if (moduleBuilder.symbolWriter != null)
{
Debug.Assert(scope != null && scope.parent == null);
scope.endOffset = code.Position;
}
ResolveBranches();
ByteBuffer bb = moduleBuilder.methodBodies;
int localVarSigTok = 0;
int rva;
if (locals.Count == 0 && exceptions.Count == 0 && maxStack <= 8 && code.Length < 64)
{
rva = WriteTinyHeaderAndCode(bb);
}
else
{
rva = WriteFatHeaderAndCode(bb, ref localVarSigTok, initLocals);
}
if (moduleBuilder.symbolWriter != null)
{
if (sequencePoints.Count != 0)
{
ISymbolDocumentWriter document = sequencePoints[0].document;
int[] offsets = new int[sequencePoints.Count];
int[] lines = new int[sequencePoints.Count];
int[] columns = new int[sequencePoints.Count];
int[] endLines = new int[sequencePoints.Count];
int[] endColumns = new int[sequencePoints.Count];
for (int i = 0; i < sequencePoints.Count; i++)
{
if (sequencePoints[i].document != document)
{
throw new NotImplementedException();
}
offsets[i] = sequencePoints[i].offset;
lines[i] = sequencePoints[i].startLine;
columns[i] = sequencePoints[i].startColumn;
endLines[i] = sequencePoints[i].endLine;
endColumns[i] = sequencePoints[i].endColumn;
}
for (int i = 0; i < sequencePoints.Count; i++)
{
if (sequencePoints[i].document != document)
{
throw new NotImplementedException();
}
offsets[i] = sequencePoints[i].offset;
lines[i] = sequencePoints[i].startLine;
columns[i] = sequencePoints[i].startColumn;
endLines[i] = sequencePoints[i].endLine;
endColumns[i] = sequencePoints[i].endColumn;
}
moduleBuilder.symbolWriter.DefineSequencePoints(document, offsets, lines, columns, endLines, endColumns);
}
WriteScope(scope, localVarSigTok);
}
return rva;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="927" endline="960">
private void ResolveBranches()
{
foreach (LabelFixup fixup in labelFixups)
{
if (fixup.label == -1)
{
code.Position = fixup.offset;
int count = code.GetInt32AtCurrentPosition();
int offset = fixup.offset + 4 + 4 * count;
code.Position += 4;
for (int i = 0; i < count; i++)
{
int index = code.GetInt32AtCurrentPosition();
code.Write(labels[index] - offset);
}
for (int i = 0; i < count; i++)
{
int index = code.GetInt32AtCurrentPosition();
code.Write(labels[index] - offset);
}
}
else
{
code.Position = fixup.offset;
byte size = code.GetByteAtCurrentPosition();
int branchOffset = labels[fixup.label] - (code.Position + size);
if (size == 1)
{
WriteByteBranchOffset(branchOffset);
}
else
{
code.Write(branchOffset);
}
}
}
foreach (LabelFixup fixup in labelFixups)
{
if (fixup.label == -1)
{
code.Position = fixup.offset;
int count = code.GetInt32AtCurrentPosition();
int offset = fixup.offset + 4 + 4 * count;
code.Position += 4;
for (int i = 0; i < count; i++)
{
int index = code.GetInt32AtCurrentPosition();
code.Write(labels[index] - offset);
}
}
else
{
code.Position = fixup.offset;
byte size = code.GetByteAtCurrentPosition();
int branchOffset = labels[fixup.label] - (code.Position + size);
if (size == 1)
{
WriteByteBranchOffset(branchOffset);
}
else
{
code.Write(branchOffset);
}
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="961" endline="969">
private int WriteTinyHeaderAndCode(ByteBuffer bb)
{
int rva = bb.Position;
const byte CorILMethod_TinyFormat = 0x2;
bb.Write((byte)(CorILMethod_TinyFormat | (code.Length << 2)));
WriteCode(bb);
return rva;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="970" endline="1108">
private int WriteFatHeaderAndCode(ByteBuffer bb, ref int localVarSigTok, bool initLocals)
{
bb.Align(4);
int rva = bb.Position;
if (locals.Count != 0)
{
ByteBuffer localVarSig = new ByteBuffer(locals.Count + 2);
Signature.WriteLocalVarSig(moduleBuilder, localVarSig, locals);
localVarSigTok = 0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(localVarSig));
}
const byte CorILMethod_FatFormat = 0x03;
const byte CorILMethod_MoreSects = 0x08;
const byte CorILMethod_InitLocals = 0x10;
short flagsAndSize = (short)(CorILMethod_FatFormat | (3 << 12));
if (initLocals)
{
flagsAndSize |= CorILMethod_InitLocals;
}
if (exceptions.Count > 0)
{
flagsAndSize |= CorILMethod_MoreSects;
}
bb.Write(flagsAndSize);
bb.Write(maxStack);
bb.Write(code.Length);
bb.Write(localVarSigTok);
WriteCode(bb);
if (exceptions.Count > 0)
{
bb.Align(4);
bool fat = false;
foreach (ExceptionBlock block in exceptions)
{
if (block.tryOffset > 65535 || block.tryLength > 255 || block.handlerOffset > 65535 || block.handlerLength > 255)
{
fat = true;
break;
}
}
foreach (ExceptionBlock block in exceptions)
{
if (block.tryOffset > 65535 || block.tryLength > 255 || block.handlerOffset > 65535 || block.handlerLength > 255)
{
fat = true;
break;
}
}
exceptions.Sort(exceptions[0]);
if (exceptions.Count * 12 + 4 > 255)
{
fat = true;
}
const byte CorILMethod_Sect_EHTable = 0x1;
const byte CorILMethod_Sect_FatFormat = 0x40;
const short COR_ILEXCEPTION_CLAUSE_EXCEPTION = 0x0000;
const short COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001;
const short COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002;
const short COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004;
if (fat)
{
bb.Write((byte)(CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat));
int dataSize = exceptions.Count * 24 + 4;
bb.Write((byte)dataSize);
bb.Write((short)(dataSize >> 8));
foreach (ExceptionBlock block in exceptions)
{
if (block.exceptionType == FAULT)
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_FAULT);
}
else if (block.filterOffset != 0)
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_FILTER);
}
else if (block.exceptionType != null)
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_EXCEPTION);
}
else
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_FINALLY);
}
bb.Write(block.tryOffset);
bb.Write(block.tryLength);
bb.Write(block.handlerOffset);
bb.Write(block.handlerLength);
if (block.exceptionType != null && block.exceptionType != FAULT)
{
bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
}
else
{
bb.Write(block.filterOffset);
}
}
foreach (ExceptionBlock block in exceptions)
{
if (block.exceptionType == FAULT)
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_FAULT);
}
else if (block.filterOffset != 0)
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_FILTER);
}
else if (block.exceptionType != null)
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_EXCEPTION);
}
else
{
bb.Write((int)COR_ILEXCEPTION_CLAUSE_FINALLY);
}
bb.Write(block.tryOffset);
bb.Write(block.tryLength);
bb.Write(block.handlerOffset);
bb.Write(block.handlerLength);
if (block.exceptionType != null && block.exceptionType != FAULT)
{
bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
}
else
{
bb.Write(block.filterOffset);
}
}
}
else
{
bb.Write(CorILMethod_Sect_EHTable);
bb.Write((byte)(exceptions.Count * 12 + 4));
bb.Write((short)0);
foreach (ExceptionBlock block in exceptions)
{
if (block.exceptionType == FAULT)
{
bb.Write(COR_ILEXCEPTION_CLAUSE_FAULT);
}
else if (block.filterOffset != 0)
{
bb.Write(COR_ILEXCEPTION_CLAUSE_FILTER);
}
else if (block.exceptionType != null)
{
bb.Write(COR_ILEXCEPTION_CLAUSE_EXCEPTION);
}
else
{
bb.Write(COR_ILEXCEPTION_CLAUSE_FINALLY);
}
bb.Write((short)block.tryOffset);
bb.Write((byte)block.tryLength);
bb.Write((short)block.handlerOffset);
bb.Write((byte)block.handlerLength);
if (block.exceptionType != null && block.exceptionType != FAULT)
{
bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
}
else
{
bb.Write(block.filterOffset);
}
}
foreach (ExceptionBlock block in exceptions)
{
if (block.exceptionType == FAULT)
{
bb.Write(COR_ILEXCEPTION_CLAUSE_FAULT);
}
else if (block.filterOffset != 0)
{
bb.Write(COR_ILEXCEPTION_CLAUSE_FILTER);
}
else if (block.exceptionType != null)
{
bb.Write(COR_ILEXCEPTION_CLAUSE_EXCEPTION);
}
else
{
bb.Write(COR_ILEXCEPTION_CLAUSE_FINALLY);
}
bb.Write((short)block.tryOffset);
bb.Write((byte)block.tryLength);
bb.Write((short)block.handlerOffset);
bb.Write((byte)block.handlerLength);
if (block.exceptionType != null && block.exceptionType != FAULT)
{
bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
}
else
{
bb.Write(block.filterOffset);
}
}
}
}
return rva;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="1109" endline="1118">
private void WriteCode(ByteBuffer bb)
{
int codeOffset = bb.Position;
foreach (int fixup in this.tokenFixups)
{
moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
}
foreach (int fixup in this.tokenFixups)
{
moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
}
bb.Write(code);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="1119" endline="1142">
private void WriteScope(Scope scope, int localVarSigTok)
{
moduleBuilder.symbolWriter.OpenScope(scope.startOffset);
foreach (LocalBuilder local in scope.locals)
{
if (local.name != null)
{
int startOffset = local.startOffset;
int endOffset = local.endOffset;
if (startOffset == 0 && endOffset == 0)
{
startOffset = scope.startOffset;
endOffset = scope.endOffset;
}
moduleBuilder.symbolWriter.DefineLocalVariable2(local.name, 0, localVarSigTok, SymAddressKind.ILOffset, local.LocalIndex, 0, 0, startOffset, endOffset);
}
}
foreach (LocalBuilder local in scope.locals)
{
if (local.name != null)
{
int startOffset = local.startOffset;
int endOffset = local.endOffset;
if (startOffset == 0 && endOffset == 0)
{
startOffset = scope.startOffset;
endOffset = scope.endOffset;
}
moduleBuilder.symbolWriter.DefineLocalVariable2(local.name, 0, localVarSigTok, SymAddressKind.ILOffset, local.LocalIndex, 0, 0, startOffset, endOffset);
}
}
foreach (Scope child in scope.children)
{
WriteScope(child, localVarSigTok);
}
foreach (Scope child in scope.children)
{
WriteScope(child, localVarSigTok);
}
moduleBuilder.symbolWriter.CloseScope(scope.endOffset);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="54" endline="115">
private PEFileKinds fileKind = PEFileKinds.Dll;
private MethodInfo entryPoint;
private VersionInfo versionInfo;
private ResourceSection unmanagedResources;
private string imageRuntimeVersion;
internal int mdStreamVersion = 0x20000;
private Module pseudoManifestModule;
private readonly List<ResourceFile> resourceFiles = new List<ResourceFile>();
private readonly List<ModuleBuilder> modules = new List<ModuleBuilder>();
private readonly List<Module> addedModules = new List<Module>();
private readonly List<CustomAttributeBuilder> customAttributes = new List<CustomAttributeBuilder>();
private readonly List<CustomAttributeBuilder> declarativeSecurity = new List<CustomAttributeBuilder>();
private readonly List<Type> typeForwarders = new List<Type>();
private struct ResourceFile
{
internal string Name;
internal string FileName;
internal ResourceAttributes Attributes;
}
internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
{
this.name = name.Name;
SetVersionHelper(name.Version);
if (name.CultureInfo != null && !string.IsNullOrEmpty(name.CultureInfo.Name))
{
this.culture = name.CultureInfo.Name;
}
this.flags = name.Flags;
this.hashAlgorithm = name.HashAlgorithm;
if (this.hashAlgorithm == AssemblyHashAlgorithm.None)
{
this.hashAlgorithm = AssemblyHashAlgorithm.SHA1;
}
this.keyPair = name.KeyPair;
if (this.keyPair != null)
{
this.publicKey = this.keyPair.PublicKey;
}
else
{
byte[] publicKey = name.GetPublicKey();
if (publicKey != null && publicKey.Length != 0)
{
this.publicKey = (byte[])publicKey.Clone();
}
}
this.dir = dir ?? ".";
this.requiredPermissions = requiredPermissions;
this.optionalPermissions = optionalPermissions;
this.refusedPermissions = refusedPermissions;
if (universe.HasMscorlib && universe.Mscorlib.ImageRuntimeVersion != null)
{
this.imageRuntimeVersion = universe.Mscorlib.ImageRuntimeVersion;
}
else
{
this.imageRuntimeVersion = typeof(object).Assembly.ImageRuntimeVersion;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="116" endline="133">
private void SetVersionHelper(Version version)
{
if (version == null)
{
majorVersion = 0;
minorVersion = 0;
buildVersion = 0;
revisionVersion = 0;
}
else
{
majorVersion = (ushort)version.Major;
minorVersion = (ushort)version.Minor;
buildVersion = version.Build == -1 ? (ushort)0
revisionVersion = version.Revision == -1 ? (ushort)0
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="134" endline="140">
public void __SetAssemblyVersion(Version version)
{
AssemblyName oldName = GetName();
SetVersionHelper(version);
universe.RenameAssembly(this, oldName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="141" endline="147">
public void __SetAssemblyCulture(string cultureName)
{
AssemblyName oldName = GetName();
this.culture = cultureName;
universe.RenameAssembly(this, oldName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="148" endline="158">
public void __SetAssemblyKeyPair(StrongNameKeyPair keyPair)
{
AssemblyName oldName = GetName();
this.keyPair = keyPair;
if (keyPair != null)
{
this.publicKey = keyPair.PublicKey;
}
universe.RenameAssembly(this, oldName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="159" endline="166">
public void __SetAssemblyPublicKey(byte[] publicKey)
{
AssemblyName oldName = GetName();
this.publicKey = publicKey == null ? null
universe.RenameAssembly(this, oldName);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="177" endline="189">
public override AssemblyName GetName()
{
AssemblyName n = new AssemblyName();
n.Name = name;
n.Version = new Version(majorVersion, minorVersion, buildVersion, revisionVersion);
n.Culture = culture;
n.HashAlgorithm = hashAlgorithm;
n.Flags = flags;
n.SetPublicKey(publicKey != null ? (byte[])publicKey.Clone()
n.KeyPair = keyPair;
return n;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
{
ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
modules.Add(module);
return module;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="212" endline="223">
public ModuleBuilder GetDynamicModule(string name)
{
foreach (ModuleBuilder module in modules)
{
if (module.Name == name)
{
return module;
}
}
foreach (ModuleBuilder module in modules)
{
if (module.Name == name)
{
return module;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="260" endline="402">
public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
{
ModuleBuilder manifestModule = null;
foreach (ModuleBuilder moduleBuilder in modules)
{
moduleBuilder.PopulatePropertyAndEventTables();
if (manifestModule == null
&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
{
manifestModule = moduleBuilder;
}
}
foreach (ModuleBuilder moduleBuilder in modules)
{
moduleBuilder.PopulatePropertyAndEventTables();
if (manifestModule == null
&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
{
manifestModule = moduleBuilder;
}
}
if (manifestModule == null)
{
manifestModule = DefineDynamicModule("RefEmit_OnDiskManifestModule", assemblyFileName, false);
}
AssemblyTable.Record assemblyRecord = new AssemblyTable.Record();
assemblyRecord.HashAlgId = (int)hashAlgorithm;
assemblyRecord.Name = manifestModule.Strings.Add(name);
assemblyRecord.MajorVersion = majorVersion;
assemblyRecord.MinorVersion = minorVersion;
assemblyRecord.BuildNumber = buildVersion;
assemblyRecord.RevisionNumber = revisionVersion;
if (publicKey != null)
{
assemblyRecord.PublicKey = manifestModule.Blobs.Add(ByteBuffer.Wrap(publicKey));
assemblyRecord.Flags = (int)(flags | AssemblyNameFlags.PublicKey);
}
else
{
assemblyRecord.Flags = (int)(flags & ~AssemblyNameFlags.PublicKey);
}
if (culture != null)
{
assemblyRecord.Culture = manifestModule.Strings.Add(culture);
}
int token = 0x20000000 + manifestModule.AssemblyTable.AddRecord(assemblyRecord);
#pragma warning disable 618
System.Security.Permissions.SecurityAction requestMinimum = System.Security.Permissions.SecurityAction.RequestMinimum;
System.Security.Permissions.SecurityAction requestOptional = System.Security.Permissions.SecurityAction.RequestOptional;
System.Security.Permissions.SecurityAction requestRefuse = System.Security.Permissions.SecurityAction.RequestRefuse;
#pragma warning restore 618
if (requiredPermissions != null)
{
manifestModule.AddDeclarativeSecurity(token, requestMinimum, requiredPermissions);
}
if (optionalPermissions != null)
{
manifestModule.AddDeclarativeSecurity(token, requestOptional, optionalPermissions);
}
if (refusedPermissions != null)
{
manifestModule.AddDeclarativeSecurity(token, requestRefuse, refusedPermissions);
}
if (versionInfo != null)
{
versionInfo.SetName(GetName());
versionInfo.SetFileName(assemblyFileName);
foreach (CustomAttributeBuilder cab in customAttributes)
{
if (!cab.HasBlob)
{
versionInfo.SetAttribute(cab);
}
}
foreach (CustomAttributeBuilder cab in customAttributes)
{
if (!cab.HasBlob)
{
versionInfo.SetAttribute(cab);
}
}
ByteBuffer versionInfoData = new ByteBuffer(512);
versionInfo.Write(versionInfoData);
if (unmanagedResources == null)
{
unmanagedResources = new ResourceSection();
}
unmanagedResources.AddVersionInfo(versionInfoData);
}
foreach (CustomAttributeBuilder cab in customAttributes)
{
manifestModule.SetCustomAttribute(0x20000001, cab);
}
foreach (CustomAttributeBuilder cab in customAttributes)
{
manifestModule.SetCustomAttribute(0x20000001, cab);
}
manifestModule.AddDeclarativeSecurity(0x20000001, declarativeSecurity);
foreach (Type type in typeForwarders)
{
manifestModule.AddTypeForwarder(type);
}
foreach (Type type in typeForwarders)
{
manifestModule.AddTypeForwarder(type);
}
foreach (ResourceFile resfile in resourceFiles)
{
int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
rec.Offset = 0;
rec.Flags = (int)resfile.Attributes;
rec.Name = manifestModule.Strings.Add(resfile.Name);
rec.Implementation = fileToken;
manifestModule.ManifestResource.AddRecord(rec);
}
foreach (ResourceFile resfile in resourceFiles)
{
int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
rec.Offset = 0;
rec.Flags = (int)resfile.Attributes;
rec.Name = manifestModule.Strings.Add(resfile.Name);
rec.Implementation = fileToken;
manifestModule.ManifestResource.AddRecord(rec);
}
int entryPointToken = 0;
foreach (ModuleBuilder moduleBuilder in modules)
{
moduleBuilder.FillAssemblyRefTable();
if (moduleBuilder != manifestModule)
{
int fileToken;
if (entryPoint != null && entryPoint.Module == moduleBuilder)
{
ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
}
else
{
ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
}
moduleBuilder.ExportTypes(fileToken, manifestModule);
}
}
foreach (ModuleBuilder moduleBuilder in modules)
{
moduleBuilder.FillAssemblyRefTable();
if (moduleBuilder != manifestModule)
{
int fileToken;
if (entryPoint != null && entryPoint.Module == moduleBuilder)
{
ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
}
else
{
ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
}
moduleBuilder.ExportTypes(fileToken, manifestModule);
}
}
foreach (Module module in addedModules)
{
int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
module.ExportTypes(fileToken, manifestModule);
}
foreach (Module module in addedModules)
{
int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
module.ExportTypes(fileToken, manifestModule);
}
if (entryPointToken == 0 && entryPoint != null)
{
entryPointToken = entryPoint.MetadataToken;
}
ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="403" endline="425">
private int AddFile(ModuleBuilder manifestModule, string fileName, int flags)
{
SHA1Managed hash = new SHA1Managed();
string fullPath = fileName;
if (dir != null)
{
fullPath = Path.Combine(dir, fileName);
}
using (FileStream fs = new FileStream(fullPath, FileMode.Open, FileAccess.Read))
{
using (CryptoStream cs = new CryptoStream(Stream.Null, hash, CryptoStreamMode.Write))
{
byte[] buf = new byte[8192];
ModuleWriter.HashChunk(fs, cs, buf, (int)fs.Length);
}
}
FileTable.Record file = new FileTable.Record();
file.Flags = flags;
file.Name = manifestModule.Strings.Add(Path.GetFileName(fileName));
file.HashValue = manifestModule.Blobs.Add(ByteBuffer.Wrap(hash.Hash));
return 0x26000000 + manifestModule.File.AddRecord(file);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="431" endline="439">
public void AddResourceFile(string name, string fileName, ResourceAttributes attribs)
{
ResourceFile resfile = new ResourceFile();
resfile.Name = name;
resfile.FileName = fileName;
resfile.Attributes = attribs;
resourceFiles.Add(resfile);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="445" endline="454">
public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark)
{
versionInfo = new VersionInfo();
versionInfo.product = product;
versionInfo.informationalVersion = productVersion;
versionInfo.company = company;
versionInfo.copyright = copyright;
versionInfo.trademark = trademark;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="477" endline="490">
public override Type[] GetTypes()
{
List<Type> list = new List<Type>();
foreach (ModuleBuilder module in modules)
{
module.GetTypesImpl(list);
}
foreach (ModuleBuilder module in modules)
{
module.GetTypesImpl(list);
}
foreach (Module module in addedModules)
{
module.GetTypesImpl(list);
}
foreach (Module module in addedModules)
{
module.GetTypesImpl(list);
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="491" endline="511">
internal override Type GetTypeImpl(string typeName)
{
foreach (ModuleBuilder mb in modules)
{
Type type = mb.GetTypeImpl(typeName);
if (type != null)
{
return type;
}
}
foreach (ModuleBuilder mb in modules)
{
Type type = mb.GetTypeImpl(typeName);
if (type != null)
{
return type;
}
}
foreach (Module module in addedModules)
{
Type type = module.GetTypeImpl(typeName);
if (type != null)
{
return type;
}
}
foreach (Module module in addedModules)
{
Type type = module.GetTypeImpl(typeName);
if (type != null)
{
return type;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="516" endline="522">
}
public void __SetImageRuntimeVersion(string imageRuntimeVersion, int mdStreamVersion)
{
this.imageRuntimeVersion = imageRuntimeVersion;
this.mdStreamVersion = mdStreamVersion;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="523" endline="533">
public override Module ManifestModule
{
get
{
if (pseudoManifestModule == null)
{
pseudoManifestModule = new ManifestModule(this);
}
return pseudoManifestModule;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="550" endline="569">
public override Module[] GetModules(bool getResourceModules)
{
List<Module> list = new List<Module>();
foreach (ModuleBuilder module in modules)
{
if (getResourceModules || !module.IsResource())
{
list.Add(module);
}
}
foreach (ModuleBuilder module in modules)
{
if (getResourceModules || !module.IsResource())
{
list.Add(module);
}
}
foreach (Module module in addedModules)
{
if (getResourceModules || !module.IsResource())
{
list.Add(module);
}
}
foreach (Module module in addedModules)
{
if (getResourceModules || !module.IsResource())
{
list.Add(module);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="570" endline="588">
public override Module GetModule(string name)
{
foreach (ModuleBuilder module in modules)
{
if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
{
return module;
}
}
foreach (ModuleBuilder module in modules)
{
if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
{
return module;
}
}
foreach (Module module in addedModules)
{
if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
{
return module;
}
}
foreach (Module module in addedModules)
{
if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
{
return module;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="589" endline="595">
public Module __AddModule(RawModule module)
{
Module mod = module.ToModule(this);
addedModules.Add(mod);
return mod;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="610" endline="623">
}
internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
{
List<CustomAttributeData> list = new List<CustomAttributeData>();
foreach (CustomAttributeBuilder cab in customAttributes)
{
if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
{
list.Add(cab.ToData(this));
}
}
foreach (CustomAttributeBuilder cab in customAttributes)
{
if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
{
list.Add(cab.ToData(this));
}
}
return list;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="624" endline="635">
}
sealed class ManifestModule
{
private readonly AssemblyBuilder assembly;
private readonly Guid guid = Guid.NewGuid();
internal ManifestModule(AssemblyBuilder assembly)
{
this.assembly = assembly;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="44" endline="50">
private FieldSignature(Type fieldType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers)
{
this.fieldType = fieldType;
this.optionalCustomModifiers = optionalCustomModifiers;
this.requiredCustomModifiers = requiredCustomModifiers;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
public override bool Equals(object obj)
{
FieldSignature other = obj as FieldSignature;
return other != null
&& other.fieldType.Equals(fieldType)
&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="80" endline="87">
internal FieldSignature ExpandTypeParameters(Type declaringType)
{
return new FieldSignature(
fieldType.BindTypeParameters(declaringType),
BindTypeParameters(declaringType, optionalCustomModifiers),
BindTypeParameters(declaringType, requiredCustomModifiers));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="88" endline="101">
internal static FieldSignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
{
if (br.ReadByte() != FIELD)
{
throw new BadImageFormatException();
}
Type fieldType;
Type[] optionalCustomModifiers;
Type[] requiredCustomModifiers;
ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
fieldType = ReadType(module, br, context);
return new FieldSignature(fieldType, optionalCustomModifiers, requiredCustomModifiers);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="102" endline="109">
internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
{
bb.Write(FIELD);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
WriteType(module, bb, fieldType);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="40" endline="46">
internal TypeDefImpl(ModuleReader module, int index)
{
this.module = module;
this.index = index;
this.typeName = TypeNameParser.Escape(module.GetString(module.TypeDef.records[index].TypeName));
this.typeNamespace = TypeNameParser.Escape(module.GetString(module.TypeDef.records[index].TypeNamespace));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="47" endline="58">
public override Type BaseType
{
get
{
int extends = module.TypeDef.records[index].Extends;
if ((extends & 0xFFFFFF) == 0)
{
return null;
}
return module.ResolveType(extends, this);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="64" endline="85">
}
public override EventInfo[] __GetDeclaredEvents()
{
int token = this.MetadataToken;
for (int i = 0; i < module.EventMap.records.Length; i++)
{
if (module.EventMap.records[i].Parent == token)
{
int evt = module.EventMap.records[i].EventList - 1;
int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1
EventInfo[] events = new EventInfo[end - evt];
for (int j = 0; evt < end; evt++, j++)
{
events[j] = new EventInfoImpl(module, this, evt);
}
for (int j = 0; evt < end; evt++, j++)
{
events[j] = new EventInfoImpl(module, this, evt);
}
return events;
}
}
for (int i = 0; i < module.EventMap.records.Length; i++)
{
if (module.EventMap.records[i].Parent == token)
{
int evt = module.EventMap.records[i].EventList - 1;
int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1
EventInfo[] events = new EventInfo[end - evt];
for (int j = 0; evt < end; evt++, j++)
{
events[j] = new EventInfoImpl(module, this, evt);
}
return events;
}
}
return Empty<EventInfo>.Array;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="86" endline="97">
public override FieldInfo[] __GetDeclaredFields()
{
int field = module.TypeDef.records[index].FieldList - 1;
int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].FieldList - 1
FieldInfo[] fields = new FieldInfo[end - field];
for (int i = 0; field < end; i++, field++)
{
fields[i] = module.GetFieldAt(this, field);
}
for (int i = 0; field < end; i++, field++)
{
fields[i] = module.GetFieldAt(this, field);
}
return fields;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="98" endline="112">
public override Type[] __GetDeclaredInterfaces()
{
int token = this.MetadataToken;
List<Type> list = new List<Type>();
for (int i = 0; i < module.InterfaceImpl.records.Length; i++)
{
if (module.InterfaceImpl.records[i].Class == token)
{
list.Add(module.ResolveType(module.InterfaceImpl.records[i].Interface, this));
}
}
for (int i = 0; i < module.InterfaceImpl.records.Length; i++)
{
if (module.InterfaceImpl.records[i].Class == token)
{
list.Add(module.ResolveType(module.InterfaceImpl.records[i].Interface, this));
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="113" endline="124">
public override MethodBase[] __GetDeclaredMethods()
{
int method = module.TypeDef.records[index].MethodList - 1;
int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].MethodList - 1
MethodBase[] methods = new MethodBase[end - method];
for (int i = 0; method < end; method++, i++)
{
methods[i] = module.GetMethodAt(this, method);
}
for (int i = 0; method < end; method++, i++)
{
methods[i] = module.GetMethodAt(this, method);
}
return methods;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="125" endline="157">
public override __MethodImplMap __GetMethodImplMap()
{
List<MethodInfo> bodies = new List<MethodInfo>();
List<List<MethodInfo>> declarations = new List<List<MethodInfo>>();
int token = this.MetadataToken;
for (int i = 0; i < module.MethodImpl.records.Length; i++)
{
if (module.MethodImpl.records[i].Class == token)
{
MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
int index = bodies.IndexOf(body);
if (index == -1)
{
index = bodies.Count;
bodies.Add(body);
declarations.Add(new List<MethodInfo>());
}
MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
declarations[index].Add(declaration);
}
}
for (int i = 0; i < module.MethodImpl.records.Length; i++)
{
if (module.MethodImpl.records[i].Class == token)
{
MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
int index = bodies.IndexOf(body);
if (index == -1)
{
index = bodies.Count;
bodies.Add(body);
declarations.Add(new List<MethodInfo>());
}
MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
declarations[index].Add(declaration);
}
}
__MethodImplMap map = new __MethodImplMap();
map.TargetType = this;
map.MethodBodies = bodies.ToArray();
map.MethodDeclarations = new MethodInfo[declarations.Count][];
for (int i = 0; i < map.MethodDeclarations.Length; i++)
{
map.MethodDeclarations[i] = declarations[i].ToArray();
}
for (int i = 0; i < map.MethodDeclarations.Length; i++)
{
map.MethodDeclarations[i] = declarations[i].ToArray();
}
return map;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="158" endline="172">
public override Type[] __GetDeclaredTypes()
{
int token = this.MetadataToken;
List<Type> list = new List<Type>();
for (int i = 0; i < module.NestedClass.records.Length; i++)
{
if (module.NestedClass.records[i].EnclosingClass == token)
{
list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
}
}
for (int i = 0; i < module.NestedClass.records.Length; i++)
{
if (module.NestedClass.records[i].EnclosingClass == token)
{
list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="173" endline="193">
public override PropertyInfo[] __GetDeclaredProperties()
{
int token = this.MetadataToken;
for (int i = 0; i < module.PropertyMap.records.Length; i++)
{
if (module.PropertyMap.records[i].Parent == token)
{
int property = module.PropertyMap.records[i].PropertyList - 1;
int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1
PropertyInfo[] properties = new PropertyInfo[end - property];
for (int j = 0; property < end; property++, j++)
{
properties[j] = new PropertyInfoImpl(module, this, property);
}
for (int j = 0; property < end; property++, j++)
{
properties[j] = new PropertyInfoImpl(module, this, property);
}
return properties;
}
}
for (int i = 0; i < module.PropertyMap.records.Length; i++)
{
if (module.PropertyMap.records[i].Parent == token)
{
int property = module.PropertyMap.records[i].PropertyList - 1;
int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1
PropertyInfo[] properties = new PropertyInfo[end - property];
for (int j = 0; property < end; property++, j++)
{
properties[j] = new PropertyInfoImpl(module, this, property);
}
return properties;
}
}
return Empty<PropertyInfo>.Array;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="213" endline="219">
}
public override Type[] GetGenericArguments()
{
PopulateGenericArguments();
return Util.Copy(typeArgs);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="220" endline="242">
private void PopulateGenericArguments()
{
if (typeArgs == null)
{
int token = this.MetadataToken;
int first = module.GenericParam.FindFirstByOwner(token);
if (first == -1)
{
typeArgs = Type.EmptyTypes;
}
else
{
List<Type> list = new List<Type>();
int len = module.GenericParam.records.Length;
for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
{
list.Add(new GenericTypeParameter(module, i));
}
for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
{
list.Add(new GenericTypeParameter(module, i));
}
typeArgs = list.ToArray();
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="270" endline="279">
}
public override Type GetGenericTypeDefinition()
{
if (IsGenericTypeDefinition)
{
return this;
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="280" endline="296">
public override string ToString()
{
StringBuilder sb = new StringBuilder(this.FullName);
string sep = "[";
foreach (Type arg in GetGenericArguments())
{
sb.Append(sep);
sb.Append(arg);
sep = ",";
}
foreach (Type arg in GetGenericArguments())
{
sb.Append(sep);
sb.Append(arg);
sep = ",";
}
if (sep != "[")
{
sb.Append(']');
}
return sb.ToString();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="297" endline="317">
public override Type DeclaringType
{
get
{
if ((this.Attributes & TypeAttributes.VisibilityMask & ~TypeAttributes.Public) == 0)
{
return null;
}
int token = this.MetadataToken;
for (int i = 0; i < module.NestedClass.records.Length; i++)
{
if (module.NestedClass.records[i].NestedClass == token)
{
return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
}
}
for (int i = 0; i < module.NestedClass.records.Length; i++)
{
if (module.NestedClass.records[i].NestedClass == token)
{
return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
}
}
throw new InvalidOperationException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="318" endline="365">
}
public override StructLayoutAttribute StructLayoutAttribute
{
get
{
StructLayoutAttribute layout;
switch (this.Attributes & TypeAttributes.LayoutMask)
{
case TypeAttributes.AutoLayout
return null;
case TypeAttributes.SequentialLayout
layout = new StructLayoutAttribute(LayoutKind.Sequential);
break;
case TypeAttributes.ExplicitLayout
layout = new StructLayoutAttribute(LayoutKind.Explicit);
break;
default
throw new BadImageFormatException();
}
int token = this.MetadataToken;
for (int i = 0; i < module.ClassLayout.records.Length; i++)
{
if (module.ClassLayout.records[i].Parent == token)
{
layout.Pack = module.ClassLayout.records[i].PackingSize;
layout.Size = module.ClassLayout.records[i].ClassSize;
switch (this.Attributes & TypeAttributes.StringFormatMask)
{
case TypeAttributes.AnsiClass
layout.CharSet = CharSet.Ansi;
break;
case TypeAttributes.UnicodeClass
layout.CharSet = CharSet.Unicode;
break;
case TypeAttributes.AutoClass
layout.CharSet = CharSet.Auto;
break;
default
layout.CharSet = CharSet.None;
break;
}
return layout;
}
}
for (int i = 0; i < module.ClassLayout.records.Length; i++)
{
if (module.ClassLayout.records[i].Parent == token)
{
layout.Pack = module.ClassLayout.records[i].PackingSize;
layout.Size = module.ClassLayout.records[i].ClassSize;
switch (this.Attributes & TypeAttributes.StringFormatMask)
{
case TypeAttributes.AnsiClass
layout.CharSet = CharSet.Ansi;
break;
case TypeAttributes.UnicodeClass
layout.CharSet = CharSet.Unicode;
break;
case TypeAttributes.AutoClass
layout.CharSet = CharSet.Auto;
break;
default
layout.CharSet = CharSet.None;
break;
}
return layout;
}
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="39" endline="45">
internal AssemblyReader(string location, ModuleReader manifestModule)
{
this.location = location;
this.manifestModule = manifestModule;
externalModules = new Module[manifestModule.File.records.Length];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="61" endline="87">
private AssemblyName GetNameImpl(ref AssemblyTable.Record rec)
{
AssemblyName name = new AssemblyName();
name.Name = manifestModule.GetString(rec.Name);
name.Version = new Version(rec.MajorVersion, rec.MinorVersion, rec.BuildNumber, rec.RevisionNumber);
if (rec.PublicKey != 0)
{
name.SetPublicKey(manifestModule.GetBlobCopy(rec.PublicKey));
}
else
{
name.SetPublicKey(Empty<byte>.Array);
}
if (rec.Culture != 0)
{
name.CultureInfo = new System.Globalization.CultureInfo(manifestModule.GetString(rec.Culture));
}
else
{
name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
}
name.HashAlgorithm = (AssemblyHashAlgorithm)rec.HashAlgId;
name.CodeBase = this.CodeBase;
name.Flags = (AssemblyNameFlags)rec.Flags;
return name;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="88" endline="102">
public override Type[] GetTypes()
{
if (externalModules.Length == 0)
{
return manifestModule.GetTypes();
}
List<Type> list = new List<Type>();
foreach (Module module in GetModules(false))
{
list.AddRange(module.GetTypes());
}
foreach (Module module in GetModules(false))
{
list.AddRange(module.GetTypes());
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="103" endline="115">
internal override Type GetTypeImpl(string typeName)
{
Type type = manifestModule.GetType(typeName);
for (int i = 0; type == null && i < externalModules.Length; i++)
{
if ((manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
{
type = GetModule(i).GetType(typeName);
}
}
for (int i = 0; type == null && i < externalModules.Length; i++)
{
if ((manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
{
type = GetModule(i).GetType(typeName);
}
}
return type;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="125" endline="139">
}
public override Module[] GetLoadedModules(bool getResourceModules)
{
List<Module> list = new List<Module>();
list.Add(manifestModule);
foreach (Module m in externalModules)
{
if (m != null)
{
list.Add(m);
}
}
foreach (Module m in externalModules)
{
if (m != null)
{
list.Add(m);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="140" endline="160">
public override Module[] GetModules(bool getResourceModules)
{
if (externalModules.Length == 0)
{
return new Module[] { manifestModule };
}
else
{
List<Module> list = new List<Module>();
list.Add(manifestModule);
for (int i = 0; i < manifestModule.File.records.Length; i++)
{
if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
{
list.Add(GetModule(i));
}
}
for (int i = 0; i < manifestModule.File.records.Length; i++)
{
if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
{
list.Add(GetModule(i));
}
}
return list.ToArray();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="161" endline="174">
public override Module GetModule(string name)
{
if (name.Equals(manifestModule.ScopeName, StringComparison.InvariantCultureIgnoreCase))
{
return manifestModule;
}
int index = GetModuleIndex(name);
if (index != -1)
{
return GetModule(index);
}
return null;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="175" endline="186">
private int GetModuleIndex(string name)
{
for (int i = 0; i < manifestModule.File.records.Length; i++)
{
if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
{
return i;
}
}
for (int i = 0; i < manifestModule.File.records.Length; i++)
{
if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
{
return i;
}
}
return -1;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="187" endline="197">
private Module GetModule(int index)
{
if (externalModules[index] != null)
{
return externalModules[index];
}
string location = Path.Combine(Path.GetDirectoryName(this.location), manifestModule.GetString(manifestModule.File.records[index].Name));
return LoadModule(index, File.ReadAllBytes(location), location);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="198" endline="209">
private Module LoadModule(int index, byte[] rawModule, string location)
{
if ((manifestModule.File.records[index].Flags & ContainsNoMetaData) != 0)
{
return externalModules[index] = new ResourceModule(this, manifestModule.GetString(manifestModule.File.records[index].Name), location);
}
else
{
return externalModules[index] = new ModuleReader(this, manifestModule.universe, new MemoryStream(rawModule), location);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="210" endline="223">
public override Module LoadModule(string moduleName, byte[] rawModule)
{
int index = GetModuleIndex(moduleName);
if (index == -1)
{
throw new ArgumentException();
}
if (externalModules[index] != null)
{
return externalModules[index];
}
return LoadModule(index, rawModule, null);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCodes.cs" startline="258" endline="715">
{
switch (value)
{
case 0
return "nop";
case 1
return "break";
case 2
return "ldarg.0";
case 3
return "ldarg.1";
case 4
return "ldarg.2";
case 5
return "ldarg.3";
case 6
return "ldloc.0";
case 7
return "ldloc.1";
case 8
return "ldloc.2";
case 9
return "ldloc.3";
case 10
return "stloc.0";
case 11
return "stloc.1";
case 12
return "stloc.2";
case 13
return "stloc.3";
case 14
return "ldarg.s";
case 15
return "ldarga.s";
case 16
return "starg.s";
case 17
return "ldloc.s";
case 18
return "ldloca.s";
case 19
return "stloc.s";
case 20
return "ldnull";
case 21
return "ldc.i4.m1";
case 22
return "ldc.i4.0";
case 23
return "ldc.i4.1";
case 24
return "ldc.i4.2";
case 25
return "ldc.i4.3";
case 26
return "ldc.i4.4";
case 27
return "ldc.i4.5";
case 28
return "ldc.i4.6";
case 29
return "ldc.i4.7";
case 30
return "ldc.i4.8";
case 31
return "ldc.i4.s";
case 32
return "ldc.i4";
case 33
return "ldc.i8";
case 34
return "ldc.r4";
case 35
return "ldc.r8";
case 37
return "dup";
case 38
return "pop";
case 39
return "jmp";
case 40
return "call";
case 41
return "calli";
case 42
return "ret";
case 43
return "br.s";
case 44
return "brfalse.s";
case 45
return "brtrue.s";
case 46
return "beq.s";
case 47
return "bge.s";
case 48
return "bgt.s";
case 49
return "ble.s";
case 50
return "blt.s";
case 51
return "bne.un.s";
case 52
return "bge.un.s";
case 53
return "bgt.un.s";
case 54
return "ble.un.s";
case 55
return "blt.un.s";
case 56
return "br";
case 57
return "brfalse";
case 58
return "brtrue";
case 59
return "beq";
case 60
return "bge";
case 61
return "bgt";
case 62
return "ble";
case 63
return "blt";
case 64
return "bne.un";
case 65
return "bge.un";
case 66
return "bgt.un";
case 67
return "ble.un";
case 68
return "blt.un";
case 69
return "switch";
case 70
return "ldind.i1";
case 71
return "ldind.u1";
case 72
return "ldind.i2";
case 73
return "ldind.u2";
case 74
return "ldind.i4";
case 75
return "ldind.u4";
case 76
return "ldind.i8";
case 77
return "ldind.i";
case 78
return "ldind.r4";
case 79
return "ldind.r8";
case 80
return "ldind.ref";
case 81
return "stind.ref";
case 82
return "stind.i1";
case 83
return "stind.i2";
case 84
return "stind.i4";
case 85
return "stind.i8";
case 86
return "stind.r4";
case 87
return "stind.r8";
case 88
return "add";
case 89
return "sub";
case 90
return "mul";
case 91
return "div";
case 92
return "div.un";
case 93
return "rem";
case 94
return "rem.un";
case 95
return "and";
case 96
return "or";
case 97
return "xor";
case 98
return "shl";
case 99
return "shr";
case 100
return "shr.un";
case 101
return "neg";
case 102
return "not";
case 103
return "conv.i1";
case 104
return "conv.i2";
case 105
return "conv.i4";
case 106
return "conv.i8";
case 107
return "conv.r4";
case 108
return "conv.r8";
case 109
return "conv.u4";
case 110
return "conv.u8";
case 111
return "callvirt";
case 112
return "cpobj";
case 113
return "ldobj";
case 114
return "ldstr";
case 115
return "newobj";
case 116
return "castclass";
case 117
return "isinst";
case 118
return "conv.r.un";
case 121
return "unbox";
case 122
return "throw";
case 123
return "ldfld";
case 124
return "ldflda";
case 125
return "stfld";
case 126
return "ldsfld";
case 127
return "ldsflda";
case 128
return "stsfld";
case 129
return "stobj";
case 130
return "conv.ovf.i1.un";
case 131
return "conv.ovf.i2.un";
case 132
return "conv.ovf.i4.un";
case 133
return "conv.ovf.i8.un";
case 134
return "conv.ovf.u1.un";
case 135
return "conv.ovf.u2.un";
case 136
return "conv.ovf.u4.un";
case 137
return "conv.ovf.u8.un";
case 138
return "conv.ovf.i.un";
case 139
return "conv.ovf.u.un";
case 140
return "box";
case 141
return "newarr";
case 142
return "ldlen";
case 143
return "ldelema";
case 144
return "ldelem.i1";
case 145
return "ldelem.u1";
case 146
return "ldelem.i2";
case 147
return "ldelem.u2";
case 148
return "ldelem.i4";
case 149
return "ldelem.u4";
case 150
return "ldelem.i8";
case 151
return "ldelem.i";
case 152
return "ldelem.r4";
case 153
return "ldelem.r8";
case 154
return "ldelem.ref";
case 155
return "stelem.i";
case 156
return "stelem.i1";
case 157
return "stelem.i2";
case 158
return "stelem.i4";
case 159
return "stelem.i8";
case 160
return "stelem.r4";
case 161
return "stelem.r8";
case 162
return "stelem.ref";
case 163
return "ldelem";
case 164
return "stelem";
case 165
return "unbox.any";
case 179
return "conv.ovf.i1";
case 180
return "conv.ovf.u1";
case 181
return "conv.ovf.i2";
case 182
return "conv.ovf.u2";
case 183
return "conv.ovf.i4";
case 184
return "conv.ovf.u4";
case 185
return "conv.ovf.i8";
case 186
return "conv.ovf.u8";
case 194
return "refanyval";
case 195
return "ckfinite";
case 198
return "mkrefany";
case 208
return "ldtoken";
case 209
return "conv.u2";
case 210
return "conv.u1";
case 211
return "conv.i";
case 212
return "conv.ovf.i";
case 213
return "conv.ovf.u";
case 214
return "add.ovf";
case 215
return "add.ovf.un";
case 216
return "mul.ovf";
case 217
return "mul.ovf.un";
case 218
return "sub.ovf";
case 219
return "sub.ovf.un";
case 220
return "endfinally";
case 221
return "leave";
case 222
return "leave.s";
case 223
return "stind.i";
case 224
return "conv.u";
case 248
return "prefix7";
case 249
return "prefix6";
case 250
return "prefix5";
case 251
return "prefix4";
case 252
return "prefix3";
case 253
return "prefix2";
case 254
return "prefix1";
case 255
return "prefixref";
case -512
return "arglist";
case -511
return "ceq";
case -510
return "cgt";
case -509
return "cgt.un";
case -508
return "clt";
case -507
return "clt.un";
case -506
return "ldftn";
case -505
return "ldvirtftn";
case -503
return "ldarg";
case -502
return "ldarga";
case -501
return "starg";
case -500
return "ldloc";
case -499
return "ldloca";
case -498
return "stloc";
case -497
return "localloc";
case -495
return "endfilter";
case -494
return "unaligned.";
case -493
return "volatile.";
case -492
return "tail.";
case -491
return "initobj";
case -490
return "constrained.";
case -489
return "cpblk";
case -488
return "initblk";
case -486
return "rethrow";
case -484
return "sizeof";
case -483
return "refanytype";
case -482
return "readonly.";
}
throw new ArgumentOutOfRangeException();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCodes.cs" startline="716" endline="747">
public static bool TakesSingleByteArgument(OpCode inst)
{
switch (inst.Value)
{
case 14
case 15
case 16
case 17
case 18
case 19
case 31
case 43
case 44
case 45
case 46
case 47
case 48
case 49
case 50
case 51
case 52
case 53
case 54
case 55
case 222
case -494
return true;
default
return false;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCodes.cs" startline="30" endline="255">
public static readonly OpCode Nop = new OpCode(4888);
public static readonly OpCode Break = new OpCode(4199116);
public static readonly OpCode Ldarg_0 = new OpCode(8492847);
public static readonly OpCode Ldarg_1 = new OpCode(12687151);
public static readonly OpCode Ldarg_2 = new OpCode(16881455);
public static readonly OpCode Ldarg_3 = new OpCode(21075759);
public static readonly OpCode Ldloc_0 = new OpCode(25270063);
public static readonly OpCode Ldloc_1 = new OpCode(29464367);
public static readonly OpCode Ldloc_2 = new OpCode(33658671);
public static readonly OpCode Ldloc_3 = new OpCode(37852975);
public static readonly OpCode Stloc_0 = new OpCode(41949467);
public static readonly OpCode Stloc_1 = new OpCode(46143771);
public static readonly OpCode Stloc_2 = new OpCode(50338075);
public static readonly OpCode Stloc_3 = new OpCode(54532379);
public static readonly OpCode Ldarg_S = new OpCode(58824508);
public static readonly OpCode Ldarga_S = new OpCode(63224012);
public static readonly OpCode Starg_S = new OpCode(67115304);
public static readonly OpCode Ldloc_S = new OpCode(71407420);
public static readonly OpCode Ldloca_S = new OpCode(75806924);
public static readonly OpCode Stloc_S = new OpCode(79698216);
public static readonly OpCode Ldnull = new OpCode(84609339);
public static readonly OpCode Ldc_I4_M1 = new OpCode(88389823);
public static readonly OpCode Ldc_I4_0 = new OpCode(92584127);
public static readonly OpCode Ldc_I4_1 = new OpCode(96778431);
public static readonly OpCode Ldc_I4_2 = new OpCode(100972735);
public static readonly OpCode Ldc_I4_3 = new OpCode(105167039);
public static readonly OpCode Ldc_I4_4 = new OpCode(109361343);
public static readonly OpCode Ldc_I4_5 = new OpCode(113555647);
public static readonly OpCode Ldc_I4_6 = new OpCode(117749951);
public static readonly OpCode Ldc_I4_7 = new OpCode(121944255);
public static readonly OpCode Ldc_I4_8 = new OpCode(126138559);
public static readonly OpCode Ldc_I4_S = new OpCode(130332874);
public static readonly OpCode Ldc_I4 = new OpCode(134530584);
public static readonly OpCode Ldc_I8 = new OpCode(138827489);
public static readonly OpCode Ldc_R4 = new OpCode(143124407);
public static readonly OpCode Ldc_R8 = new OpCode(147421301);
public static readonly OpCode Dup = new OpCode(155404637);
public static readonly OpCode Pop = new OpCode(159393399);
public static readonly OpCode Jmp = new OpCode(163582686);
public static readonly OpCode Call = new OpCode(168690130);
public static readonly OpCode Calli = new OpCode(172884439);
public static readonly OpCode Ret = new OpCode(176258034);
public static readonly OpCode Br_S = new OpCode(180356455);
public static readonly OpCode Brfalse_S = new OpCode(184566035);
public static readonly OpCode Brtrue_S = new OpCode(188760339);
public static readonly OpCode Beq_S = new OpCode(192949342);
public static readonly OpCode Bge_S = new OpCode(197143646);
public static readonly OpCode Bgt_S = new OpCode(201337950);
public static readonly OpCode Ble_S = new OpCode(205532254);
public static readonly OpCode Blt_S = new OpCode(209726558);
public static readonly OpCode Bne_Un_S = new OpCode(213920862);
public static readonly OpCode Bge_Un_S = new OpCode(218115166);
public static readonly OpCode Bgt_Un_S = new OpCode(222309470);
public static readonly OpCode Ble_Un_S = new OpCode(226503774);
public static readonly OpCode Blt_Un_S = new OpCode(230698078);
public static readonly OpCode Br = new OpCode(234885812);
public static readonly OpCode Brfalse = new OpCode(239095392);
public static readonly OpCode Brtrue = new OpCode(243289696);
public static readonly OpCode Beq = new OpCode(247475279);
public static readonly OpCode Bge = new OpCode(251669583);
public static readonly OpCode Bgt = new OpCode(255863887);
public static readonly OpCode Ble = new OpCode(260058191);
public static readonly OpCode Blt = new OpCode(264252495);
public static readonly OpCode Bne_Un = new OpCode(268446799);
public static readonly OpCode Bge_Un = new OpCode(272641103);
public static readonly OpCode Bgt_Un = new OpCode(276835407);
public static readonly OpCode Ble_Un = new OpCode(281029711);
public static readonly OpCode Blt_Un = new OpCode(285224015);
public static readonly OpCode Switch = new OpCode(289427051);
public static readonly OpCode Ldind_I1 = new OpCode(293929358);
public static readonly OpCode Ldind_U1 = new OpCode(298123662);
public static readonly OpCode Ldind_I2 = new OpCode(302317966);
public static readonly OpCode Ldind_U2 = new OpCode(306512270);
public static readonly OpCode Ldind_I4 = new OpCode(310706574);
public static readonly OpCode Ldind_U4 = new OpCode(314900878);
public static readonly OpCode Ldind_I8 = new OpCode(319197782);
public static readonly OpCode Ldind_I = new OpCode(323289486);
public static readonly OpCode Ldind_R4 = new OpCode(327688990);
public static readonly OpCode Ldind_R8 = new OpCode(331985894);
public static readonly OpCode Ldind_Ref = new OpCode(336282798);
public static readonly OpCode Stind_Ref = new OpCode(339768820);
public static readonly OpCode Stind_I1 = new OpCode(343963124);
public static readonly OpCode Stind_I2 = new OpCode(348157428);
public static readonly OpCode Stind_I4 = new OpCode(352351732);
public static readonly OpCode Stind_I8 = new OpCode(356551166);
public static readonly OpCode Stind_R4 = new OpCode(360755730);
public static readonly OpCode Stind_R8 = new OpCode(364955164);
public static readonly OpCode Add = new OpCode(369216329);
public static readonly OpCode Sub = new OpCode(373410633);
public static readonly OpCode Mul = new OpCode(377604937);
public static readonly OpCode Div = new OpCode(381799241);
public static readonly OpCode Div_Un = new OpCode(385993545);
public static readonly OpCode Rem = new OpCode(390187849);
public static readonly OpCode Rem_Un = new OpCode(394382153);
public static readonly OpCode And = new OpCode(398576457);
public static readonly OpCode Or = new OpCode(402770761);
public static readonly OpCode Xor = new OpCode(406965065);
public static readonly OpCode Shl = new OpCode(411159369);
public static readonly OpCode Shr = new OpCode(415353673);
public static readonly OpCode Shr_Un = new OpCode(419547977);
public static readonly OpCode Neg = new OpCode(423737322);
public static readonly OpCode Not = new OpCode(427931626);
public static readonly OpCode Conv_I1 = new OpCode(432331130);
public static readonly OpCode Conv_I2 = new OpCode(436525434);
public static readonly OpCode Conv_I4 = new OpCode(440719738);
public static readonly OpCode Conv_I8 = new OpCode(445016642);
public static readonly OpCode Conv_R4 = new OpCode(449313546);
public static readonly OpCode Conv_R8 = new OpCode(453610450);
public static readonly OpCode Conv_U4 = new OpCode(457496954);
public static readonly OpCode Conv_U8 = new OpCode(461793858);
public static readonly OpCode Callvirt = new OpCode(466484004);
public static readonly OpCode Cpobj = new OpCode(469790542);
public static readonly OpCode Ldobj = new OpCode(474077528);
public static readonly OpCode Ldstr = new OpCode(478872210);
public static readonly OpCode Newobj = new OpCode(483158791);
public static readonly OpCode Castclass = new OpCode(487311950);
public static readonly OpCode Isinst = new OpCode(491095854);
public static readonly OpCode Conv_R_Un = new OpCode(495553490);
public static readonly OpCode Unbox = new OpCode(507874780);
public static readonly OpCode Throw = new OpCode(511759452);
public static readonly OpCode Ldfld = new OpCode(516056466);
public static readonly OpCode Ldflda = new OpCode(520455970);
public static readonly OpCode Stfld = new OpCode(524347262);
public static readonly OpCode Ldsfld = new OpCode(528588249);
public static readonly OpCode Ldsflda = new OpCode(532987753);
public static readonly OpCode Stsfld = new OpCode(536879045);
public static readonly OpCode Stobj = new OpCode(541090290);
public static readonly OpCode Conv_Ovf_I1_Un = new OpCode(545577338);
public static readonly OpCode Conv_Ovf_I2_Un = new OpCode(549771642);
public static readonly OpCode Conv_Ovf_I4_Un = new OpCode(553965946);
public static readonly OpCode Conv_Ovf_I8_Un = new OpCode(558262850);
public static readonly OpCode Conv_Ovf_U1_Un = new OpCode(562354554);
public static readonly OpCode Conv_Ovf_U2_Un = new OpCode(566548858);
public static readonly OpCode Conv_Ovf_U4_Un = new OpCode(570743162);
public static readonly OpCode Conv_Ovf_U8_Un = new OpCode(575040066);
public static readonly OpCode Conv_Ovf_I_Un = new OpCode(579131770);
public static readonly OpCode Conv_Ovf_U_Un = new OpCode(583326074);
public static readonly OpCode Box = new OpCode(587930786);
public static readonly OpCode Newarr = new OpCode(592133640);
public static readonly OpCode Ldlen = new OpCode(595953446);
public static readonly OpCode Ldelema = new OpCode(600157847);
public static readonly OpCode Ldelem_I1 = new OpCode(604352143);
public static readonly OpCode Ldelem_U1 = new OpCode(608546447);
public static readonly OpCode Ldelem_I2 = new OpCode(612740751);
public static readonly OpCode Ldelem_U2 = new OpCode(616935055);
public static readonly OpCode Ldelem_I4 = new OpCode(621129359);
public static readonly OpCode Ldelem_U4 = new OpCode(625323663);
public static readonly OpCode Ldelem_I8 = new OpCode(629620567);
public static readonly OpCode Ldelem_I = new OpCode(633712271);
public static readonly OpCode Ldelem_R4 = new OpCode(638111775);
public static readonly OpCode Ldelem_R8 = new OpCode(642408679);
public static readonly OpCode Ldelem_Ref = new OpCode(646705583);
public static readonly OpCode Stelem_I = new OpCode(650186475);
public static readonly OpCode Stelem_I1 = new OpCode(654380779);
public static readonly OpCode Stelem_I2 = new OpCode(658575083);
public static readonly OpCode Stelem_I4 = new OpCode(662769387);
public static readonly OpCode Stelem_I8 = new OpCode(666968821);
public static readonly OpCode Stelem_R4 = new OpCode(671168255);
public static readonly OpCode Stelem_R8 = new OpCode(675367689);
public static readonly OpCode Stelem_Ref = new OpCode(679567123);
public static readonly OpCode Ldelem = new OpCode(683838727);
public static readonly OpCode Stelem = new OpCode(687965999);
public static readonly OpCode Unbox_Any = new OpCode(692217246);
public static readonly OpCode Conv_Ovf_I1 = new OpCode(751098234);
public static readonly OpCode Conv_Ovf_U1 = new OpCode(755292538);
public static readonly OpCode Conv_Ovf_I2 = new OpCode(759486842);
public static readonly OpCode Conv_Ovf_U2 = new OpCode(763681146);
public static readonly OpCode Conv_Ovf_I4 = new OpCode(767875450);
public static readonly OpCode Conv_Ovf_U4 = new OpCode(772069754);
public static readonly OpCode Conv_Ovf_I8 = new OpCode(776366658);
public static readonly OpCode Conv_Ovf_U8 = new OpCode(780560962);
public static readonly OpCode Refanyval = new OpCode(814012802);
public static readonly OpCode Ckfinite = new OpCode(818514898);
public static readonly OpCode Mkrefany = new OpCode(830595078);
public static readonly OpCode Ldtoken = new OpCode(872728098);
public static readonly OpCode Conv_U2 = new OpCode(876927354);
public static readonly OpCode Conv_U1 = new OpCode(881121658);
public static readonly OpCode Conv_I = new OpCode(885315962);
public static readonly OpCode Conv_Ovf_I = new OpCode(889510266);
public static readonly OpCode Conv_Ovf_U = new OpCode(893704570);
public static readonly OpCode Add_Ovf = new OpCode(897698633);
public static readonly OpCode Add_Ovf_Un = new OpCode(901892937);
public static readonly OpCode Mul_Ovf = new OpCode(906087241);
public static readonly OpCode Mul_Ovf_Un = new OpCode(910281545);
public static readonly OpCode Sub_Ovf = new OpCode(914475849);
public static readonly OpCode Sub_Ovf_Un = new OpCode(918670153);
public static readonly OpCode Endfinally = new OpCode(922751806);
public static readonly OpCode Leave = new OpCode(926945972);
public static readonly OpCode Leave_S = new OpCode(931140291);
public static readonly OpCode Stind_I = new OpCode(935359988);
public static readonly OpCode Conv_U = new OpCode(939841914);
public static readonly OpCode Prefix7 = new OpCode(1040189696);
public static readonly OpCode Prefix6 = new OpCode(1044384000);
public static readonly OpCode Prefix5 = new OpCode(1048578304);
public static readonly OpCode Prefix4 = new OpCode(1052772608);
public static readonly OpCode Prefix3 = new OpCode(1056966912);
public static readonly OpCode Prefix2 = new OpCode(1061161216);
public static readonly OpCode Prefix1 = new OpCode(1065355520);
public static readonly OpCode Prefixref = new OpCode(1069549824);
public static readonly OpCode Arglist = new OpCode(-2147170789);
public static readonly OpCode Ceq = new OpCode(-2142966567);
public static readonly OpCode Cgt = new OpCode(-2138772263);
public static readonly OpCode Cgt_Un = new OpCode(-2134577959);
public static readonly OpCode Clt = new OpCode(-2130383655);
public static readonly OpCode Clt_Un = new OpCode(-2126189351);
public static readonly OpCode Ldftn = new OpCode(-2122004966);
public static readonly OpCode Ldvirtftn = new OpCode(-2117759533);
public static readonly OpCode Ldarg = new OpCode(-2109627244);
public static readonly OpCode Ldarga = new OpCode(-2105227740);
public static readonly OpCode Starg = new OpCode(-2101336448);
public static readonly OpCode Ldloc = new OpCode(-2097044332);
public static readonly OpCode Ldloca = new OpCode(-2092644828);
public static readonly OpCode Stloc = new OpCode(-2088753536);
public static readonly OpCode Localloc = new OpCode(-2084241010);
public static readonly OpCode Endfilter = new OpCode(-2076160335);
public static readonly OpCode Unaligned = new OpCode(-2071982151);
public static readonly OpCode Volatile = new OpCode(-2067787858);
public static readonly OpCode Tailcall = new OpCode(-2063593554);
public static readonly OpCode Initobj = new OpCode(-2059384859);
public static readonly OpCode Constrained = new OpCode(-2055204938);
public static readonly OpCode Cpblk = new OpCode(-2050974371);
public static readonly OpCode Initblk = new OpCode(-2046780067);
public static readonly OpCode Rethrow = new OpCode(-2038428509);
public static readonly OpCode Sizeof = new OpCode(-2029730269);
public static readonly OpCode Refanytype = new OpCode(-2025531014);
public static readonly OpCode Readonly = new OpCode(-2021650514);
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="41" endline="114">
private readonly Guid mvid = Guid.NewGuid();
private long imageBaseAddress = 0x00400000;
private readonly AssemblyBuilder asm;
internal readonly string moduleName;
internal readonly string fileName;
internal readonly ISymbolWriterImpl symbolWriter;
private readonly TypeBuilder moduleType;
private readonly List<TypeBuilder> types = new List<TypeBuilder>();
private readonly Dictionary<Type, int> typeTokens = new Dictionary<Type, int>();
private readonly Dictionary<Type, int> memberRefTypeTokens = new Dictionary<Type, int>();
private readonly Dictionary<string, TypeBuilder> fullNameToType = new Dictionary<string, TypeBuilder>();
internal readonly ByteBuffer methodBodies = new ByteBuffer(128 * 1024);
internal readonly List<int> tokenFixupOffsets = new List<int>();
internal readonly ByteBuffer initializedData = new ByteBuffer(512);
internal readonly ByteBuffer manifestResources = new ByteBuffer(512);
internal ResourceSection unmanagedResources;
private readonly Dictionary<MemberInfo, int> importedMembers = new Dictionary<MemberInfo, int>();
private readonly Dictionary<MemberRefKey, int> importedMemberRefs = new Dictionary<MemberRefKey, int>();
private readonly Dictionary<Assembly, int> referencedAssemblies = new Dictionary<Assembly, int>();
private List<AssemblyName> referencedAssemblyNames;
private int nextPseudoToken = -1;
private readonly List<int> resolvedTokens = new List<int>();
internal readonly TableHeap Tables = new TableHeap();
internal readonly StringHeap Strings = new StringHeap();
internal readonly UserStringHeap UserStrings = new UserStringHeap();
internal readonly GuidHeap Guids = new GuidHeap();
internal readonly BlobHeap Blobs = new BlobHeap();
struct MemberRefKey
{
private readonly Type type;
private readonly string name;
private readonly Signature signature;
internal MemberRefKey(Type type, string name, Signature signature)
{
this.type = type;
this.name = name;
this.signature = signature;
}
public bool Equals(MemberRefKey other)
{
return other.type.Equals(type)
&& other.name == name
&& other.signature.Equals(signature);
}
public override bool Equals(object obj)
{
MemberRefKey? other = obj as MemberRefKey?;
return other != null && Equals(other);
}
public override int GetHashCode()
{
return type.GetHashCode() + name.GetHashCode() + signature.GetHashCode();
}
}
internal ModuleBuilder(AssemblyBuilder asm, string moduleName, string fileName, bool emitSymbolInfo)
{
this.asm = asm;
this.moduleName = moduleName;
this.fileName = fileName;
if (emitSymbolInfo)
{
symbolWriter = SymbolSupport.CreateSymbolWriterFor(this);
}
moduleType = new TypeBuilder(this, "<Module>", null, 0);
types.Add(moduleType);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="115" endline="125">
internal void PopulatePropertyAndEventTables()
{
foreach (TypeBuilder type in types)
{
type.PopulatePropertyAndEventTables();
}
foreach (TypeBuilder type in types)
{
type.PopulatePropertyAndEventTables();
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="126" endline="135">
internal void WriteTypeDefTable(MetadataWriter mw)
{
int fieldList = 1;
int methodList = 1;
foreach (TypeBuilder type in types)
{
type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
}
foreach (TypeBuilder type in types)
{
type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="136" endline="144">
internal void WriteMethodDefTable(int baseRVA, MetadataWriter mw)
{
int paramList = 1;
foreach (TypeBuilder type in types)
{
type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
}
foreach (TypeBuilder type in types)
{
type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="145" endline="152">
internal void WriteParamTable(MetadataWriter mw)
{
foreach (TypeBuilder type in types)
{
type.WriteParamRecords(mw);
}
foreach (TypeBuilder type in types)
{
type.WriteParamRecords(mw);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
internal void WriteFieldTable(MetadataWriter mw)
{
foreach (TypeBuilder type in types)
{
type.WriteFieldRecords(mw);
}
foreach (TypeBuilder type in types)
{
type.WriteFieldRecords(mw);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="191" endline="200">
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
{
TypeBuilder tb = DefineType(name, attr, parent);
foreach (Type iface in interfaces)
{
tb.AddInterfaceImplementation(iface);
}
foreach (Type iface in interfaces)
{
tb.AddInterfaceImplementation(iface);
}
return tb;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="201" endline="211">
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
{
if (parent == null && (attr & TypeAttributes.Interface) == 0)
{
parent = universe.System_Object;
}
TypeBuilder typeBuilder = new TypeBuilder(this, name, parent, attr);
PostDefineType(typeBuilder, packingSize, typesize);
return typeBuilder;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="212" endline="218">
public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType)
{
TypeBuilder tb = DefineType(name, (visibility & TypeAttributes.VisibilityMask) | TypeAttributes.Sealed, universe.System_Enum);
FieldBuilder fb = tb.DefineField("value__", underlyingType, FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
return new EnumBuilder(tb, fb);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="219" endline="236">
internal TypeBuilder DefineNestedTypeHelper(TypeBuilder enclosingType, string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
{
if (parent == null && (attr & TypeAttributes.Interface) == 0)
{
parent = universe.System_Object;
}
TypeBuilder typeBuilder = new TypeBuilder(enclosingType, name, parent, attr);
PostDefineType(typeBuilder, packingSize, typesize);
if (enclosingType != null)
{
NestedClassTable.Record rec = new NestedClassTable.Record();
rec.NestedClass = typeBuilder.MetadataToken;
rec.EnclosingClass = enclosingType.MetadataToken;
this.NestedClass.AddRecord(rec);
}
return typeBuilder;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="237" endline="250">
private void PostDefineType(TypeBuilder typeBuilder, PackingSize packingSize, int typesize)
{
types.Add(typeBuilder);
fullNameToType.Add(typeBuilder.FullName, typeBuilder);
if (packingSize != PackingSize.Unspecified || typesize != 0)
{
ClassLayoutTable.Record rec = new ClassLayoutTable.Record();
rec.PackingSize = (short)packingSize;
rec.ClassSize = typesize;
rec.Parent = typeBuilder.MetadataToken;
this.ClassLayout.AddRecord(rec);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="301" endline="311">
internal void AddTypeForwarder(Type type)
{
ExportType(type);
foreach (Type nested in type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic))
{
AddTypeForwarder(nested);
}
foreach (Type nested in type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic))
{
AddTypeForwarder(nested);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="312" endline="332">
private int ExportType(Type type)
{
ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
rec.TypeDefId = type.MetadataToken;
rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
if (type.IsNested)
{
rec.Flags = 0;
rec.TypeNamespace = 0;
rec.Implementation = ExportType(type.DeclaringType);
}
else
{
rec.Flags = 0x00200000;	// CorTypeAttr.tdForwarder
string ns = type.Namespace;
rec.TypeNamespace = ns == null ? 0
rec.Implementation = ImportAssemblyRef(type.Assembly);
}
return 0x27000000 | this.ExportedType.FindOrAddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="343" endline="352">
internal void SetCustomAttribute(int token, CustomAttributeBuilder customBuilder)
{
Debug.Assert(!customBuilder.IsPseudoCustomAttribute);
CustomAttributeTable.Record rec = new CustomAttributeTable.Record();
rec.Parent = token;
rec.Type = this.GetConstructorToken(customBuilder.Constructor).Token;
rec.Value = customBuilder.WriteBlob(this);
this.CustomAttribute.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="353" endline="362">
internal void AddDeclarativeSecurity(int token, System.Security.Permissions.SecurityAction securityAction, System.Security.PermissionSet permissionSet)
{
DeclSecurityTable.Record rec = new DeclSecurityTable.Record();
rec.Action = (short)securityAction;
rec.Parent = token;
rec.PermissionSet = this.Blobs.Add(ByteBuffer.Wrap(System.Text.Encoding.Unicode.GetBytes(permissionSet.ToXml().ToString())));
this.DeclSecurity.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="363" endline="395">
internal void AddDeclarativeSecurity(int token, List<CustomAttributeBuilder> declarativeSecurity)
{
Dictionary<int, List<CustomAttributeBuilder>> ordered = new Dictionary<int, List<CustomAttributeBuilder>>();
foreach (CustomAttributeBuilder cab in declarativeSecurity)
{
int action;
if (cab.ConstructorArgumentCount == 0)
{
action = (int)System.Security.Permissions.SecurityAction.LinkDemand;
}
else
{
action = (int)cab.GetConstructorArgument(0);
}
List<CustomAttributeBuilder> list;
if (!ordered.TryGetValue(action, out list))
{
list = new List<CustomAttributeBuilder>();
ordered.Add(action, list);
}
list.Add(cab);
}
foreach (CustomAttributeBuilder cab in declarativeSecurity)
{
int action;
if (cab.ConstructorArgumentCount == 0)
{
action = (int)System.Security.Permissions.SecurityAction.LinkDemand;
}
else
{
action = (int)cab.GetConstructorArgument(0);
}
List<CustomAttributeBuilder> list;
if (!ordered.TryGetValue(action, out list))
{
list = new List<CustomAttributeBuilder>();
ordered.Add(action, list);
}
list.Add(cab);
}
foreach (KeyValuePair<int, List<CustomAttributeBuilder>> kv in ordered)
{
DeclSecurityTable.Record rec = new DeclSecurityTable.Record();
rec.Action = (short)kv.Key;
rec.Parent = token;
rec.PermissionSet = WriteDeclSecurityBlob(kv.Value);
this.DeclSecurity.AddRecord(rec);
}
foreach (KeyValuePair<int, List<CustomAttributeBuilder>> kv in ordered)
{
DeclSecurityTable.Record rec = new DeclSecurityTable.Record();
rec.Action = (short)kv.Key;
rec.Parent = token;
rec.PermissionSet = WriteDeclSecurityBlob(kv.Value);
this.DeclSecurity.AddRecord(rec);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="396" endline="412">
private int WriteDeclSecurityBlob(List<CustomAttributeBuilder> list)
{
ByteBuffer namedArgs = new ByteBuffer(100);
ByteBuffer bb = new ByteBuffer(list.Count * 100);
bb.Write((byte)'.');
bb.WriteCompressedInt(list.Count);
foreach (CustomAttributeBuilder cab in list)
{
bb.Write(cab.Constructor.DeclaringType.AssemblyQualifiedName);
namedArgs.Clear();
cab.WriteNamedArgumentsForDeclSecurity(this, namedArgs);
bb.WriteCompressedInt(namedArgs.Length);
bb.Write(namedArgs);
}
foreach (CustomAttributeBuilder cab in list)
{
bb.Write(cab.Constructor.DeclaringType.AssemblyQualifiedName);
namedArgs.Clear();
cab.WriteNamedArgumentsForDeclSecurity(this, namedArgs);
bb.WriteCompressedInt(namedArgs.Length);
bb.Write(namedArgs);
}
return this.Blobs.Add(bb);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="413" endline="428">
public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute)
{
ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
rec.Offset = manifestResources.Position;
rec.Flags = (int)attribute;
rec.Name = this.Strings.Add(name);
rec.Implementation = 0;
this.ManifestResource.AddRecord(rec);
manifestResources.Write(0);	// placeholder for the length
manifestResources.Write(stream);
int savePosition = manifestResources.Position;
manifestResources.Position = rec.Offset;
manifestResources.Write(savePosition - (manifestResources.Position + 4));
manifestResources.Position = savePosition;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="433" endline="440">
}
internal override Type GetTypeImpl(string typeName)
{
TypeBuilder type;
fullNameToType.TryGetValue(typeName, out type);
return type;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="441" endline="451">
internal override void GetTypesImpl(List<Type> list)
{
foreach (Type type in types)
{
if (type != moduleType)
{
list.Add(type);
}
}
foreach (Type type in types)
{
if (type != moduleType)
{
list.Add(type);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="462" endline="473">
public TypeToken GetTypeToken(Type type)
{
if (type.Module == this)
{
return new TypeToken(type.GetModuleBuilderToken());
}
else
{
return new TypeToken(ImportType(type));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="474" endline="497">
internal int GetTypeTokenForMemberRef(Type type)
{
if (type.IsGenericTypeDefinition)
{
int token;
if (!memberRefTypeTokens.TryGetValue(type, out token))
{
ByteBuffer spec = new ByteBuffer(5);
Signature.WriteTypeSpec(this, spec, type);
token = 0x1B000000 | this.TypeSpec.AddRecord(this.Blobs.Add(spec));
memberRefTypeTokens.Add(type, token);
}
return token;
}
else if (type.IsModulePseudoType)
{
return 0x1A000000 | this.ModuleRef.FindOrAddRecord(this.Strings.Add(type.Module.ScopeName));
}
else
{
return GetTypeToken(type).Token;
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="504" endline="519">
public FieldToken GetFieldToken(FieldInfo field)
{
FieldBuilder fb = field as FieldBuilder;
if (fb != null && fb.Module == this && !IsFromGenericTypeDefinition(fb))
{
return new FieldToken(fb.MetadataToken);
}
else
{
return new FieldToken(ImportMember(field));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="520" endline="532">
public MethodToken GetMethodToken(MethodInfo method)
{
MethodBuilder mb = method as MethodBuilder;
if (mb != null && mb.ModuleBuilder == this)
{
return new MethodToken(mb.MetadataToken);
}
else
{
return new MethodToken(ImportMember(method));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="533" endline="550">
internal MethodToken GetMethodTokenForIL(MethodInfo method)
{
if (method.IsGenericMethodDefinition)
{
method = method.MakeGenericMethod(method.GetGenericArguments());
}
if (IsFromGenericTypeDefinition(method))
{
return new MethodToken(ImportMember(method));
}
else
{
return GetMethodToken(method);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="551" endline="562">
public MethodToken GetConstructorToken(ConstructorInfo constructor)
{
if (constructor.Module == this && constructor.GetMethodInfo() is MethodBuilder)
{
return new MethodToken(constructor.MetadataToken);
}
else
{
return new MethodToken(ImportMember(constructor));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="563" endline="573">
internal int ImportMember(MethodBase member)
{
int token;
if (!importedMembers.TryGetValue(member, out token))
{
token = member.ImportTo(this);
importedMembers.Add(member, token);
}
return token;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="574" endline="584">
internal int ImportMember(FieldInfo member)
{
int token;
if (!importedMembers.TryGetValue(member, out token))
{
token = member.ImportTo(this);
importedMembers.Add(member, token);
}
return token;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="585" endline="601">
internal int ImportMethodOrField(Type declaringType, string name, Signature sig)
{
int token;
if (!importedMemberRefs.TryGetValue(new MemberRefKey(declaringType, name, sig), out token))
{
MemberRefTable.Record rec = new MemberRefTable.Record();
rec.Class = GetTypeTokenForMemberRef(declaringType);
rec.Name = this.Strings.Add(name);
ByteBuffer bb = new ByteBuffer(16);
sig.WriteSig(this, bb);
rec.Signature = this.Blobs.Add(bb);
token = 0x0A000000 | this.MemberRef.AddRecord(rec);
importedMemberRefs.Add(new MemberRefKey(declaringType, name, sig), token);
}
return token;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="602" endline="635">
internal int ImportType(Type type)
{
int token;
if (!typeTokens.TryGetValue(type, out token))
{
if (type.HasElementType || (type.IsGenericType && !type.IsGenericTypeDefinition))
{
ByteBuffer spec = new ByteBuffer(5);
Signature.WriteTypeSpec(this, spec, type);
token = 0x1B000000 | this.TypeSpec.AddRecord(this.Blobs.Add(spec));
}
else
{
TypeRefTable.Record rec = new TypeRefTable.Record();
if (type.IsNested)
{
rec.ResolutionScope = GetTypeToken(type.DeclaringType).Token;
rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
rec.TypeNameSpace = 0;
}
else
{
rec.ResolutionScope = ImportAssemblyRef(type.Assembly);
rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
string ns = type.Namespace;
rec.TypeNameSpace = ns == null ? 0
}
token = 0x01000000 | this.TypeRef.AddRecord(rec);
}
typeTokens.Add(type, token);
}
return token;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="636" endline="650">
private int ImportAssemblyRef(Assembly asm)
{
int token;
if (!referencedAssemblies.TryGetValue(asm, out token))
{
token = 0x23800001 + referencedAssemblies.Count;
referencedAssemblies.Add(asm, token);
}
return token;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="651" endline="677">
internal void FillAssemblyRefTable()
{
int[] realtokens = new int[referencedAssemblies.Count];
foreach (KeyValuePair<Assembly, int> kv in referencedAssemblies)
{
realtokens[(kv.Value & 0x7FFFFF) - 1] = FindOrAddAssemblyRef(kv.Key.GetName());
}
foreach (KeyValuePair<Assembly, int> kv in referencedAssemblies)
{
realtokens[(kv.Value & 0x7FFFFF) - 1] = FindOrAddAssemblyRef(kv.Key.GetName());
}
for (int i = 0; i < this.TypeRef.records.Length; i++)
{
int resolutionScope = this.TypeRef.records[i].ResolutionScope;
if ((resolutionScope >> 24) == AssemblyRefTable.Index)
{
this.TypeRef.records[i].ResolutionScope = realtokens[(resolutionScope & 0x7FFFFF) - 1];
}
}
for (int i = 0; i < this.TypeRef.records.Length; i++)
{
int resolutionScope = this.TypeRef.records[i].ResolutionScope;
if ((resolutionScope >> 24) == AssemblyRefTable.Index)
{
this.TypeRef.records[i].ResolutionScope = realtokens[(resolutionScope & 0x7FFFFF) - 1];
}
}
for (int i = 0; i < this.ExportedType.records.Length; i++)
{
int implementation = this.ExportedType.records[i].Implementation;
if ((implementation >> 24) == AssemblyRefTable.Index)
{
this.ExportedType.records[i].Implementation = realtokens[(implementation & 0x7FFFFF) - 1];
}
}
for (int i = 0; i < this.ExportedType.records.Length; i++)
{
int implementation = this.ExportedType.records[i].Implementation;
if ((implementation >> 24) == AssemblyRefTable.Index)
{
this.ExportedType.records[i].Implementation = realtokens[(implementation & 0x7FFFFF) - 1];
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="678" endline="714">
private int FindOrAddAssemblyRef(AssemblyName name)
{
AssemblyRefTable.Record rec = new AssemblyRefTable.Record();
Version ver = name.Version;
rec.MajorVersion = (ushort)ver.Major;
rec.MinorVersion = (ushort)ver.Minor;
rec.BuildNumber = (ushort)ver.Build;
rec.RevisionNumber = (ushort)ver.Revision;
rec.Flags = (int)(name.Flags & AssemblyNameFlags.Retargetable);
byte[] publicKeyOrToken = null;
if (usePublicKeyAssemblyReference)
{
publicKeyOrToken = name.GetPublicKey();
}
if (publicKeyOrToken == null || publicKeyOrToken.Length == 0)
{
publicKeyOrToken = name.GetPublicKeyToken();
}
else
{
const int PublicKey = 0x0001;
rec.Flags |= PublicKey;
}
rec.PublicKeyOrToken = this.Blobs.Add(ByteBuffer.Wrap(publicKeyOrToken));
rec.Name = this.Strings.Add(name.Name);
if (name.CultureInfo != null)
{
rec.Culture = this.Strings.Add(name.CultureInfo.Name);
}
else
{
rec.Culture = 0;
}
rec.HashValue = 0;
return 0x23000000 | this.AssemblyRef.FindOrAddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="715" endline="727">
internal void WriteSymbolTokenMap()
{
for (int i = 0; i < resolvedTokens.Count; i++)
{
int newToken = resolvedTokens[i];
int oldToken = (i + 1) | (newToken & ~0xFFFFFF);
SymbolSupport.RemapToken(symbolWriter, oldToken, newToken);
}
for (int i = 0; i < resolvedTokens.Count; i++)
{
int newToken = resolvedTokens[i];
int oldToken = (i + 1) | (newToken & ~0xFFFFFF);
SymbolSupport.RemapToken(symbolWriter, oldToken, newToken);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="728" endline="737">
internal void RegisterTokenFixup(int pseudoToken, int realToken)
{
int index = -(pseudoToken + 1);
while (resolvedTokens.Count <= index)
{
resolvedTokens.Add(0);
}
while (resolvedTokens.Count <= index)
{
resolvedTokens.Add(0);
}
resolvedTokens[index] = realToken;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="749" endline="765">
internal void FixupMethodBodyTokens()
{
int methodToken = 0x06000001;
int fieldToken = 0x04000001;
int parameterToken = 0x08000001;
foreach (TypeBuilder type in types)
{
type.ResolveMethodAndFieldTokens(ref methodToken, ref fieldToken, ref parameterToken);
}
foreach (TypeBuilder type in types)
{
type.ResolveMethodAndFieldTokens(ref methodToken, ref fieldToken, ref parameterToken);
}
foreach (int offset in tokenFixupOffsets)
{
methodBodies.Position = offset;
int pseudoToken = methodBodies.GetInt32AtCurrentPosition();
methodBodies.Write(ResolvePseudoToken(pseudoToken));
}
foreach (int offset in tokenFixupOffsets)
{
methodBodies.Position = offset;
int pseudoToken = methodBodies.GetInt32AtCurrentPosition();
methodBodies.Write(ResolvePseudoToken(pseudoToken));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="766" endline="796">
private int GetHeaderLength()
{
return
4 + // Signature
2 + // MajorVersion
2 + // MinorVersion
4 + // Reserved
4 + // ImageRuntimeVersion Length
StringToPaddedUTF8Length(asm.ImageRuntimeVersion) +
2 + // Flags
2 + // Streams
4 + // #~ Offset
4 + // #~ Size
4 + // StringToPaddedUTF8Length("#~")
4 + // #Strings Offset
4 + // #Strings Size
12 + // StringToPaddedUTF8Length("#Strings")
4 + // #US Offset
4 + // #US Size
4 + // StringToPaddedUTF8Length("#US")
4 + // #GUID Offset
4 + // #GUID Size
8 + // StringToPaddedUTF8Length("#GUID")
(Blobs.IsEmpty ? 0
(
4 + // #Blob Offset
4 + // #Blob Size
8   // StringToPaddedUTF8Length("#Blob")
));
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="797" endline="803">
internal int MetadataLength
{
get
{
return GetHeaderLength() + (Blobs.IsEmpty ? 0
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="804" endline="864">
}
internal void WriteMetadata(MetadataWriter mw)
{
mw.Write(0x424A5342);			// Signature ("BSJB")
mw.Write((ushort)1);			// MajorVersion
mw.Write((ushort)1);			// MinorVersion
mw.Write(0);					// Reserved
byte[] version = StringToPaddedUTF8(asm.ImageRuntimeVersion);
mw.Write(version.Length);		// Length
mw.Write(version);
mw.Write((ushort)0);			// Flags
if (Blobs.IsEmpty)
{
mw.Write((ushort)4);		// Streams
}
else
{
mw.Write((ushort)5);		// Streams
}
int offset = GetHeaderLength();
mw.Write(offset);				// Offset
mw.Write(Tables.Length);		// Size
mw.Write(StringToPaddedUTF8("#~"));
offset += Tables.Length;
mw.Write(offset);				// Offset
mw.Write(Strings.Length);		// Size
mw.Write(StringToPaddedUTF8("#Strings"));
offset += Strings.Length;
mw.Write(offset);				// Offset
mw.Write(UserStrings.Length);	// Size
mw.Write(StringToPaddedUTF8("#US"));
offset += UserStrings.Length;
mw.Write(offset);				// Offset
mw.Write(Guids.Length);			// Size
mw.Write(StringToPaddedUTF8("#GUID"));
offset += Guids.Length;
if (!Blobs.IsEmpty)
{
mw.Write(offset);				// Offset
mw.Write(Blobs.Length);			// Size
mw.Write(StringToPaddedUTF8("#Blob"));
}
Tables.Write(mw);
Strings.Write(mw);
UserStrings.Write(mw);
Guids.Write(mw);
if (!Blobs.IsEmpty)
{
Blobs.Write(mw);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="870" endline="876">
private static byte[] StringToPaddedUTF8(string str)
{
byte[] buf = new byte[(System.Text.Encoding.UTF8.GetByteCount(str) + 4) & ~3];
System.Text.Encoding.UTF8.GetBytes(str, 0, str.Length, buf, 0);
return buf;
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="882" endline="908">
internal void ExportTypes(Type[] types, int fileToken)
{
Dictionary<Type, int> declaringTypes = new Dictionary<Type, int>();
foreach (Type type in types)
{
if (!type.IsModulePseudoType && IsVisible(type))
{
ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
rec.Flags = (int)type.Attributes;
rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
string ns = type.Namespace;
rec.TypeNamespace = ns == null ? 0
if (type.IsNested)
{
rec.Implementation = declaringTypes[type.DeclaringType];
}
else
{
rec.Implementation = fileToken;
}
int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
declaringTypes.Add(type, exportTypeToken);
}
}
foreach (Type type in types)
{
if (!type.IsModulePseudoType && IsVisible(type))
{
ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
rec.Flags = (int)type.Attributes;
rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
string ns = type.Namespace;
rec.TypeNamespace = ns == null ? 0
if (type.IsNested)
{
rec.Implementation = declaringTypes[type.DeclaringType];
}
else
{
rec.Implementation = fileToken;
}
int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
declaringTypes.Add(type, exportTypeToken);
}
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="915" endline="1005">
internal void AddConstant(int parentToken, object defaultValue)
{
ConstantTable.Record rec = new ConstantTable.Record();
rec.Parent = parentToken;
ByteBuffer val = new ByteBuffer(16);
if (defaultValue == null)
{
rec.Type = Signature.ELEMENT_TYPE_CLASS;
val.Write((int)0);
}
else if (defaultValue is bool)
{
rec.Type = Signature.ELEMENT_TYPE_BOOLEAN;
val.Write((bool)defaultValue ? (byte)1
}
else if (defaultValue is char)
{
rec.Type = Signature.ELEMENT_TYPE_CHAR;
val.Write((char)defaultValue);
}
else if (defaultValue is sbyte)
{
rec.Type = Signature.ELEMENT_TYPE_I1;
val.Write((sbyte)defaultValue);
}
else if (defaultValue is byte)
{
rec.Type = Signature.ELEMENT_TYPE_U1;
val.Write((byte)defaultValue);
}
else if (defaultValue is short)
{
rec.Type = Signature.ELEMENT_TYPE_I2;
val.Write((short)defaultValue);
}
else if (defaultValue is ushort)
{
rec.Type = Signature.ELEMENT_TYPE_U2;
val.Write((ushort)defaultValue);
}
else if (defaultValue is int)
{
rec.Type = Signature.ELEMENT_TYPE_I4;
val.Write((int)defaultValue);
}
else if (defaultValue is uint)
{
rec.Type = Signature.ELEMENT_TYPE_U4;
val.Write((uint)defaultValue);
}
else if (defaultValue is long)
{
rec.Type = Signature.ELEMENT_TYPE_I8;
val.Write((long)defaultValue);
}
else if (defaultValue is ulong)
{
rec.Type = Signature.ELEMENT_TYPE_U8;
val.Write((ulong)defaultValue);
}
else if (defaultValue is float)
{
rec.Type = Signature.ELEMENT_TYPE_R4;
val.Write((float)defaultValue);
}
else if (defaultValue is double)
{
rec.Type = Signature.ELEMENT_TYPE_R8;
val.Write((double)defaultValue);
}
else if (defaultValue is string)
{
rec.Type = Signature.ELEMENT_TYPE_STRING;
foreach (char c in (string)defaultValue)
{
val.Write(c);
}
foreach (char c in (string)defaultValue)
{
val.Write(c);
}
}
else if (defaultValue is DateTime)
{
rec.Type = Signature.ELEMENT_TYPE_I8;
val.Write(((DateTime)defaultValue).Ticks);
}
else
{
throw new ArgumentException();
}
rec.Value = this.Blobs.Add(val);
this.Constant.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1010" endline="1019">
}
public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
if (genericTypeArguments != null || genericMethodArguments != null)
{
throw new NotImplementedException();
}
return types[(metadataToken & 0xFFFFFF) - 1];
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1020" endline="1052">
public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
{
if (genericTypeArguments != null || genericMethodArguments != null)
{
throw new NotImplementedException();
}
if ((metadataToken >> 24) == MemberRefTable.Index)
{
foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
{
if (kv.Value == metadataToken)
{
return (MethodBase)kv.Key;
}
}
foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
{
if (kv.Value == metadataToken)
{
return (MethodBase)kv.Key;
}
}
}
if ((metadataToken & 0xFF000000) == 0x06000000)
{
metadataToken = -(metadataToken & 0x00FFFFFF);
}
foreach (Type type in types)
{
MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
if (method != null)
{
return method;
}
}
foreach (Type type in types)
{
MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
if (method != null)
{
return method;
}
}
return ((TypeBuilder)moduleType).LookupMethod(metadataToken);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1111" endline="1123">
public void SetUserEntryPoint(MethodInfo entryPoint)
{
int token = entryPoint.MetadataToken;
if (token < 0)
{
token = -token | 0x06000000;
}
if (symbolWriter != null)
{
symbolWriter.SetUserEntryPoint(new SymbolToken(token));
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
internal int GetSignatureBlobIndex(Signature sig)
{
ByteBuffer bb = new ByteBuffer(16);
sig.WriteSig(this, bb);
return this.Blobs.Add(bb);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1177" endline="1186">
}
private int AddTypeRefByName(int resolutionScope, string ns, string name)
{
TypeRefTable.Record rec = new TypeRefTable.Record();
rec.ResolutionScope = resolutionScope;
rec.TypeName = this.Strings.Add(name);
rec.TypeNameSpace = ns == null ? 0
return 0x01000000 | this.TypeRef.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1187" endline="1229">
public void __Save(PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
{
PopulatePropertyAndEventTables();
IList<CustomAttributeData> attributes = asm.GetCustomAttributesData(null);
if (attributes.Count > 0)
{
int mscorlib = ImportAssemblyRef(universe.Mscorlib);
int[] placeholderTokens = new int[4];
string[] placeholderTypeNames = new string[] { "AssemblyAttributesGoHere", "AssemblyAttributesGoHereM", "AssemblyAttributesGoHereS", "AssemblyAttributesGoHereSM" };
foreach (CustomAttributeData cad in attributes)
{
int index;
if (cad.Constructor.DeclaringType.BaseType == universe.System_Security_Permissions_CodeAccessSecurityAttribute)
{
if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
{
index = 3;
}
else
{
index = 2;
}
}
else if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
{
index = 1;
}
else
{
index = 0;
}
if (placeholderTokens[index] == 0)
{
placeholderTokens[index] = AddTypeRefByName(mscorlib, "System.Runtime.CompilerServices", placeholderTypeNames[index]);
}
SetCustomAttribute(placeholderTokens[index], cad.__ToBuilder());
}
foreach (CustomAttributeData cad in attributes)
{
int index;
if (cad.Constructor.DeclaringType.BaseType == universe.System_Security_Permissions_CodeAccessSecurityAttribute)
{
if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
{
index = 3;
}
else
{
index = 2;
}
}
else if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
{
index = 1;
}
else
{
index = 0;
}
if (placeholderTokens[index] == 0)
{
placeholderTokens[index] = AddTypeRefByName(mscorlib, "System.Runtime.CompilerServices", placeholderTypeNames[index]);
}
SetCustomAttribute(placeholderTokens[index], cad.__ToBuilder());
}
}
FillAssemblyRefTable();
ModuleWriter.WriteModule(null, null, this, PEFileKinds.Dll, portableExecutableKind, imageFileMachine, unmanagedResources, 0);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1230" endline="1239">
public void __AddAssemblyReference(AssemblyName assemblyName)
{
if (referencedAssemblyNames == null)
{
referencedAssemblyNames = new List<AssemblyName>();
}
FindOrAddAssemblyRef(assemblyName);
referencedAssemblyNames.Add((AssemblyName)assemblyName.Clone());
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1240" endline="1263">
public override AssemblyName[] __GetReferencedAssemblies()
{
List<AssemblyName> list = new List<AssemblyName>();
if (referencedAssemblyNames != null)
{
foreach (AssemblyName name in referencedAssemblyNames)
{
if (!list.Contains(name))
{
list.Add(name);
}
}
foreach (AssemblyName name in referencedAssemblyNames)
{
if (!list.Contains(name))
{
list.Add(name);
}
}
}
foreach (Assembly asm in referencedAssemblies.Keys)
{
AssemblyName name = asm.GetName();
if (!list.Contains(name))
{
list.Add(name);
}
}
foreach (Assembly asm in referencedAssemblies.Keys)
{
AssemblyName name = asm.GetName();
if (!list.Contains(name))
{
list.Add(name);
}
}
return list.ToArray();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="41" endline="53">
internal FieldBuilder(TypeBuilder type, string name, Type fieldType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attribs)
{
this.typeBuilder = type;
this.name = name;
this.pseudoToken = type.ModuleBuilder.AllocPseudoToken();
this.nameIndex = type.ModuleBuilder.Strings.Add(name);
this.fieldSig = FieldSignature.Create(fieldType, optionalCustomModifiers, requiredCustomModifiers);
ByteBuffer sig = new ByteBuffer(5);
fieldSig.WriteSig(this.typeBuilder.ModuleBuilder, sig);
this.signature = this.typeBuilder.ModuleBuilder.Blobs.Add(sig);
this.attribs = attribs;
this.typeBuilder.ModuleBuilder.Field.AddVirtualRecord();
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="65" endline="74">
public void __SetDataAndRVA(byte[] data)
{
attribs |= FieldAttributes.HasFieldRVA;
FieldRVATable.Record rec = new FieldRVATable.Record();
rec.RVA = typeBuilder.ModuleBuilder.initializedData.Position;
rec.Field = pseudoToken;
typeBuilder.ModuleBuilder.FieldRVA.AddRecord(rec);
typeBuilder.ModuleBuilder.initializedData.Write(data);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="85" endline="111">
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
{
Universe u = this.Module.universe;
if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_FieldOffsetAttribute)
{
customBuilder = customBuilder.DecodeBlob(this.Module.Assembly);
SetOffset((int)customBuilder.GetConstructorArgument(0));
}
else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
{
MarshalSpec.SetMarshalAsAttribute(typeBuilder.ModuleBuilder, pseudoToken, customBuilder);
attribs |= FieldAttributes.HasFieldMarshal;
}
else if (customBuilder.Constructor.DeclaringType == u.System_NonSerializedAttribute)
{
attribs |= FieldAttributes.NotSerialized;
}
else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
{
attribs |= FieldAttributes.SpecialName;
}
else
{
typeBuilder.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
}
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="112" endline="119">
public void SetOffset(int iOffset)
{
FieldLayoutTable.Record rec = new FieldLayoutTable.Record();
rec.Offset = iOffset;
rec.Field = pseudoToken;
typeBuilder.ModuleBuilder.FieldLayout.AddRecord(rec);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="150" endline="156">
internal void WriteFieldRecords(MetadataWriter mw)
{
mw.Write((short)attribs);
mw.WriteStringIndex(nameIndex);
mw.WriteBlobIndex(signature);
}
</source>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="166" endline="182">
}
internal override int ImportTo(ModuleBuilder other)
{
if (typeBuilder.IsGenericTypeDefinition)
{
return other.ImportMember(TypeBuilder.GetField(typeBuilder, this));
}
else if (other == typeBuilder.ModuleBuilder)
{
return pseudoToken;
}
else
{
return other.ImportMethodOrField(typeBuilder, name, fieldSig);
}
}
</source>
